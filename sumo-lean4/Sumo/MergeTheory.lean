import Sumo.Signature

namespace Sumo

namespace MergeTheory

noncomputable section
def domainDecls : List (Obj × Nat × Obj) :=
 [
  (Const.«instance», 1, Const.«Entity»),
  (Const.«instance», 2, Const.«Class»),
  (Const.«immediateInstance», 1, Const.«Entity»),
  (Const.«immediateInstance», 2, Const.«Class»),
  (Const.«inverse», 1, Const.«BinaryRelation»),
  (Const.«inverse», 2, Const.«BinaryRelation»),
  (Const.«subclass», 1, Const.«Class»),
  (Const.«subclass», 2, Const.«Class»),
  (Const.«immediateSubclass», 1, Const.«Class»),
  (Const.«immediateSubclass», 2, Const.«Class»),
  (Const.«subrelation», 1, Const.«Relation»),
  (Const.«subrelation», 2, Const.«Relation»),
  (Const.«domain», 1, Const.«Relation»),
  (Const.«domain», 2, Const.«PositiveInteger»),
  (Const.«domain», 3, Const.«Class»),
  (Const.«domainSubclass», 1, Const.«Relation»),
  (Const.«domainSubclass», 2, Const.«PositiveInteger»),
  (Const.«domainSubclass», 3, Const.«Class»),
  (Const.«range», 1, Const.«Function»),
  (Const.«range», 2, Const.«Class»),
  (Const.«rangeSubclass», 1, Const.«Function»),
  (Const.«valence», 1, Const.«Relation»),
  (Const.«valence», 2, Const.«PositiveInteger»),
  (Const.«documentation», 1, Const.«Entity»),
  (Const.«documentation», 2, Const.«HumanLanguage»),
  (Const.«documentation», 3, Const.«SymbolicString»),
  (Const.«format», 1, Const.«Language»),
  (Const.«format», 2, Const.«Entity»),
  (Const.«format», 3, Const.«SymbolicString»),
  (Const.«termFormat», 1, Const.«Language»),
  (Const.«termFormat», 2, Const.«Entity»),
  (Const.«termFormat», 3, Const.«SymbolicString»),
  (Const.«disjoint», 1, Const.«Class»),
  (Const.«disjoint», 2, Const.«Class»),
  (Const.«disjointRelation», 1, Const.«Relation»),
  (Const.«disjointRelation», 2, Const.«Relation»),
  (Const.«contraryAttribute», 1, Const.«Attribute»),
  (Const.«exhaustiveAttribute», 2, Const.«Attribute»),
  (Const.«exhaustiveDecomposition», 1, Const.«Class»),
  (Const.«exhaustiveDecomposition», 2, Const.«Class»),
  (Const.«disjointDecomposition», 1, Const.«Class»),
  (Const.«disjointDecomposition», 2, Const.«Class»),
  (Const.«partition», 1, Const.«Class»),
  (Const.«partition», 2, Const.«Class»),
  (Const.«relatedInternalConcept», 1, Const.«Entity»),
  (Const.«relatedInternalConcept», 2, Const.«Entity»),
  (Const.«relatedExternalConcept», 1, Const.«SymbolicString»),
  (Const.«relatedExternalConcept», 2, Const.«Entity»),
  (Const.«relatedExternalConcept», 3, Const.«Language»),
  (Const.«synonymousExternalConcept», 1, Const.«SymbolicString»),
  (Const.«synonymousExternalConcept», 2, Const.«Entity»),
  (Const.«synonymousExternalConcept», 3, Const.«Language»),
  (Const.«subsumingExternalConcept», 1, Const.«SymbolicString»),
  (Const.«subsumingExternalConcept», 2, Const.«Entity»),
  (Const.«subsumingExternalConcept», 3, Const.«Language»),
  (Const.«subsumedExternalConcept», 1, Const.«SymbolicString»),
  (Const.«subsumedExternalConcept», 2, Const.«Entity»),
  (Const.«subsumedExternalConcept», 3, Const.«Language»),
  (Const.«externalImage», 1, Const.«Entity»),
  (Const.«externalImage», 2, Const.«SymbolicString»),
  (Const.«subAttribute», 1, Const.«Attribute»),
  (Const.«subAttribute», 2, Const.«Attribute»),
  (Const.«successorAttribute», 1, Const.«Attribute»),
  (Const.«successorAttribute», 2, Const.«Attribute»),
  (Const.«successorAttributeClosure», 1, Const.«Attribute»),
  (Const.«successorAttributeClosure», 2, Const.«Attribute»),
  (Const.«greaterThanByQuality», 1, Const.«Entity»),
  (Const.«greaterThanByQuality», 2, Const.«Entity»),
  (Const.«greaterThanByQuality», 3, Const.«Attribute»),
  (Const.«entails», 1, Const.«Formula»),
  (Const.«entails», 2, Const.«Formula»),
  (Const.«AssignmentFn», 1, Const.«Function»),
  (Const.«AssignmentFn», 2, Const.«Entity»),
  (Const.«PowerSetFn», 1, Const.«SetOrClass»),
  (Const.«FrontFn», 1, Const.«SelfConnectedObject»),
  (Const.«BackFn», 1, Const.«SelfConnectedObject»),
  (Const.«part», 1, Const.«Object»),
  (Const.«part», 2, Const.«Object»),
  (Const.«properPart», 1, Const.«Object»),
  (Const.«properPart», 2, Const.«Object»),
  (Const.«piece», 1, Const.«Substance»),
  (Const.«piece», 2, Const.«Substance»),
  (Const.«component», 1, Const.«CorpuscularObject»),
  (Const.«component», 2, Const.«CorpuscularObject»),
  (Const.«material», 2, Const.«CorpuscularObject»),
  (Const.«hole», 1, Const.«HoleRegion»),
  (Const.«hole», 2, Const.«SelfConnectedObject»),
  (Const.«properlyFills», 1, Const.«Object»),
  (Const.«properlyFills», 2, Const.«HoleRegion»),
  (Const.«contains», 1, Const.«SelfConnectedObject»),
  (Const.«contains», 2, Const.«Object»),
  (Const.«member», 1, Const.«Physical»),
  (Const.«member», 2, Const.«Collection»),
  (Const.«subCollection», 1, Const.«Collection»),
  (Const.«subCollection», 2, Const.«Collection»),
  (Const.«containsInformation», 1, Const.«ContentBearingPhysical»),
  (Const.«containsInformation», 2, Const.«Proposition»),
  (Const.«containsFormula», 1, Const.«ContentBearingPhysical»),
  (Const.«containsFormula», 2, Const.«Formula»),
  (Const.«language», 1, Const.«ContentBearingPhysical»),
  (Const.«language», 2, Const.«Language»),
  (Const.«leader», 1, Const.«AutonomousAgent»),
  (Const.«leader», 2, Const.«Human»),
  (Const.«property», 1, Const.«Entity»),
  (Const.«property», 2, Const.«Attribute»),
  (Const.«attribute», 1, Const.«Object»),
  (Const.«attribute», 2, Const.«Attribute»),
  (Const.«manner», 1, Const.«Process»),
  (Const.«manner», 2, Const.«Attribute»),
  (Const.«ExtensionFn», 1, Const.«Attribute»),
  (Const.«AttrFn», 2, Const.«Attribute»),
  (Const.«lessThan», 1, Const.«RealNumber»),
  (Const.«lessThan», 2, Const.«RealNumber»),
  (Const.«greaterThan», 1, Const.«RealNumber»),
  (Const.«greaterThan», 2, Const.«RealNumber»),
  (Const.«lessThanOrEqualTo», 1, Const.«RealNumber»),
  (Const.«lessThanOrEqualTo», 2, Const.«RealNumber»),
  (Const.«greaterThanOrEqualTo», 1, Const.«RealNumber»),
  (Const.«greaterThanOrEqualTo», 2, Const.«RealNumber»),
  (Const.«involvedInEvent», 1, Const.«Process»),
  (Const.«involvedInEvent», 2, Const.«Entity»),
  (Const.«agent», 1, Const.«Process»),
  (Const.«agent», 2, Const.«AutonomousAgent»),
  (Const.«destination», 1, Const.«Process»),
  (Const.«destination», 2, Const.«Entity»),
  (Const.«experiencer», 1, Const.«Process»),
  (Const.«experiencer», 2, Const.«AutonomousAgent»),
  (Const.«instrument», 1, Const.«Process»),
  (Const.«instrument», 2, Const.«Object»),
  (Const.«origin», 1, Const.«Process»),
  (Const.«origin», 2, Const.«Object»),
  (Const.«patient», 1, Const.«Process»),
  (Const.«patient», 2, Const.«Entity»),
  (Const.«resource», 1, Const.«Process»),
  (Const.«resource», 2, Const.«Object»),
  (Const.«resourceExhausted», 1, Const.«Process»),
  (Const.«resourceExhausted», 2, Const.«Object»),
  (Const.«result», 1, Const.«Process»),
  (Const.«result», 2, Const.«Entity»),
  (Const.«ProbabilityFn», 1, Const.«Formula»),
  (Const.«conditionalProbability», 1, Const.«Formula»),
  (Const.«conditionalProbability», 2, Const.«Formula»),
  (Const.«conditionalProbability», 3, Const.«RealNumber»),
  (Const.«increasesLikelihood», 1, Const.«Formula»),
  (Const.«increasesLikelihood», 2, Const.«Formula»),
  (Const.«decreasesLikelihood», 1, Const.«Formula»),
  (Const.«decreasesLikelihood», 2, Const.«Formula»),
  (Const.«independentProbability», 1, Const.«Formula»),
  (Const.«independentProbability», 2, Const.«Formula»),
  (Const.«prefers», 1, Const.«CognitiveAgent»),
  (Const.«prefers», 2, Const.«Formula»),
  (Const.«prefers», 3, Const.«Formula»),
  (Const.«inScopeOfInterest», 1, Const.«CognitiveAgent»),
  (Const.«inScopeOfInterest», 2, Const.«Entity»),
  (Const.«needs», 1, Const.«CognitiveAgent»),
  (Const.«needs», 2, Const.«Physical»),
  (Const.«wants», 1, Const.«CognitiveAgent»),
  (Const.«wants», 2, Const.«Physical»),
  (Const.«desires», 1, Const.«CognitiveAgent»),
  (Const.«desires», 2, Const.«Formula»),
  (Const.«considers», 1, Const.«CognitiveAgent»),
  (Const.«considers», 2, Const.«Formula»),
  (Const.«believes», 1, Const.«CognitiveAgent»),
  (Const.«believes», 2, Const.«Formula»),
  (Const.«knows», 1, Const.«CognitiveAgent»),
  (Const.«knows», 2, Const.«Formula»),
  (Const.«says», 1, Const.«CognitiveAgent»),
  (Const.«says», 2, Const.«Formula»),
  (Const.«ListFn», 1, Const.«Entity»),
  (Const.«ListOrderFn», 1, Const.«List»),
  (Const.«ListOrderFn», 2, Const.«PositiveInteger»),
  (Const.«ListLengthFn», 1, Const.«List»),
  (Const.«ListConcatenateFn», 1, Const.«List»),
  (Const.«ListConcatenateFn», 2, Const.«List»),
  (Const.«inList», 1, Const.«Entity»),
  (Const.«inList», 2, Const.«List»),
  (Const.«subList», 1, Const.«List»),
  (Const.«subList», 2, Const.«List»),
  (Const.«SubListFn», 1, Const.«Integer»),
  (Const.«SubListFn», 2, Const.«Integer»),
  (Const.«SubListFn», 3, Const.«List»),
  (Const.«LastFn», 1, Const.«List»),
  (Const.«FirstFn», 1, Const.«List»),
  (Const.«ListSumFn», 1, Const.«List»),
  (Const.«AverageFn», 1, Const.«List»),
  (Const.«initialList», 1, Const.«List»),
  (Const.«initialList», 2, Const.«List»),
  (Const.«identicalListItems», 1, Const.«List»),
  (Const.«identicalListItems», 2, Const.«List»),
  (Const.«closedOn», 1, Const.«Function»),
  (Const.«closedOn», 2, Const.«Class»),
  (Const.«reflexiveOn», 1, Const.«BinaryRelation»),
  (Const.«reflexiveOn», 2, Const.«Class»),
  (Const.«partialOrderingOn», 1, Const.«BinaryRelation»),
  (Const.«partialOrderingOn», 2, Const.«Class»),
  (Const.«totalOrderingOn», 1, Const.«BinaryRelation»),
  (Const.«totalOrderingOn», 2, Const.«Class»),
  (Const.«trichotomizingOn», 1, Const.«BinaryRelation»),
  (Const.«trichotomizingOn», 2, Const.«Class»),
  (Const.«equivalenceRelationOn», 1, Const.«BinaryRelation»),
  (Const.«equivalenceRelationOn», 2, Const.«Class»),
  (Const.«distributes», 1, Const.«BinaryFunction»),
  (Const.«distributes», 2, Const.«BinaryFunction»),
  (Const.«subProcess», 1, Const.«Process»),
  (Const.«subProcess», 2, Const.«Process»),
  (Const.«relatedEvent», 1, Const.«Process»),
  (Const.«relatedEvent», 2, Const.«Process»),
  (Const.«causes», 1, Const.«Process»),
  (Const.«causes», 2, Const.«Process»),
  (Const.«causesProposition», 1, Const.«Formula»),
  (Const.«causesProposition», 2, Const.«Formula»),
  (Const.«copy», 1, Const.«Object»),
  (Const.«copy», 2, Const.«Object»),
  (Const.«time», 1, Const.«Physical»),
  (Const.«time», 2, Const.«TimePosition»),
  (Const.«holdsDuring», 1, Const.«TimePosition»),
  (Const.«holdsDuring», 2, Const.«Formula»),
  (Const.«capability», 2, Const.«CaseRole»),
  (Const.«capability», 3, Const.«Object»),
  (Const.«exploits», 1, Const.«Object»),
  (Const.«exploits», 2, Const.«AutonomousAgent»),
  (Const.«hasPurpose», 1, Const.«Physical»),
  (Const.«hasPurpose», 2, Const.«Formula»),
  (Const.«hasPurposeForAgent», 1, Const.«Physical»),
  (Const.«hasPurposeForAgent», 2, Const.«Formula»),
  (Const.«hasPurposeForAgent», 3, Const.«AutonomousAgent»),
  (Const.«hasSkill», 2, Const.«AutonomousAgent»),
  (Const.«confersNorm», 1, Const.«Entity»),
  (Const.«confersNorm», 2, Const.«Formula»),
  (Const.«confersNorm», 3, Const.«ObjectiveNorm»),
  (Const.«deprivesNorm», 1, Const.«Entity»),
  (Const.«deprivesNorm», 2, Const.«Formula»),
  (Const.«deprivesNorm», 3, Const.«ObjectiveNorm»),
  (Const.«overlapsSpatially», 1, Const.«Object»),
  (Const.«overlapsSpatially», 2, Const.«Object»),
  (Const.«partlyLocated», 1, Const.«Physical»),
  (Const.«partlyLocated», 2, Const.«Object»),
  (Const.«located», 1, Const.«Physical»),
  (Const.«located», 2, Const.«Object»),
  (Const.«eventPartlyLocated», 1, Const.«Process»),
  (Const.«eventPartlyLocated», 2, Const.«Object»),
  (Const.«eventLocated», 1, Const.«Process»),
  (Const.«eventLocated», 2, Const.«Object»),
  (Const.«exactlyLocated», 1, Const.«Physical»),
  (Const.«exactlyLocated», 2, Const.«Object»),
  (Const.«between», 1, Const.«Object»),
  (Const.«between», 2, Const.«Object»),
  (Const.«between», 3, Const.«Object»),
  (Const.«betweenOnPath», 1, Const.«Object»),
  (Const.«betweenOnPath», 2, Const.«Object»),
  (Const.«betweenOnPath», 3, Const.«Object»),
  (Const.«betweenOnPath», 4, Const.«Object»),
  (Const.«traverses», 1, Const.«Object»),
  (Const.«traverses», 2, Const.«Object»),
  (Const.«crosses», 1, Const.«Object»),
  (Const.«crosses», 2, Const.«Object»),
  (Const.«penetrates», 1, Const.«Object»),
  (Const.«penetrates», 2, Const.«Object»),
  (Const.«WhereFn», 1, Const.«Physical»),
  (Const.«WhereFn», 2, Const.«TimePoint»),
  (Const.«possesses», 1, Const.«AutonomousAgent»),
  (Const.«possesses», 2, Const.«Object»),
  (Const.«PropertyFn», 1, Const.«AutonomousAgent»),
  (Const.«prevents», 1, Const.«Process»),
  (Const.«hinders», 1, Const.«Process»),
  (Const.«refers», 1, Const.«Entity»),
  (Const.«refers», 2, Const.«Entity»),
  (Const.«names», 1, Const.«SymbolicString»),
  (Const.«names», 2, Const.«Entity»),
  (Const.«uniqueIdentifier», 1, Const.«SymbolicString»),
  (Const.«uniqueIdentifier», 2, Const.«Entity»),
  (Const.«represents», 1, Const.«Entity»),
  (Const.«represents», 2, Const.«Entity»),
  (Const.«representsForAgent», 1, Const.«Entity»),
  (Const.«representsForAgent», 2, Const.«Entity»),
  (Const.«representsForAgent», 3, Const.«AutonomousAgent»),
  (Const.«representsInLanguage», 1, Const.«LinguisticExpression»),
  (Const.«representsInLanguage», 2, Const.«Entity»),
  (Const.«representsInLanguage», 3, Const.«Language»),
  (Const.«equivalentContentInstance», 1, Const.«ContentBearingPhysical»),
  (Const.«equivalentContentInstance», 2, Const.«ContentBearingPhysical»),
  (Const.«subsumesContentInstance», 1, Const.«ContentBearingPhysical»),
  (Const.«subsumesContentInstance», 2, Const.«ContentBearingPhysical»),
  (Const.«realization», 1, Const.«Process»),
  (Const.«realization», 2, Const.«Proposition»),
  (Const.«expressedInLanguage», 1, Const.«LinguisticExpression»),
  (Const.«expressedInLanguage», 2, Const.«Language»),
  (Const.«subProposition», 1, Const.«Proposition»),
  (Const.«subProposition», 2, Const.«Proposition»),
  (Const.«subPlan», 1, Const.«Plan»),
  (Const.«subPlan», 2, Const.«Plan»),
  (Const.«uses», 1, Const.«Object»),
  (Const.«uses», 2, Const.«AutonomousAgent»),
  (Const.«MultiplicationFn», 1, Const.«RealNumber»),
  (Const.«MultiplicationFn», 2, Const.«RealNumber»),
  (Const.«AdditionFn», 1, Const.«RealNumber»),
  (Const.«AdditionFn», 2, Const.«RealNumber»),
  (Const.«SubtractionFn», 1, Const.«RealNumber»),
  (Const.«SubtractionFn», 2, Const.«RealNumber»),
  (Const.«DivisionFn», 1, Const.«RealNumber»),
  (Const.«DivisionFn», 2, Const.«RealNumber»),
  (Const.«AbsoluteValueFn», 1, Const.«RealNumber»),
  (Const.«CeilingFn», 1, Const.«RealNumber»),
  (Const.«CosineFn», 1, Const.«PlaneAngleMeasure»),
  (Const.«DenominatorFn», 1, Const.«RealNumber»),
  (Const.«ExponentiationFn», 1, Const.«RealNumber»),
  (Const.«ExponentiationFn», 2, Const.«Integer»),
  (Const.«FloorFn», 1, Const.«RealNumber»),
  (Const.«GreatestCommonDivisorFn», 1, Const.«Integer»),
  (Const.«multiplicativeFactor», 1, Const.«Integer»),
  (Const.«multiplicativeFactor», 2, Const.«Integer»),
  (Const.«ImaginaryPartFn», 1, Const.«ComplexNumber»),
  (Const.«IntegerSquareRootFn», 1, Const.«RealNumber»),
  (Const.«LeastCommonMultipleFn», 1, Const.«Integer»),
  (Const.«LogFn», 1, Const.«RealNumber»),
  (Const.«LogFn», 2, Const.«PositiveInteger»),
  (Const.«MaxFn», 1, Const.«Number»),
  (Const.«MaxFn», 2, Const.«Number»),
  (Const.«MinFn», 1, Const.«Number»),
  (Const.«MinFn», 2, Const.«Number»),
  (Const.«NumeratorFn», 1, Const.«RealNumber»),
  (Const.«RationalNumberFn», 1, Const.«Number»),
  (Const.«RealNumberFn», 1, Const.«Number»),
  (Const.«ReciprocalFn», 1, Const.«RealNumber»),
  (Const.«RemainderFn», 1, Const.«Integer»),
  (Const.«RemainderFn», 2, Const.«Integer»),
  (Const.«RoundFn», 1, Const.«RealNumber»),
  (Const.«SignumFn», 1, Const.«RealNumber»),
  (Const.«SineFn», 1, Const.«RealNumber»),
  (Const.«SquareRootFn», 1, Const.«RealNumber»),
  (Const.«TangentFn», 1, Const.«RealNumber»),
  (Const.«ArcTangentFn», 1, Const.«RealNumber»),
  (Const.«ArcCosineFn», 1, Const.«RealNumber»),
  (Const.«ArcSineFn», 1, Const.«RealNumber»),
  (Const.«identityElement», 1, Const.«BinaryFunction»),
  (Const.«identityElement», 2, Const.«Integer»),
  (Const.«SuccessorFn», 1, Const.«Integer»),
  (Const.«PredecessorFn», 1, Const.«Integer»),
  (Const.«average», 1, Const.«List»),
  (Const.«average», 2, Const.«RealNumber»),
  (Const.«subset», 1, Const.«Set»),
  (Const.«subset», 2, Const.«Set»),
  (Const.«element», 1, Const.«Entity»),
  (Const.«element», 2, Const.«Set»),
  (Const.«UnionFn», 1, Const.«SetOrClass»),
  (Const.«UnionFn», 2, Const.«SetOrClass»),
  (Const.«IntersectionFn», 1, Const.«SetOrClass»),
  (Const.«IntersectionFn», 2, Const.«SetOrClass»),
  (Const.«RelativeComplementFn», 1, Const.«SetOrClass»),
  (Const.«RelativeComplementFn», 2, Const.«SetOrClass»),
  (Const.«ComplementFn», 1, Const.«SetOrClass»),
  (Const.«CardinalityFn», 1, Const.«SetOrClass»),
  (Const.«KappaFn», 1, Const.«SymbolicString»),
  (Const.«KappaFn», 2, Const.«Formula»),
  (Const.«links», 1, Const.«GraphNode»),
  (Const.«links», 2, Const.«GraphNode»),
  (Const.«links», 3, Const.«GraphArc»),
  (Const.«graphPart», 1, Const.«GraphElement»),
  (Const.«graphPart», 2, Const.«Graph»),
  (Const.«subGraph», 1, Const.«Graph»),
  (Const.«subGraph», 2, Const.«Graph»),
  (Const.«pathLength», 1, Const.«GraphPath»),
  (Const.«pathLength», 2, Const.«PositiveInteger»),
  (Const.«InitialNodeFn», 1, Const.«GraphArc»),
  (Const.«TerminalNodeFn», 1, Const.«GraphArc»),
  (Const.«BeginNodeFn», 1, Const.«GraphPath»),
  (Const.«EndNodeFn», 1, Const.«GraphPath»),
  (Const.«arcWeight», 1, Const.«GraphArc»),
  (Const.«arcWeight», 2, Const.«RealNumber»),
  (Const.«PathWeightFn», 1, Const.«GraphPath»),
  (Const.«MinimalWeightedPathFn», 1, Const.«GraphNode»),
  (Const.«MinimalWeightedPathFn», 2, Const.«GraphNode»),
  (Const.«MaximalWeightedPathFn», 1, Const.«GraphNode»),
  (Const.«MaximalWeightedPathFn», 2, Const.«GraphNode»),
  (Const.«GraphPathFn», 1, Const.«GraphNode»),
  (Const.«GraphPathFn», 2, Const.«GraphNode»),
  (Const.«CutSetFn», 1, Const.«Graph»),
  (Const.«MinimalCutSetFn», 1, Const.«Graph»),
  (Const.«abstractCounterpart», 1, Const.«Abstract»),
  (Const.«abstractCounterpart», 2, Const.«Physical»),
  (Const.«subSystem», 1, Const.«PhysicalSystem»),
  (Const.«subSystem», 2, Const.«PhysicalSystem»),
  (Const.«systemPart», 1, Const.«Physical»),
  (Const.«systemPart», 2, Const.«PhysicalSystem»),
  (Const.«graphMeasure», 1, Const.«Graph»),
  (Const.«graphMeasure», 2, Const.«UnitOfMeasure»),
  (Const.«MeasureFn», 1, Const.«RealNumber»),
  (Const.«MeasureFn», 2, Const.«UnitOfMeasure»),
  (Const.«KiloFn», 1, Const.«UnitOfMeasure»),
  (Const.«MegaFn», 1, Const.«UnitOfMeasure»),
  (Const.«GigaFn», 1, Const.«UnitOfMeasure»),
  (Const.«TeraFn», 1, Const.«UnitOfMeasure»),
  (Const.«MilliFn», 1, Const.«UnitOfMeasure»),
  (Const.«MicroFn», 1, Const.«UnitOfMeasure»),
  (Const.«NanoFn», 1, Const.«UnitOfMeasure»),
  (Const.«PicoFn», 1, Const.«UnitOfMeasure»),
  (Const.«IntervalFn», 1, Const.«ConstantQuantity»),
  (Const.«IntervalFn», 2, Const.«ConstantQuantity»),
  (Const.«UnitFn», 1, Const.«PhysicalQuantity»),
  (Const.«PerFn», 1, Const.«PhysicalQuantity»),
  (Const.«PerFn», 2, Const.«PhysicalQuantity»),
  (Const.«DensityFn», 1, Const.«MassMeasure»),
  (Const.«DensityFn», 2, Const.«VolumeMeasure»),
  (Const.«SpeedFn», 1, Const.«LengthMeasure»),
  (Const.«SpeedFn», 2, Const.«TimeDuration»),
  (Const.«VelocityFn», 1, Const.«LengthMeasure»),
  (Const.«VelocityFn», 2, Const.«TimeDuration»),
  (Const.«VelocityFn», 3, Const.«Region»),
  (Const.«VelocityFn», 4, Const.«DirectionalAttribute»),
  (Const.«weight», 1, Const.«SelfConnectedObject»),
  (Const.«weight», 2, Const.«MassMeasure»),
  (Const.«measure», 1, Const.«Physical»),
  (Const.«measure», 2, Const.«PhysicalQuantity»),
  (Const.«age», 1, Const.«Physical»),
  (Const.«age», 2, Const.«TimeDuration»),
  (Const.«linearExtent», 1, Const.«Physical»),
  (Const.«linearExtent», 2, Const.«LengthMeasure»),
  (Const.«width», 1, Const.«Physical»),
  (Const.«width», 2, Const.«LengthMeasure»),
  (Const.«height», 1, Const.«SelfConnectedObject»),
  (Const.«height», 2, Const.«LengthMeasure»),
  (Const.«length», 1, Const.«Physical»),
  (Const.«length», 2, Const.«LengthMeasure»),
  (Const.«AmountsFn», 2, Const.«CorpuscularObject»),
  (Const.«AmountsFn», 3, Const.«UnitOfMass»),
  (Const.«amount», 2, Const.«CorpuscularObject»),
  (Const.«amount», 3, Const.«MassMeasure»),
  (Const.«shape», 1, Const.«Physical»),
  (Const.«shape», 2, Const.«ShapeAttribute»),
  (Const.«CenterOfCircleFn», 1, Const.«Circle»),
  (Const.«radius», 1, Const.«Circle»),
  (Const.«radius», 2, Const.«LengthMeasure»),
  (Const.«diameter», 1, Const.«Circle»),
  (Const.«diameter», 2, Const.«LengthMeasure»),
  (Const.«distance», 1, Const.«Physical»),
  (Const.«distance», 2, Const.«Physical»),
  (Const.«distance», 3, Const.«LengthMeasure»),
  (Const.«altitude», 1, Const.«Physical»),
  (Const.«altitude», 2, Const.«Physical»),
  (Const.«altitude», 3, Const.«LengthMeasure»),
  (Const.«depth», 1, Const.«Physical»),
  (Const.«depth», 2, Const.«Physical»),
  (Const.«depth», 3, Const.«LengthMeasure»),
  (Const.«larger», 1, Const.«Object»),
  (Const.«larger», 2, Const.«Object»),
  (Const.«smaller», 1, Const.«Object»),
  (Const.«smaller», 2, Const.«Object»),
  (Const.«monetaryValue», 1, Const.«Physical»),
  (Const.«monetaryValue», 2, Const.«CurrencyMeasure»),
  (Const.«WealthFn», 1, Const.«AutonomousAgent»),
  (Const.«barometricPressure», 1, Const.«Object»),
  (Const.«barometricPressure», 2, Const.«PhysicalQuantity»),
  (Const.«duration», 1, Const.«TimeInterval»),
  (Const.«duration», 2, Const.«TimeDuration»),
  (Const.«frequency», 2, Const.«TimeDuration»),
  (Const.«temporalPart», 1, Const.«TimePosition»),
  (Const.«temporalPart», 2, Const.«TimePosition»),
  (Const.«BeginFn», 1, Const.«TimeInterval»),
  (Const.«EndFn», 1, Const.«TimeInterval»),
  (Const.«starts», 1, Const.«TimeInterval»),
  (Const.«starts», 2, Const.«TimeInterval»),
  (Const.«finishes», 1, Const.«TimeInterval»),
  (Const.«finishes», 2, Const.«TimeInterval»),
  (Const.«finishesDuring», 1, Const.«TimeInterval»),
  (Const.«finishesDuring», 2, Const.«TimeInterval»),
  (Const.«startsDuring», 1, Const.«TimeInterval»),
  (Const.«startsDuring», 2, Const.«TimeInterval»),
  (Const.«before», 1, Const.«TimePoint»),
  (Const.«before», 2, Const.«TimePoint»),
  (Const.«beforeOrEqual», 1, Const.«TimePoint»),
  (Const.«beforeOrEqual», 2, Const.«TimePoint»),
  (Const.«temporallyBetween», 1, Const.«TimePoint»),
  (Const.«temporallyBetween», 2, Const.«TimePoint»),
  (Const.«temporallyBetween», 3, Const.«TimePoint»),
  (Const.«temporallyBetweenOrEqual», 1, Const.«TimePoint»),
  (Const.«temporallyBetweenOrEqual», 2, Const.«TimePoint»),
  (Const.«temporallyBetweenOrEqual», 3, Const.«TimePoint»),
  (Const.«overlapsTemporally», 1, Const.«TimeInterval»),
  (Const.«overlapsTemporally», 2, Const.«TimeInterval»),
  (Const.«during», 1, Const.«TimeInterval»),
  (Const.«during», 2, Const.«TimeInterval»),
  (Const.«meetsTemporally», 1, Const.«TimeInterval»),
  (Const.«meetsTemporally», 2, Const.«TimeInterval»),
  (Const.«earlier», 1, Const.«TimeInterval»),
  (Const.«earlier», 2, Const.«TimeInterval»),
  (Const.«cooccur», 1, Const.«Physical»),
  (Const.«cooccur», 2, Const.«Physical»),
  (Const.«TimeIntervalFn», 1, Const.«TimePoint»),
  (Const.«TimeIntervalFn», 2, Const.«TimePoint»),
  (Const.«WhenFn», 1, Const.«Physical»),
  (Const.«PastFn», 1, Const.«TimePosition»),
  (Const.«ImmediatePastFn», 1, Const.«TimePosition»),
  (Const.«FutureFn», 1, Const.«TimePosition»),
  (Const.«ImmediateFutureFn», 1, Const.«TimePosition»),
  (Const.«date», 1, Const.«Physical»),
  (Const.«date», 2, Const.«Day»),
  (Const.«YearFn», 1, Const.«Integer»),
  (Const.«DayFn», 1, Const.«PositiveInteger»),
  (Const.«HourFn», 1, Const.«NonnegativeInteger»),
  (Const.«MinuteFn», 1, Const.«NonnegativeInteger»),
  (Const.«SecondFn», 1, Const.«PositiveInteger»),
  (Const.«MorningFn», 1, Const.«Day»),
  (Const.«AfternoonFn», 1, Const.«Day»),
  (Const.«EveningFn», 1, Const.«Day»),
  (Const.«WeekFn», 1, Const.«PositiveInteger»),
  (Const.«QuarterFn», 1, Const.«PositiveInteger»),
  (Const.«successorClass», 1, Const.«Class»),
  (Const.«successorClass», 2, Const.«Class»),
  (Const.«TemporalCompositionFn», 1, Const.«TimeInterval»),
  (Const.«connected», 1, Const.«Object»),
  (Const.«connected», 2, Const.«Object»),
  (Const.«connects», 1, Const.«Object»),
  (Const.«connects», 2, Const.«Object»),
  (Const.«connects», 3, Const.«Object»),
  (Const.«meetsSpatially», 1, Const.«Object»),
  (Const.«meetsSpatially», 2, Const.«Object»),
  (Const.«overlapsPartially», 1, Const.«Object»),
  (Const.«overlapsPartially», 2, Const.«Object»),
  (Const.«superficialPart», 1, Const.«Object»),
  (Const.«superficialPart», 2, Const.«Object»),
  (Const.«surface», 1, Const.«SelfConnectedObject»),
  (Const.«surface», 2, Const.«SelfConnectedObject»),
  (Const.«interiorPart», 1, Const.«Object»),
  (Const.«interiorPart», 2, Const.«Object»),
  (Const.«bottom», 1, Const.«SelfConnectedObject»),
  (Const.«bottom», 2, Const.«SelfConnectedObject»),
  (Const.«top», 1, Const.«SelfConnectedObject»),
  (Const.«top», 2, Const.«SelfConnectedObject»),
  (Const.«side», 1, Const.«SelfConnectedObject»),
  (Const.«side», 2, Const.«SelfConnectedObject»),
  (Const.«MereologicalSumFn», 1, Const.«Object»),
  (Const.«MereologicalSumFn», 2, Const.«Object»),
  (Const.«MereologicalProductFn», 1, Const.«Object»),
  (Const.«MereologicalProductFn», 2, Const.«Object»),
  (Const.«MereologicalDifferenceFn», 1, Const.«Object»),
  (Const.«MereologicalDifferenceFn», 2, Const.«Object»),
  (Const.«HoleHostFn», 1, Const.«HoleRegion»),
  (Const.«partiallyFills», 1, Const.«Object»),
  (Const.«partiallyFills», 2, Const.«HoleRegion»),
  (Const.«completelyFills», 1, Const.«Object»),
  (Const.«completelyFills», 2, Const.«HoleRegion»),
  (Const.«fills», 1, Const.«Object»),
  (Const.«fills», 2, Const.«HoleRegion»),
  (Const.«HoleSkinFn», 1, Const.«HoleRegion»),
  (Const.«pathologicSymptom», 1, Const.«DiseaseOrSyndrome»),
  (Const.«expects», 1, Const.«CognitiveAgent»),
  (Const.«expects», 2, Const.«Formula»),
  (Const.«moves», 1, Const.«Motion»),
  (Const.«moves», 2, Const.«Object»),
  (Const.«changesLocation», 1, Const.«Translocation»),
  (Const.«changesLocation», 2, Const.«Object»),
  (Const.«path», 1, Const.«Motion»),
  (Const.«path», 2, Const.«Object»),
  (Const.«surfaceWindSpeed», 1, Const.«Object»),
  (Const.«surfaceWindSpeed», 2, Const.«PhysicalQuantity»),
  (Const.«objectTransferred», 1, Const.«Transfer»),
  (Const.«objectTransferred», 2, Const.«Object»),
  (Const.«grasps», 1, Const.«Animal»),
  (Const.«grasps», 2, Const.«Object»),
  (Const.«transactionAmount», 1, Const.«FinancialTransaction»),
  (Const.«transactionAmount», 2, Const.«CurrencyMeasure»),
  (Const.«objectAttached», 1, Const.«Process»),
  (Const.«objectAttached», 2, Const.«Entity»),
  (Const.«objectDetached», 1, Const.«Process»),
  (Const.«objectDetached», 2, Const.«Entity»),
  (Const.«attends», 1, Const.«Demonstrating»),
  (Const.«attends», 2, Const.«Human»),
  (Const.«atomicNumber», 2, Const.«PositiveInteger»),
  (Const.«boilingPoint», 2, Const.«TemperatureMeasure»),
  (Const.«meltingPoint», 2, Const.«TemperatureMeasure»),
  (Const.«geographicSubregion», 1, Const.«GeographicArea»),
  (Const.«geographicSubregion», 2, Const.«GeographicArea»),
  (Const.«geopoliticalSubdivision», 1, Const.«GeopoliticalArea»),
  (Const.«geopoliticalSubdivision», 2, Const.«GeopoliticalArea»),
  (Const.«developmentalForm», 1, Const.«OrganicObject»),
  (Const.«developmentalForm», 2, Const.«DevelopmentalAttribute»),
  (Const.«inhabits», 1, Const.«Organism»),
  (Const.«inhabits», 2, Const.«Object»),
  (Const.«home», 1, Const.«Human»),
  (Const.«home», 2, Const.«PermanentResidence»),
  (Const.«stays», 1, Const.«Human»),
  (Const.«stays», 2, Const.«TemporaryResidence»),
  (Const.«BodySideFn», 1, Const.«AntiSymmetricPositionalAttribute»),
  (Const.«authors», 1, Const.«AutonomousAgent»),
  (Const.«editor», 1, Const.«AutonomousAgent»),
  (Const.«publishes», 1, Const.«Organization»),
  (Const.«EditionFn», 2, Const.«PositiveInteger»),
  (Const.«covers», 1, Const.«Object»),
  (Const.«covers», 2, Const.«Object»),
  (Const.«wears», 1, Const.«Animal»),
  (Const.«wears», 2, Const.«WearableItem»),
  (Const.«engineeringSubcomponent», 1, Const.«EngineeringComponent»),
  (Const.«engineeringSubcomponent», 2, Const.«EngineeringComponent»),
  (Const.«connectedEngineeringComponents», 1, Const.«EngineeringComponent»),
  (Const.«connectedEngineeringComponents», 2, Const.«EngineeringComponent»),
  (Const.«connectsEngineeringComponents», 1, Const.«EngineeringConnection»),
  (Const.«connectsEngineeringComponents», 2, Const.«EngineeringComponent»),
  (Const.«connectsEngineeringComponents», 3, Const.«EngineeringComponent»),
  (Const.«ImmediateFamilyFn», 1, Const.«Human»),
  (Const.«relative», 1, Const.«Organism»),
  (Const.«relative», 2, Const.«Organism»),
  (Const.«familyRelation», 1, Const.«Organism»),
  (Const.«familyRelation», 2, Const.«Organism»),
  (Const.«ancestor», 1, Const.«Organism»),
  (Const.«ancestor», 2, Const.«Organism»),
  (Const.«parent», 1, Const.«Organism»),
  (Const.«parent», 2, Const.«Organism»),
  (Const.«mother», 1, Const.«Organism»),
  (Const.«mother», 2, Const.«Organism»),
  (Const.«father», 1, Const.«Organism»),
  (Const.«father», 2, Const.«Organism»),
  (Const.«daughter», 1, Const.«Organism»),
  (Const.«daughter», 2, Const.«Organism»),
  (Const.«son», 1, Const.«Organism»),
  (Const.«son», 2, Const.«Organism»),
  (Const.«sibling», 1, Const.«Organism»),
  (Const.«sibling», 2, Const.«Organism»),
  (Const.«brother», 1, Const.«Man»),
  (Const.«brother», 2, Const.«Human»),
  (Const.«sister», 1, Const.«Woman»),
  (Const.«sister», 2, Const.«Human»),
  (Const.«legalRelation», 1, Const.«Human»),
  (Const.«legalRelation», 2, Const.«Human»),
  (Const.«acquaintance», 1, Const.«Human»),
  (Const.«acquaintance», 2, Const.«Human»),
  (Const.«mutualAcquaintance», 1, Const.«Human»),
  (Const.«mutualAcquaintance», 2, Const.«Human»),
  (Const.«spouse», 1, Const.«Human»),
  (Const.«spouse», 2, Const.«Human»),
  (Const.«husband», 1, Const.«Man»),
  (Const.«husband», 2, Const.«Woman»),
  (Const.«wife», 1, Const.«Woman»),
  (Const.«wife», 2, Const.«Man»),
  (Const.«employs», 1, Const.«AutonomousAgent»),
  (Const.«employs», 2, Const.«CognitiveAgent»),
  (Const.«GovernmentFn», 1, Const.«GeopoliticalArea»),
  (Const.«subOrganization», 1, Const.«Organization»),
  (Const.«subOrganization», 2, Const.«Organization»),
  (Const.«citizen», 1, Const.«Human»),
  (Const.«citizen», 2, Const.«Nation»),
  (Const.«premise», 1, Const.«Argument»),
  (Const.«premise», 2, Const.«Proposition»),
  (Const.«PremisesFn», 1, Const.«Argument»),
  (Const.«conclusion», 1, Const.«Argument»),
  (Const.«conclusion», 2, Const.«Proposition»),
  (Const.«consistent», 1, Const.«Proposition»),
  (Const.«consistent», 2, Const.«Proposition»),
  (Const.«orientation», 1, Const.«Object»),
  (Const.«orientation», 2, Const.«Object»),
  (Const.«orientation», 3, Const.«PositionalAttribute»),
  (Const.«direction», 1, Const.«Process»),
  (Const.«direction», 2, Const.«PositionalAttribute»),
  (Const.«faces», 1, Const.«Object»),
  (Const.«faces», 2, Const.«DirectionalAttribute»),
  (Const.«truth», 1, Const.«Sentence»),
  (Const.«truth», 2, Const.«TruthValue»),
  (Const.«RelativeTimeFn», 1, Const.«TimePosition»),
  (Const.«RelativeTimeFn», 2, Const.«TimeZone»),
  (Const.«occupiesPosition», 1, Const.«Human»),
  (Const.«occupiesPosition», 2, Const.«Position»),
  (Const.«occupiesPosition», 3, Const.«Organization»),
  (Const.«modalAttribute», 1, Const.«Formula»),
  (Const.«modalAttribute», 2, Const.«NormativeAttribute»),
  (Const.«holdsRight», 1, Const.«Formula»),
  (Const.«holdsRight», 2, Const.«CognitiveAgent»),
  (Const.«confersRight», 1, Const.«Formula»),
  (Const.«confersRight», 2, Const.«Entity»),
  (Const.«confersRight», 3, Const.«CognitiveAgent»),
  (Const.«holdsObligation», 1, Const.«Formula»),
  (Const.«holdsObligation», 2, Const.«CognitiveAgent»),
  (Const.«confersObligation», 1, Const.«Formula»),
  (Const.«confersObligation», 2, Const.«Entity»),
  (Const.«confersObligation», 3, Const.«CognitiveAgent»),
  (Const.«geometricPart», 1, Const.«GeometricFigure»),
  (Const.«geometricPart», 2, Const.«GeometricFigure»),
  (Const.«pointOfFigure», 1, Const.«GeometricPoint»),
  (Const.«pointOfFigure», 2, Const.«GeometricFigure»),
  (Const.«angleOfFigure», 1, Const.«TwoDimensionalAngle»),
  (Const.«angleOfFigure», 2, Const.«GeometricFigure»),
  (Const.«pointOfIntersection», 1, Const.«OneDimensionalFigure»),
  (Const.«pointOfIntersection», 2, Const.«OneDimensionalFigure»),
  (Const.«pointOfIntersection», 3, Const.«GeometricPoint»),
  (Const.«parallel», 1, Const.«StraightLine»),
  (Const.«parallel», 2, Const.«StraightLine»),
  (Const.«angularMeasure», 1, Const.«TwoDimensionalAngle»),
  (Const.«angularMeasure», 2, Const.«AngleMeasure»),
  (Const.«relativeAngle», 1, Const.«Object»),
  (Const.«relativeAngle», 2, Const.«Object»),
  (Const.«relativeAngle», 3, Const.«RealNumber»),
  (Const.«physicalEnd», 1, Const.«Object»),
  (Const.«physicalEnd», 2, Const.«Object»),
  (Const.«lineMeasure», 1, Const.«OneDimensionalFigure»),
  (Const.«lineMeasure», 2, Const.«LengthMeasure»),
  (Const.«geometricDistance», 1, Const.«GeometricPoint»),
  (Const.«geometricDistance», 2, Const.«GeometricPoint»),
  (Const.«geometricDistance», 3, Const.«LengthMeasure»),
  (Const.«comment», 1, Const.«Entity»),
  (Const.«comment», 2, Const.«SymbolicString»),
  (Const.«comment», 3, Const.«SymbolicString»),
  (Const.«minValue», 1, Const.«Predicate»),
  (Const.«minValue», 2, Const.«Integer»),
  (Const.«minValue», 3, Const.«Quantity»),
  (Const.«maxValue», 1, Const.«Predicate»),
  (Const.«maxValue», 2, Const.«Integer»),
  (Const.«maxValue», 3, Const.«Quantity»),
  (Const.«defaultMinValue», 1, Const.«Predicate»),
  (Const.«defaultMinValue», 2, Const.«Integer»),
  (Const.«defaultMinValue», 3, Const.«Quantity»),
  (Const.«defaultMaxValue», 1, Const.«Predicate»),
  (Const.«defaultMaxValue», 2, Const.«Integer»),
  (Const.«defaultMaxValue», 3, Const.«Quantity»),
  (Const.«defaultValue», 1, Const.«Predicate»),
  (Const.«defaultValue», 2, Const.«Integer»),
  (Const.«defaultValue», 3, Const.«Quantity»)
 ]
def domainSubclassDecls : List (Obj × Nat × Obj) :=
 [
  (Const.«rangeSubclass», 2, Const.«Class»),
  (Const.«exhaustiveAttribute», 1, Const.«Attribute»),
  (Const.«material», 1, Const.«Substance»),
  (Const.«ingredient», 1, Const.«Substance»),
  (Const.«ingredient», 2, Const.«Substance»),
  (Const.«substanceElement», 1, Const.«CorpuscularObject»),
  (Const.«substanceElement», 2, Const.«Substance»),
  (Const.«AttrFn», 1, Const.«Object»),
  (Const.«causesSubclass», 1, Const.«Process»),
  (Const.«causesSubclass», 2, Const.«Process»),
  (Const.«capability», 1, Const.«Process»),
  (Const.«hasSkill», 1, Const.«Process»),
  (Const.«precondition», 1, Const.«Process»),
  (Const.«precondition», 2, Const.«Process»),
  (Const.«hindersSubclass», 1, Const.«Process»),
  (Const.«hindersSubclass», 2, Const.«Process»),
  (Const.«preventsSubclass», 1, Const.«Process»),
  (Const.«preventsSubclass», 2, Const.«Process»),
  (Const.«prevents», 2, Const.«Process»),
  (Const.«hinders», 2, Const.«Process»),
  (Const.«equivalentContentClass», 1, Const.«ContentBearingPhysical»),
  (Const.«equivalentContentClass», 2, Const.«ContentBearingPhysical»),
  (Const.«subsumesContentClass», 1, Const.«ContentBearingPhysical»),
  (Const.«subsumesContentClass», 2, Const.«ContentBearingPhysical»),
  (Const.«GeneralizedUnionFn», 1, Const.«SetOrClass»),
  (Const.«GeneralizedIntersectionFn», 1, Const.«SetOrClass»),
  (Const.«AmountsFn», 1, Const.«Substance»),
  (Const.«amount», 1, Const.«Substance»),
  (Const.«frequency», 1, Const.«Process»),
  (Const.«RecurrentTimeIntervalFn», 1, Const.«TimeInterval»),
  (Const.«RecurrentTimeIntervalFn», 2, Const.«TimeInterval»),
  (Const.«MonthFn», 1, Const.«Month»),
  (Const.«MonthFn», 2, Const.«Year»),
  (Const.«DayFn», 2, Const.«Month»),
  (Const.«HourFn», 2, Const.«Day»),
  (Const.«MinuteFn», 2, Const.«Hour»),
  (Const.«SecondFn», 2, Const.«Minute»),
  (Const.«WeekFn», 2, Const.«Year»),
  (Const.«QuarterFn», 2, Const.«Year»),
  (Const.«TemporalCompositionFn», 2, Const.«TimeInterval»),
  (Const.«pathologicSymptom», 2, Const.«PathologicProcess»),
  (Const.«ImpairmentFn», 1, Const.«PhysiologicProcess»),
  (Const.«SenseImpairmentFn», 1, Const.«Perception»),
  (Const.«SenseInabilityFn», 1, Const.«Perception»),
  (Const.«atomicNumber», 1, Const.«ElementalSubstance»),
  (Const.«boilingPoint», 1, Const.«PureSubstance»),
  (Const.«meltingPoint», 1, Const.«PureSubstance»),
  (Const.«FoodForFn», 1, Const.«Organism»),
  (Const.«BodySideFn», 2, Const.«BodyPart»),
  (Const.«authors», 2, Const.«ContentBearingObject»),
  (Const.«editor», 2, Const.«Text»),
  (Const.«publishes», 2, Const.«Text»),
  (Const.«EditionFn», 1, Const.«ContentBearingObject»),
  (Const.«version», 1, Const.«Artifact»),
  (Const.«version», 2, Const.«Artifact»),
  (Const.«ImpairedBodyPartFn», 1, Const.«BodyPart»),
  (Const.«DeadOrMissingBodyPartFn», 1, Const.«BodyPart»),
  (Const.«MakingFn», 1, Const.«Making»),
  (Const.«DeadFn», 1, Const.«OrganicObject»)
 ]
def rangeDecls : List (Obj × Obj) :=
 [
  (Const.«AssignmentFn», Const.«Entity»),
  (Const.«FrontFn», Const.«SelfConnectedObject»),
  (Const.«BackFn», Const.«SelfConnectedObject»),
  (Const.«ExtensionFn», Const.«Class»),
  (Const.«ProbabilityFn», Const.«RealNumber»),
  (Const.«ListFn», Const.«List»),
  (Const.«ListOrderFn», Const.«Entity»),
  (Const.«ListLengthFn», Const.«NonnegativeInteger»),
  (Const.«ListConcatenateFn», Const.«List»),
  (Const.«SubListFn», Const.«List»),
  (Const.«LastFn», Const.«Entity»),
  (Const.«FirstFn», Const.«Entity»),
  (Const.«ListSumFn», Const.«RealNumber»),
  (Const.«AverageFn», Const.«RealNumber»),
  (Const.«WhereFn», Const.«Region»),
  (Const.«PropertyFn», Const.«Set»),
  (Const.«MultiplicationFn», Const.«RealNumber»),
  (Const.«AdditionFn», Const.«RealNumber»),
  (Const.«SubtractionFn», Const.«RealNumber»),
  (Const.«DivisionFn», Const.«RealNumber»),
  (Const.«AbsoluteValueFn», Const.«NonnegativeRealNumber»),
  (Const.«CeilingFn», Const.«Integer»),
  (Const.«CosineFn», Const.«RealNumber»),
  (Const.«DenominatorFn», Const.«Integer»),
  (Const.«ExponentiationFn», Const.«RealNumber»),
  (Const.«FloorFn», Const.«Integer»),
  (Const.«GreatestCommonDivisorFn», Const.«Integer»),
  (Const.«ImaginaryPartFn», Const.«ImaginaryNumber»),
  (Const.«IntegerSquareRootFn», Const.«NonnegativeInteger»),
  (Const.«LeastCommonMultipleFn», Const.«Integer»),
  (Const.«LogFn», Const.«RealNumber»),
  (Const.«MaxFn», Const.«Number»),
  (Const.«MinFn», Const.«Number»),
  (Const.«NumeratorFn», Const.«Integer»),
  (Const.«RationalNumberFn», Const.«RationalNumber»),
  (Const.«RealNumberFn», Const.«RealNumber»),
  (Const.«ReciprocalFn», Const.«RealNumber»),
  (Const.«RemainderFn», Const.«Integer»),
  (Const.«RoundFn», Const.«RealNumber»),
  (Const.«SignumFn», Const.«Integer»),
  (Const.«SineFn», Const.«RealNumber»),
  (Const.«SquareRootFn», Const.«RealNumber»),
  (Const.«TangentFn», Const.«RealNumber»),
  (Const.«ArcTangentFn», Const.«RealNumber»),
  (Const.«ArcCosineFn», Const.«RealNumber»),
  (Const.«ArcSineFn», Const.«RealNumber»),
  (Const.«SuccessorFn», Const.«Integer»),
  (Const.«PredecessorFn», Const.«Integer»),
  (Const.«UnionFn», Const.«SetOrClass»),
  (Const.«IntersectionFn», Const.«SetOrClass»),
  (Const.«RelativeComplementFn», Const.«SetOrClass»),
  (Const.«ComplementFn», Const.«SetOrClass»),
  (Const.«GeneralizedUnionFn», Const.«SetOrClass»),
  (Const.«GeneralizedIntersectionFn», Const.«SetOrClass»),
  (Const.«CardinalityFn», Const.«Integer»),
  (Const.«KappaFn», Const.«Class»),
  (Const.«InitialNodeFn», Const.«GraphNode»),
  (Const.«TerminalNodeFn», Const.«GraphNode»),
  (Const.«BeginNodeFn», Const.«GraphNode»),
  (Const.«EndNodeFn», Const.«GraphNode»),
  (Const.«PathWeightFn», Const.«RealNumber»),
  (Const.«MinimalWeightedPathFn», Const.«GraphPath»),
  (Const.«MaximalWeightedPathFn», Const.«GraphPath»),
  (Const.«MeasureFn», Const.«PhysicalQuantity»),
  (Const.«KiloFn», Const.«UnitOfMeasure»),
  (Const.«MegaFn», Const.«UnitOfMeasure»),
  (Const.«GigaFn», Const.«UnitOfMeasure»),
  (Const.«TeraFn», Const.«UnitOfMeasure»),
  (Const.«MilliFn», Const.«UnitOfMeasure»),
  (Const.«MicroFn», Const.«UnitOfMeasure»),
  (Const.«NanoFn», Const.«UnitOfMeasure»),
  (Const.«PicoFn», Const.«UnitOfMeasure»),
  (Const.«UnitFn», Const.«UnitOfMeasure»),
  (Const.«PerFn», Const.«FunctionQuantity»),
  (Const.«DensityFn», Const.«FunctionQuantity»),
  (Const.«SpeedFn», Const.«FunctionQuantity»),
  (Const.«VelocityFn», Const.«FunctionQuantity»),
  (Const.«AmountsFn», Const.«List»),
  (Const.«CenterOfCircleFn», Const.«GeometricPoint»),
  (Const.«WealthFn», Const.«CurrencyMeasure»),
  (Const.«BeginFn», Const.«TimePoint»),
  (Const.«EndFn», Const.«TimePoint»),
  (Const.«TimeIntervalFn», Const.«TimeInterval»),
  (Const.«WhenFn», Const.«TimeInterval»),
  (Const.«PastFn», Const.«TimeInterval»),
  (Const.«ImmediatePastFn», Const.«TimeInterval»),
  (Const.«FutureFn», Const.«TimeInterval»),
  (Const.«ImmediateFutureFn», Const.«TimeInterval»),
  (Const.«MorningFn», Const.«Morning»),
  (Const.«AfternoonFn», Const.«Afternoon»),
  (Const.«EveningFn», Const.«Evening»),
  (Const.«MereologicalSumFn», Const.«Object»),
  (Const.«MereologicalProductFn», Const.«Object»),
  (Const.«MereologicalDifferenceFn», Const.«Object»),
  (Const.«HoleHostFn», Const.«Object»),
  (Const.«HoleSkinFn», Const.«Object»),
  (Const.«ImmediateFamilyFn», Const.«FamilyGroup»),
  (Const.«GovernmentFn», Const.«Government»),
  (Const.«PremisesFn», Const.«Formula»),
  (Const.«RelativeTimeFn», Const.«TimePosition»),
  (Const.«ImpairedBodyPartFn», Const.«DiseaseOrSyndrome»),
  (Const.«DeadOrMissingBodyPartFn», Const.«DiseaseOrSyndrome»)
 ]
def rangeSubclassDecls : List (Obj × Obj) :=
 [
  (Const.«PowerSetFn», Const.«SetOrClass»),
  (Const.«AttrFn», Const.«Object»),
  (Const.«GraphPathFn», Const.«GraphPath»),
  (Const.«CutSetFn», Const.«GraphPath»),
  (Const.«MinimalCutSetFn», Const.«GraphPath»),
  (Const.«IntervalFn», Const.«ConstantQuantity»),
  (Const.«RecurrentTimeIntervalFn», Const.«TimeInterval»),
  (Const.«YearFn», Const.«Year»),
  (Const.«MonthFn», Const.«Month»),
  (Const.«DayFn», Const.«Day»),
  (Const.«HourFn», Const.«Hour»),
  (Const.«MinuteFn», Const.«Minute»),
  (Const.«SecondFn», Const.«Second»),
  (Const.«WeekFn», Const.«Week»),
  (Const.«QuarterFn», Const.«QuarterYear»),
  (Const.«TemporalCompositionFn», Const.«TimeInterval»),
  (Const.«ImpairmentFn», Const.«BiologicalProcess»),
  (Const.«SenseImpairmentFn», Const.«PathologicProcess»),
  (Const.«SenseInabilityFn», Const.«PathologicProcess»),
  (Const.«FoodForFn», Const.«SelfConnectedObject»),
  (Const.«BodySideFn», Const.«BodyPart»),
  (Const.«EditionFn», Const.«ContentBearingObject»),
  (Const.«MakingFn», Const.«Object»),
  (Const.«DeadFn», Const.«OrganismRemains»)
 ]
end

noncomputable section

def axioms : List Obj :=

 [
ap (Const.«instance») ([Const.«instance», Const.«BinaryPredicate»]),
ap (Const.«subrelation») ([Const.«immediateInstance», Const.«instance»]),
ap (Const.«instance») ([Const.«immediateInstance», Const.«AsymmetricRelation»]),
ap (Const.«instance») ([Const.«immediateInstance», Const.«IntransitiveRelation»]),
mkForall (fun («?CLASS» : Obj) => mkForall (fun («?ENTITY» : Obj) => mkImp (ap (Const.«immediateInstance») ([«?ENTITY», «?CLASS»])) (mkNot (mkExists (fun («?SUBCLASS» : Obj) => mkAnd [ap (Const.«subclass») ([«?SUBCLASS», «?CLASS»]), mkNot (ap (Const.«equal») ([«?SUBCLASS», «?CLASS»])), ap (Const.«instance») ([«?ENTITY», «?SUBCLASS»])]))))),
ap (Const.«instance») ([Const.«inverse», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«inverse», Const.«IrreflexiveRelation»]),
ap (Const.«instance») ([Const.«inverse», Const.«IntransitiveRelation»]),
ap (Const.«instance») ([Const.«inverse», Const.«SymmetricRelation»]),
ap (Const.«instance») ([Const.«inverse», Const.«PartialValuedRelation»]),
ap (Const.«instance») ([Const.«subclass», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«subclass», Const.«PartialOrderingRelation»]),
mkForall (fun («?X» : Obj) => mkForall (fun («?Y» : Obj) => mkForall (fun («?Z» : Obj) => mkImp (mkAnd [ap (Const.«subclass») ([«?X», «?Y»]), ap (Const.«instance») ([«?Z», «?X»])]) (ap (Const.«instance») ([«?Z», «?Y»]))))),
ap (Const.«instance») ([Const.«immediateSubclass», Const.«AsymmetricRelation»]),
ap (Const.«instance») ([Const.«immediateSubclass», Const.«IntransitiveRelation»]),
ap (Const.«instance») ([Const.«immediateSubclass», Const.«BinaryPredicate»]),
mkForall (fun («?CLASS1» : Obj) => mkForall (fun («?CLASS2» : Obj) => mkImp (ap (Const.«immediateSubclass») ([«?CLASS1», «?CLASS2»])) (mkNot (mkExists (fun («?CLASS3» : Obj) => mkAnd [ap (Const.«subclass») ([«?CLASS3», «?CLASS2»]), ap (Const.«subclass») ([«?CLASS1», «?CLASS3»]), mkNot (ap (Const.«equal») ([«?CLASS2», «?CLASS3»])), mkNot (ap (Const.«equal») ([«?CLASS1», «?CLASS3»]))]))))),
ap (Const.«instance») ([Const.«subrelation», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«subrelation», Const.«PartialOrderingRelation»]),
mkForall (fun («?NUMBER» : Obj) => mkForall (fun («?PRED1» : Obj) => mkForall (fun («?PRED2» : Obj) => mkImp (mkAnd [ap (Const.«subrelation») ([«?PRED1», «?PRED2»]), ap (Const.«valence») ([«?PRED1», «?NUMBER»])]) (ap (Const.«valence») ([«?PRED2», «?NUMBER»]))))),
mkForall (fun («?CLASS1» : Obj) => mkForall (fun («?NUMBER» : Obj) => mkForall (fun («?PRED1» : Obj) => mkForall (fun («?PRED2» : Obj) => mkImp (mkAnd [ap (Const.«subrelation») ([«?PRED1», «?PRED2»]), ap (Const.«domain») ([«?PRED2», «?NUMBER», «?CLASS1»])]) (ap (Const.«domain») ([«?PRED1», «?NUMBER», «?CLASS1»])))))),
mkForallRow (fun («@ROW» : List Obj) => mkForall (fun («?REL1» : Obj) => mkForall (fun («?REL2» : Obj) => mkImp (mkAnd [ap (Const.«subrelation») ([«?REL1», «?REL2»]), ap (Const.«instance») ([«?REL1», Const.«Predicate»]), ap (Const.«instance») ([«?REL2», Const.«Predicate»]), ap («?REL1») («@ROW»)]) (ap («?REL2») («@ROW»))))),
mkForall (fun («?CLASS» : Obj) => mkForall (fun («?PRED1» : Obj) => mkForall (fun («?PRED2» : Obj) => mkImp (mkAnd [ap (Const.«subrelation») ([«?PRED1», «?PRED2»]), ap (Const.«instance») ([«?PRED2», «?CLASS»]), ap (Const.«subclass») ([«?CLASS», Const.«InheritableRelation»])]) (ap (Const.«instance») ([«?PRED1», «?CLASS»]))))),
ap (Const.«instance») ([Const.«domain», Const.«TernaryPredicate»]),
mkForall (fun («?CLASS1» : Obj) => mkForall (fun («?CLASS2» : Obj) => mkForall (fun («?NUMBER» : Obj) => mkForall (fun («?REL» : Obj) => mkImp (mkAnd [ap (Const.«domain») ([«?REL», «?NUMBER», «?CLASS1»]), ap (Const.«domain») ([«?REL», «?NUMBER», «?CLASS2»])]) (mkOr [ap (Const.«subclass») ([«?CLASS1», «?CLASS2»]), ap (Const.«subclass») ([«?CLASS2», «?CLASS1»])]))))),
ap (Const.«instance») ([Const.«domainSubclass», Const.«TernaryPredicate»]),
mkForall (fun («?CLASS1» : Obj) => mkForall (fun («?NUMBER» : Obj) => mkForall (fun («?REL1» : Obj) => mkForall (fun («?REL2» : Obj) => mkImp (mkAnd [ap (Const.«subrelation») ([«?REL1», «?REL2»]), ap (Const.«domainSubclass») ([«?REL2», «?NUMBER», «?CLASS1»])]) (ap (Const.«domainSubclass») ([«?REL1», «?NUMBER», «?CLASS1»])))))),
mkForall (fun («?CLASS1» : Obj) => mkForall (fun («?CLASS2» : Obj) => mkForall (fun («?NUMBER» : Obj) => mkForall (fun («?REL» : Obj) => mkImp (mkAnd [ap (Const.«domainSubclass») ([«?REL», «?NUMBER», «?CLASS1»]), ap (Const.«domainSubclass») ([«?REL», «?NUMBER», «?CLASS2»])]) (mkOr [ap (Const.«subclass») ([«?CLASS1», «?CLASS2»]), ap (Const.«subclass») ([«?CLASS2», «?CLASS1»])]))))),
mkForall (fun («?THING1» : Obj) => mkForall (fun («?THING2» : Obj) => mkImp (ap (Const.«equal») ([«?THING1», «?THING2»])) (mkForall (fun («?ATTR» : Obj) => mkIff (ap (Const.«property») ([«?THING1», «?ATTR»])) (ap (Const.«property») ([«?THING2», «?ATTR»])))))),
mkForall (fun («?ATTR1» : Obj) => mkForall (fun («?ATTR2» : Obj) => mkImp (ap (Const.«equal») ([«?ATTR1», «?ATTR2»])) (mkForall (fun («?THING» : Obj) => mkIff (ap (Const.«property») ([«?THING», «?ATTR1»])) (ap (Const.«property») ([«?THING», «?ATTR2»])))))),
mkForall (fun («?THING1» : Obj) => mkForall (fun («?THING2» : Obj) => mkImp (ap (Const.«equal») ([«?THING1», «?THING2»])) (mkForall (fun («?CLASS» : Obj) => mkIff (ap (Const.«instance») ([«?THING1», «?CLASS»])) (ap (Const.«instance») ([«?THING2», «?CLASS»])))))),
mkForall (fun («?CLASS1» : Obj) => mkForall (fun («?CLASS2» : Obj) => mkImp (ap (Const.«equal») ([«?CLASS1», «?CLASS2»])) (mkForall (fun («?THING» : Obj) => mkIff (ap (Const.«instance») ([«?THING», «?CLASS1»])) (ap (Const.«instance») ([«?THING», «?CLASS2»])))))),
mkForallRow (fun («@ROW1» : List Obj) => mkForallRow (fun («@ROW2» : List Obj) => mkForall (fun («?LIST1» : Obj) => mkForall (fun («?LIST2» : Obj) => mkForall (fun («?NUMBER» : Obj) => mkImp (mkAnd [ap (Const.«equal») ([«?LIST1», «?LIST2»]), ap (Const.«equal») ([«?LIST1», ap (Const.«ListFn») («@ROW1»)]), ap (Const.«equal») ([«?LIST2», ap (Const.«ListFn») («@ROW2»)])]) (ap (Const.«equal») ([ap (Const.«ListOrderFn») ([ap (Const.«ListFn») («@ROW1»), «?NUMBER»]), ap (Const.«ListOrderFn») ([ap (Const.«ListFn») («@ROW2»), «?NUMBER»])]))))))),
ap (Const.«instance») ([Const.«range», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«range», Const.«AsymmetricRelation»]),
mkForallRow (fun («@ROW» : List Obj) => mkForall (fun («?CLASS» : Obj) => mkForall (fun («?FUNCTION» : Obj) => mkForall (fun («?VALUE» : Obj) => mkImp (mkAnd [ap (Const.«range») ([«?FUNCTION», «?CLASS»]), ap (Const.«equal») ([ap (Const.«AssignmentFn») ([«?FUNCTION»] ++ «@ROW»), «?VALUE»])]) (ap (Const.«instance») ([«?VALUE», «?CLASS»])))))),
mkForall (fun («?CLASS1» : Obj) => mkForall (fun («?REL1» : Obj) => mkForall (fun («?REL2» : Obj) => mkImp (mkAnd [ap (Const.«subrelation») ([«?REL1», «?REL2»]), ap (Const.«range») ([«?REL2», «?CLASS1»])]) (ap (Const.«range») ([«?REL1», «?CLASS1»]))))),
mkForall (fun («?CLASS1» : Obj) => mkForall (fun («?CLASS2» : Obj) => mkForall (fun («?REL» : Obj) => mkImp (mkAnd [ap (Const.«range») ([«?REL», «?CLASS1»]), ap (Const.«range») ([«?REL», «?CLASS2»])]) (mkOr [ap (Const.«subclass») ([«?CLASS1», «?CLASS2»]), ap (Const.«subclass») ([«?CLASS2», «?CLASS1»])])))),
ap (Const.«instance») ([Const.«rangeSubclass», Const.«BinaryPredicate»]),
mkForallRow (fun («@ROW» : List Obj) => mkForall (fun («?CLASS» : Obj) => mkForall (fun («?FUNCTION» : Obj) => mkForall (fun («?VALUE» : Obj) => mkImp (mkAnd [ap (Const.«rangeSubclass») ([«?FUNCTION», «?CLASS»]), ap (Const.«equal») ([ap (Const.«AssignmentFn») ([«?FUNCTION»] ++ «@ROW»), «?VALUE»])]) (ap (Const.«subclass») ([«?VALUE», «?CLASS»])))))),
mkForall (fun («?CLASS1» : Obj) => mkForall (fun («?REL1» : Obj) => mkForall (fun («?REL2» : Obj) => mkImp (mkAnd [ap (Const.«subrelation») ([«?REL1», «?REL2»]), ap (Const.«rangeSubclass») ([«?REL2», «?CLASS1»])]) (ap (Const.«rangeSubclass») ([«?REL1», «?CLASS1»]))))),
mkForall (fun («?CLASS1» : Obj) => mkForall (fun («?CLASS2» : Obj) => mkForall (fun («?REL» : Obj) => mkImp (mkAnd [ap (Const.«rangeSubclass») ([«?REL», «?CLASS1»]), ap (Const.«rangeSubclass») ([«?REL», «?CLASS2»])]) (mkOr [ap (Const.«subclass») ([«?CLASS1», «?CLASS2»]), ap (Const.«subclass») ([«?CLASS2», «?CLASS1»])])))),
ap (Const.«instance») ([Const.«valence», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«valence», Const.«SingleValuedRelation»]),
ap (Const.«instance») ([Const.«documentation», Const.«TernaryPredicate»]),
ap (Const.«instance») ([Const.«format», Const.«TernaryPredicate»]),
ap (Const.«instance») ([Const.«termFormat», Const.«TernaryPredicate»]),
ap (Const.«instance») ([Const.«disjoint», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«disjoint», Const.«SymmetricRelation»]),
mkForall (fun («?CLASS1» : Obj) => mkForall (fun («?CLASS2» : Obj) => mkImp (ap (Const.«disjoint») ([«?CLASS1», «?CLASS2»])) (mkNot (mkExists (fun («?INST» : Obj) => mkAnd [ap (Const.«instance») ([«?INST», «?CLASS1»]), ap (Const.«instance») ([«?INST», «?CLASS2»])]))))),
ap (Const.«instance») ([Const.«disjointRelation», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«disjointRelation», Const.«IrreflexiveRelation»]),
ap (Const.«instance») ([Const.«disjointRelation», Const.«PartialValuedRelation»]),
ap (Const.«relatedInternalConcept») ([Const.«disjointRelation», Const.«disjoint»]),
mkForall (fun («?CLASS1» : Obj) => mkForall (fun («?CLASS2» : Obj) => mkForall (fun («?NUMBER» : Obj) => mkForall (fun («?REL1» : Obj) => mkForall (fun («?REL2» : Obj) => mkImp (mkAnd [ap (Const.«domain») ([«?REL1», «?NUMBER», «?CLASS1»]), ap (Const.«domain») ([«?REL2», «?NUMBER», «?CLASS2»]), ap (Const.«disjoint») ([«?CLASS1», «?CLASS2»])]) (ap (Const.«disjointRelation») ([«?REL1», «?REL2»]))))))),
mkForall (fun («?CLASS1» : Obj) => mkForall (fun («?CLASS2» : Obj) => mkForall (fun («?NUMBER» : Obj) => mkForall (fun («?REL1» : Obj) => mkForall (fun («?REL2» : Obj) => mkImp (mkAnd [ap (Const.«domainSubclass») ([«?REL1», «?NUMBER», «?CLASS1»]), ap (Const.«domainSubclass») ([«?REL2», «?NUMBER», «?CLASS2»]), ap (Const.«disjoint») ([«?CLASS1», «?CLASS2»])]) (ap (Const.«disjointRelation») ([«?REL1», «?REL2»]))))))),
mkForall (fun («?CLASS1» : Obj) => mkForall (fun («?CLASS2» : Obj) => mkForall (fun («?REL1» : Obj) => mkForall (fun («?REL2» : Obj) => mkImp (mkAnd [ap (Const.«range») ([«?REL1», «?CLASS1»]), ap (Const.«range») ([«?REL2», «?CLASS2»]), ap (Const.«disjoint») ([«?CLASS1», «?CLASS2»])]) (ap (Const.«disjointRelation») ([«?REL1», «?REL2»])))))),
mkForall (fun («?CLASS1» : Obj) => mkForall (fun («?CLASS2» : Obj) => mkForall (fun («?REL1» : Obj) => mkForall (fun («?REL2» : Obj) => mkImp (mkAnd [ap (Const.«rangeSubclass») ([«?REL1», «?CLASS1»]), ap (Const.«rangeSubclass») ([«?REL2», «?CLASS2»]), ap (Const.«disjoint») ([«?CLASS1», «?CLASS2»])]) (ap (Const.«disjointRelation») ([«?REL1», «?REL2»])))))),
mkForallRow (fun («@ROW2» : List Obj) => mkForall (fun («?REL1» : Obj) => mkForall (fun («?REL2» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?REL1», Const.«Predicate»]), ap (Const.«instance») ([«?REL2», Const.«Predicate»]), ap (Const.«disjointRelation») ([«?REL1», «?REL2»]), ap («?REL1») («@ROW2»)]) (mkNot (ap («?REL2») («@ROW2»)))))),
ap (Const.«instance») ([Const.«contraryAttribute», Const.«Predicate»]),
ap (Const.«instance») ([Const.«contraryAttribute», Const.«VariableArityRelation»]),
mkForallRow (fun («@ROW» : List Obj) => mkForall (fun («?ELEMENT» : Obj) => mkImp (ap (Const.«contraryAttribute») («@ROW»)) (mkImp (ap (Const.«inList») ([«?ELEMENT», ap (Const.«ListFn») («@ROW»)])) (ap (Const.«instance») ([«?ELEMENT», Const.«Attribute»]))))),
mkForallRow (fun («@ROW1» : List Obj) => mkForallRow (fun («@ROW2» : List Obj) => mkImp (mkAnd [ap (Const.«contraryAttribute») («@ROW1»), ap (Const.«identicalListItems») ([ap (Const.«ListFn») («@ROW1»), ap (Const.«ListFn») («@ROW2»)])]) (ap (Const.«contraryAttribute») («@ROW2»)))),
mkForallRow (fun («@ROW» : List Obj) => mkForall (fun («?ATTR1» : Obj) => mkForall (fun («?ATTR2» : Obj) => mkForall (fun («?NUMBER1» : Obj) => mkForall (fun («?NUMBER2» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (mkAnd [ap (Const.«contraryAttribute») («@ROW»), ap (Const.«equal») ([«?ATTR1», ap (Const.«ListOrderFn») ([ap (Const.«ListFn») («@ROW»), «?NUMBER1»])]), ap (Const.«equal») ([«?ATTR2», ap (Const.«ListOrderFn») ([ap (Const.«ListFn») («@ROW»), «?NUMBER2»])]), mkNot (ap (Const.«equal») ([«?NUMBER1», «?NUMBER2»])), ap (Const.«property») ([«?OBJ», «?ATTR1»])]) (mkNot (ap (Const.«property») ([«?OBJ», «?ATTR2»]))))))))),
ap (Const.«instance») ([Const.«exhaustiveAttribute», Const.«Predicate»]),
ap (Const.«instance») ([Const.«exhaustiveAttribute», Const.«VariableArityRelation»]),
mkForallRow (fun («@ROW» : List Obj) => mkForall (fun («?ATTR» : Obj) => mkForall (fun («?CLASS» : Obj) => mkImp (mkAnd [ap (Const.«exhaustiveAttribute») ([«?CLASS»] ++ «@ROW»), ap (Const.«inList») ([«?ATTR», ap (Const.«ListFn») («@ROW»)])]) (ap (Const.«instance») ([«?ATTR», Const.«Attribute»]))))),
mkForallRow (fun («@ROW» : List Obj) => mkForall (fun («?ATTR» : Obj) => mkForall (fun («?CLASS» : Obj) => mkImp (mkAnd [ap (Const.«exhaustiveAttribute») ([«?CLASS»] ++ «@ROW»), ap (Const.«inList») ([«?ATTR», ap (Const.«ListFn») («@ROW»)])]) (ap (Const.«instance») ([«?ATTR», «?CLASS»]))))),
mkForallRow (fun («@ROW» : List Obj) => mkForall (fun («?CLASS» : Obj) => mkImp (ap (Const.«exhaustiveAttribute») ([«?CLASS»] ++ «@ROW»)) (mkForall (fun («?ATTR1» : Obj) => mkImp (ap (Const.«instance») ([«?ATTR1», «?CLASS»])) (mkExists (fun («?ATTR2» : Obj) => mkAnd [ap (Const.«inList») ([«?ATTR2», ap (Const.«ListFn») («@ROW»)]), ap (Const.«equal») ([«?ATTR1», «?ATTR2»])])))))),
mkForallRow (fun («@ROW» : List Obj) => mkForall (fun («?ATTRCLASS» : Obj) => mkImp (ap (Const.«exhaustiveAttribute») ([«?ATTRCLASS»] ++ «@ROW»)) (mkNot (mkExists (fun («?EL» : Obj) => mkAnd [ap (Const.«instance») ([«?EL», «?ATTRCLASS»]), mkNot (mkExists (fun («?ATTR» : Obj) => mkExists (fun («?NUMBER» : Obj) => mkAnd [ap (Const.«equal») ([«?EL», «?ATTR»]), ap (Const.«equal») ([«?ATTR», ap (Const.«ListOrderFn») ([ap (Const.«ListFn») («@ROW»), «?NUMBER»])])])))]))))),
ap (Const.«instance») ([Const.«exhaustiveDecomposition», Const.«Predicate»]),
ap (Const.«instance») ([Const.«exhaustiveDecomposition», Const.«VariableArityRelation»]),
ap (Const.«relatedInternalConcept») ([Const.«exhaustiveDecomposition», Const.«partition»]),
mkForallRow (fun («@ROW» : List Obj) => mkForall (fun («?ELEMENT» : Obj) => mkImp (ap (Const.«exhaustiveDecomposition») («@ROW»)) (mkImp (ap (Const.«inList») ([«?ELEMENT», ap (Const.«ListFn») («@ROW»)])) (ap (Const.«instance») ([«?ELEMENT», Const.«Class»]))))),
ap (Const.«instance») ([Const.«disjointDecomposition», Const.«Predicate»]),
ap (Const.«instance») ([Const.«disjointDecomposition», Const.«VariableArityRelation»]),
ap (Const.«relatedInternalConcept») ([Const.«disjointDecomposition», Const.«exhaustiveDecomposition»]),
ap (Const.«relatedInternalConcept») ([Const.«disjointDecomposition», Const.«disjoint»]),
mkForallRow (fun («@ROW» : List Obj) => mkForall (fun («?ELEMENT» : Obj) => mkImp (ap (Const.«disjointDecomposition») («@ROW»)) (mkImp (ap (Const.«inList») ([«?ELEMENT», ap (Const.«ListFn») («@ROW»)])) (ap (Const.«instance») ([«?ELEMENT», Const.«Class»]))))),
ap (Const.«instance») ([Const.«partition», Const.«Predicate»]),
ap (Const.«instance») ([Const.«partition», Const.«VariableArityRelation»]),
mkForallRow (fun («@ROW» : List Obj) => mkImp (ap (Const.«partition») («@ROW»)) (mkAnd [ap (Const.«exhaustiveDecomposition») («@ROW»), ap (Const.«disjointDecomposition») («@ROW»)])),
mkForallRow (fun («@ROW» : List Obj) => mkImp (mkAnd [ap (Const.«exhaustiveDecomposition») («@ROW»), ap (Const.«disjointDecomposition») («@ROW»)]) (ap (Const.«partition») («@ROW»))),
mkForall (fun («?SUB1» : Obj) => mkForall (fun («?SUB2» : Obj) => mkForall (fun («?SUPER» : Obj) => mkImp (ap (Const.«partition») ([«?SUPER», «?SUB1», «?SUB2»])) (ap (Const.«partition») ([«?SUPER», «?SUB2», «?SUB1»]))))),
mkForall (fun («?INST» : Obj) => mkForall (fun («?SUB1» : Obj) => mkForall (fun («?SUB2» : Obj) => mkForall (fun («?SUPER» : Obj) => mkImp (mkAnd [ap (Const.«partition») ([«?SUPER», «?SUB1», «?SUB2»]), ap (Const.«instance») ([«?INST», «?SUPER»]), mkNot (ap (Const.«instance») ([«?INST», «?SUB1»]))]) (ap (Const.«instance») ([«?INST», «?SUB2»])))))),
ap (Const.«instance») ([Const.«relatedInternalConcept», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«relatedInternalConcept», Const.«EquivalenceRelation»]),
ap (Const.«instance») ([Const.«relatedExternalConcept», Const.«TernaryPredicate»]),
ap (Const.«relatedInternalConcept») ([Const.«relatedExternalConcept», Const.«relatedInternalConcept»]),
ap (Const.«subrelation») ([Const.«synonymousExternalConcept», Const.«relatedExternalConcept»]),
ap (Const.«instance») ([Const.«synonymousExternalConcept», Const.«TernaryPredicate»]),
ap (Const.«disjointRelation») ([Const.«synonymousExternalConcept», Const.«subsumedExternalConcept»]),
ap (Const.«disjointRelation») ([Const.«synonymousExternalConcept», Const.«subsumingExternalConcept»]),
ap (Const.«disjointRelation») ([Const.«subsumedExternalConcept», Const.«subsumingExternalConcept»]),
ap (Const.«subrelation») ([Const.«subsumingExternalConcept», Const.«relatedExternalConcept»]),
ap (Const.«instance») ([Const.«subsumingExternalConcept», Const.«TernaryPredicate»]),
ap (Const.«subrelation») ([Const.«subsumedExternalConcept», Const.«relatedExternalConcept»]),
ap (Const.«instance») ([Const.«subsumedExternalConcept», Const.«TernaryPredicate»]),
ap (Const.«instance») ([Const.«externalImage», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«subAttribute», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«subAttribute», Const.«PartialOrderingRelation»]),
ap (Const.«disjointRelation») ([Const.«subAttribute», Const.«successorAttribute»]),
mkForall (fun («?ATTR1» : Obj) => mkForall (fun («?ATTR2» : Obj) => mkImp (ap (Const.«subAttribute») ([«?ATTR1», «?ATTR2»])) (mkForall (fun («?OBJ» : Obj) => mkImp (ap (Const.«property») ([«?OBJ», «?ATTR1»])) (ap (Const.«property») ([«?OBJ», «?ATTR2»])))))),
mkForall (fun («?ATTR1» : Obj) => mkForall (fun («?ATTR2» : Obj) => mkForall (fun («?CLASS» : Obj) => mkImp (mkAnd [ap (Const.«subAttribute») ([«?ATTR1», «?ATTR2»]), ap (Const.«instance») ([«?ATTR2», «?CLASS»])]) (ap (Const.«instance») ([«?ATTR1», «?CLASS»]))))),
ap (Const.«instance») ([Const.«successorAttribute», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«successorAttribute», Const.«AsymmetricRelation»]),
ap (Const.«instance») ([Const.«successorAttributeClosure», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«successorAttributeClosure», Const.«TransitiveRelation»]),
ap (Const.«instance») ([Const.«successorAttributeClosure», Const.«IrreflexiveRelation»]),
ap (Const.«instance») ([Const.«successorAttributeClosure», Const.«PartialValuedRelation»]),
ap (Const.«relatedInternalConcept») ([Const.«successorAttributeClosure», Const.«successorAttribute»]),
mkForall (fun («?ATTR1» : Obj) => mkForall (fun («?ATTR2» : Obj) => mkImp (ap (Const.«successorAttribute») ([«?ATTR1», «?ATTR2»])) (ap (Const.«successorAttributeClosure») ([«?ATTR1», «?ATTR2»])))),
ap (Const.«instance») ([Const.«greaterThanByQuality», Const.«TernaryPredicate»]),
mkForall (fun («?ATT» : Obj) => mkForall (fun («?E1» : Obj) => mkForall (fun («?E2» : Obj) => mkForall (fun («?E3» : Obj) => mkImp (mkAnd [ap (Const.«greaterThanByQuality») ([«?E1», «?E2», «?ATT»]), ap (Const.«greaterThanByQuality») ([«?E2», «?E3», «?ATT»])]) (ap (Const.«greaterThanByQuality») ([«?E1», «?E3», «?ATT»])))))),
mkForall (fun («?ATT» : Obj) => mkForall (fun («?E1» : Obj) => mkForall (fun («?E2» : Obj) => mkImp (ap (Const.«greaterThanByQuality») ([«?E1», «?E2», «?ATT»])) (mkNot (ap (Const.«greaterThanByQuality») ([«?E2», «?E1», «?ATT»])))))),
mkForall (fun («?ATT» : Obj) => mkForall (fun («?E1» : Obj) => mkForall (fun («?E2» : Obj) => mkImp (ap (Const.«greaterThanByQuality») ([«?E1», «?E2», «?ATT»])) (mkNot (ap (Const.«equal») ([«?E2», «?E1»])))))),
ap (Const.«instance») ([Const.«entails», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«AssignmentFn», Const.«Function»]),
ap (Const.«instance») ([Const.«AssignmentFn», Const.«VariableArityRelation»]),
ap (Const.«instance») ([Const.«PowerSetFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«PowerSetFn», Const.«TotalValuedRelation»]),
ap (Const.«partition») ([Const.«Entity», Const.«Physical», Const.«Abstract»]),
mkExists (fun («?THING» : Obj) => ap (Const.«instance») ([«?THING», Const.«Entity»])),
mkForall (fun («?CLASS» : Obj) => mkImp (ap (Const.«instance») ([«?CLASS», Const.«Class»])) (ap (Const.«subclass») ([«?CLASS», Const.«Entity»]))),
ap (Const.«subclass») ([Const.«Physical», Const.«Entity»]),
ap (Const.«partition») ([Const.«Physical», Const.«Object», Const.«Process»]),
mkForall (fun («?PHYS» : Obj) => mkImp (ap (Const.«instance») ([«?PHYS», Const.«Physical»])) (mkExists (fun («?LOC» : Obj) => mkExists (fun («?TIME» : Obj) => mkAnd [ap (Const.«located») ([«?PHYS», «?LOC»]), ap (Const.«time») ([«?PHYS», «?TIME»])])))),
ap (Const.«subclass») ([Const.«Object», Const.«Physical»]),
mkForall (fun («?O» : Obj) => mkImp (ap (Const.«instance») ([«?O», Const.«Object»])) (ap (Const.«capability») ([Const.«Translocation», Const.«origin», «?O»]))),
mkForall (fun («?O» : Obj) => mkImp (ap (Const.«instance») ([«?O», Const.«Object»])) (ap (Const.«capability») ([Const.«Translocation», Const.«destination», «?O»]))),
ap (Const.«subclass») ([Const.«SelfConnectedObject», Const.«Object»]),
ap (Const.«subclass») ([Const.«OrganicThing», Const.«SelfConnectedObject»]),
ap (Const.«instance») ([Const.«FrontFn», Const.«SpatialRelation»]),
ap (Const.«instance») ([Const.«FrontFn», Const.«PartialValuedRelation»]),
ap (Const.«instance») ([Const.«FrontFn», Const.«UnaryFunction»]),
mkForall (fun («?OBJ» : Obj) => mkImp (ap (Const.«instance») ([«?OBJ», Const.«SelfConnectedObject»])) (ap (Const.«side») ([ap (Const.«FrontFn») ([«?OBJ»]), «?OBJ»]))),
ap (Const.«instance») ([Const.«BackFn», Const.«SpatialRelation»]),
ap (Const.«instance») ([Const.«BackFn», Const.«PartialValuedRelation»]),
ap (Const.«instance») ([Const.«BackFn», Const.«UnaryFunction»]),
ap (Const.«relatedInternalConcept») ([Const.«BackFn», Const.«FrontFn»]),
mkForall (fun («?OBJ» : Obj) => mkImp (ap (Const.«instance») ([«?OBJ», Const.«SelfConnectedObject»])) (ap (Const.«side») ([ap (Const.«BackFn») ([«?OBJ»]), «?OBJ»]))),
mkForall (fun («?F» : Obj) => mkForall (fun («?O» : Obj) => mkImp (ap (Const.«equal») ([«?F», ap (Const.«FrontFn») ([«?O»])])) (mkNot (ap (Const.«overlapsSpatially») ([«?F», ap (Const.«BackFn») ([«?O»])]))))),
mkForall (fun («?B» : Obj) => mkForall (fun («?O» : Obj) => mkImp (ap (Const.«equal») ([«?B», ap (Const.«BackFn») ([«?O»])])) (mkNot (ap (Const.«overlapsSpatially») ([«?B», ap (Const.«FrontFn») ([«?O»])]))))),
ap (Const.«instance») ([Const.«part», Const.«SpatialRelation»]),
ap (Const.«instance») ([Const.«part», Const.«PartialOrderingRelation»]),
ap (Const.«instance») ([Const.«part», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«properPart», Const.«AsymmetricRelation»]),
ap (Const.«instance») ([Const.«properPart», Const.«TransitiveRelation»]),
ap (Const.«subrelation») ([Const.«properPart», Const.«part»]),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkImp (ap (Const.«properPart») ([«?OBJ1», «?OBJ2»])) (mkAnd [ap (Const.«part») ([«?OBJ1», «?OBJ2»]), mkNot (ap (Const.«part») ([«?OBJ2», «?OBJ1»]))]))),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkImp (mkAnd [ap (Const.«part») ([«?OBJ1», «?OBJ2»]), mkNot (ap (Const.«part») ([«?OBJ2», «?OBJ1»]))]) (ap (Const.«properPart») ([«?OBJ1», «?OBJ2»])))),
ap (Const.«subrelation») ([Const.«piece», Const.«part»]),
ap (Const.«instance») ([Const.«piece», Const.«BinaryPredicate»]),
mkForall (fun («?SUBSTANCE1» : Obj) => mkForall (fun («?SUBSTANCE2» : Obj) => mkImp (ap (Const.«piece») ([«?SUBSTANCE1», «?SUBSTANCE2»])) (mkForall (fun («?CLASS» : Obj) => mkImp (ap (Const.«instance») ([«?SUBSTANCE1», «?CLASS»])) (ap (Const.«instance») ([«?SUBSTANCE2», «?CLASS»])))))),
ap (Const.«subrelation») ([Const.«component», Const.«part»]),
ap (Const.«instance») ([Const.«component», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«material», Const.«BinaryPredicate»]),
mkForall (fun («?BIG» : Obj) => mkForall (fun («?SMALL» : Obj) => mkImp (ap (Const.«contains») ([«?SMALL», «?BIG»])) (ap (Const.«partlyLocated») ([«?SMALL», «?BIG»])))),
ap (Const.«instance») ([Const.«hole», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«hole», Const.«SpatialRelation»]),
ap (Const.«instance») ([Const.«hole», Const.«AsymmetricRelation»]),
ap (Const.«instance») ([Const.«properlyFills», Const.«AsymmetricRelation»]),
ap (Const.«subrelation») ([Const.«properlyFills», Const.«partiallyFills»]),
ap (Const.«subclass») ([Const.«Crater», Const.«HoleRegion»]),
mkForall (fun («?C» : Obj) => mkForall (fun («?SURF» : Obj) => mkImp (ap (Const.«instance») ([«?C», Const.«Crater»])) (mkExists (fun («?HOST» : Obj) => mkExists (fun («?EVENT» : Obj) => mkExists (fun («?METEOR» : Obj) => mkExists (fun («?BOMB» : Obj) => mkAnd [ap (Const.«hole») ([«?C», «?HOST»]), ap (Const.«superficialPart») ([«?SURF», ap (Const.«HoleHostFn») ([«?C»])]), mkOr [mkAnd [ap (Const.«instance») ([«?EVENT», Const.«Impacting»]), ap (Const.«instrument») ([«?EVENT», «?METEOR»]), ap (Const.«instance») ([«?METEOR», Const.«Meteorite»])], mkAnd [ap (Const.«instance») ([«?EVENT», Const.«Explosion»]), ap (Const.«instrument») ([«?EVENT», «?BOMB»]), ap (Const.«instance») ([«?BOMB», Const.«Bomb»])], ap (Const.«instance») ([«?EVENT», Const.«VolcanicEruption»])], ap (Const.«result») ([«?EVENT», «?C»])]))))))),
ap (Const.«instance») ([Const.«contains», Const.«SpatialRelation»]),
ap (Const.«instance») ([Const.«contains», Const.«AsymmetricRelation»]),
ap (Const.«instance») ([Const.«contains», Const.«PartialValuedRelation»]),
ap (Const.«instance») ([Const.«contains», Const.«BinaryPredicate»]),
ap (Const.«disjointRelation») ([Const.«contains», Const.«part»]),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkImp (ap (Const.«contains») ([«?OBJ1», «?OBJ2»])) (mkExists (fun («?HOLE» : Obj) => mkAnd [ap (Const.«hole») ([«?HOLE», «?OBJ1»]), ap (Const.«properlyFills») ([«?OBJ2», «?HOLE»])])))),
mkForall (fun («?HOLE» : Obj) => mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkImp (mkAnd [ap (Const.«hole») ([«?HOLE», «?OBJ1»]), ap (Const.«properlyFills») ([«?OBJ2», «?HOLE»])]) (ap (Const.«contains») ([«?OBJ1», «?OBJ2»]))))),
ap (Const.«subclass») ([Const.«Substance», Const.«SelfConnectedObject»]),
ap (Const.«partition») ([Const.«Substance», Const.«PureSubstance», Const.«Mixture»]),
ap (Const.«partition») ([Const.«Substance», Const.«SyntheticSubstance», Const.«NaturalSubstance»]),
mkForall (fun («?OBJECT» : Obj) => mkForall (fun («?OBJECTTYPE» : Obj) => mkForall (fun («?PART» : Obj) => mkImp (mkAnd [ap (Const.«subclass») ([«?OBJECTTYPE», Const.«Substance»]), ap (Const.«instance») ([«?OBJECT», «?OBJECTTYPE»]), ap (Const.«piece») ([«?PART», «?OBJECT»])]) (ap (Const.«instance») ([«?PART», «?OBJECTTYPE»]))))),
mkForall (fun («?ATTR» : Obj) => mkForall (fun («?OBJ» : Obj) => mkForall (fun («?PART» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?OBJ», Const.«Substance»]), ap (Const.«attribute») ([«?OBJ», «?ATTR»]), ap (Const.«piece») ([«?PART», «?OBJ»])]) (ap (Const.«attribute») ([«?PART», «?ATTR»]))))),
ap (Const.«subclass») ([Const.«SyntheticSubstance», Const.«Substance»]),
mkForall (fun («?SUBSTANCE» : Obj) => mkImp (ap (Const.«instance») ([«?SUBSTANCE», Const.«SyntheticSubstance»])) (mkExists (fun («?PROCESS» : Obj) => mkAnd [ap (Const.«instance») ([«?PROCESS», Const.«IntentionalProcess»]), ap (Const.«result») ([«?PROCESS», «?SUBSTANCE»]), ap (Const.«instance») ([«?SUBSTANCE», Const.«Substance»])]))),
ap (Const.«subclass») ([Const.«NaturalSubstance», Const.«Substance»]),
ap (Const.«subclass») ([Const.«PureSubstance», Const.«Substance»]),
ap (Const.«partition») ([Const.«PureSubstance», Const.«CompoundSubstance», Const.«ElementalSubstance»]),
ap (Const.«subclass») ([Const.«ElementalSubstance», Const.«PureSubstance»]),
ap (Const.«subclass») ([Const.«Metal», Const.«ElementalSubstance»]),
ap (Const.«subclass») ([Const.«Atom», Const.«ElementalSubstance»]),
mkForall (fun («?ATOM» : Obj) => mkImp (ap (Const.«instance») ([«?ATOM», Const.«Atom»])) (mkExists (fun («?PROTON» : Obj) => mkExists (fun («?ELECTRON» : Obj) => mkAnd [ap (Const.«part») ([«?PROTON», «?ATOM»]), ap (Const.«part») ([«?ELECTRON», «?ATOM»]), ap (Const.«instance») ([«?PROTON», Const.«Proton»]), ap (Const.«instance») ([«?ELECTRON», Const.«Electron»])])))),
mkForall (fun («?ATOM» : Obj) => mkImp (ap (Const.«instance») ([«?ATOM», Const.«Atom»])) (mkForall (fun («?NUCLEUS1» : Obj) => mkForall (fun («?NUCLEUS2» : Obj) => mkImp (mkAnd [ap (Const.«part») ([«?NUCLEUS1», «?ATOM»]), ap (Const.«part») ([«?NUCLEUS2», «?ATOM»]), ap (Const.«instance») ([«?NUCLEUS1», Const.«AtomicNucleus»]), ap (Const.«instance») ([«?NUCLEUS2», Const.«AtomicNucleus»])]) (ap (Const.«equal») ([«?NUCLEUS1», «?NUCLEUS2»])))))),
ap (Const.«subclass») ([Const.«SubatomicParticle», Const.«ElementalSubstance»]),
mkForall (fun («?PARTICLE» : Obj) => mkImp (ap (Const.«instance») ([«?PARTICLE», Const.«SubatomicParticle»])) (mkExists (fun («?ATOM» : Obj) => mkAnd [ap (Const.«instance») ([«?ATOM», Const.«Atom»]), ap (Const.«component») ([«?PARTICLE», «?ATOM»])]))),
ap (Const.«subclass») ([Const.«AtomicNucleus», Const.«SubatomicParticle»]),
mkForall (fun («?NUCLEUS» : Obj) => mkImp (ap (Const.«instance») ([«?NUCLEUS», Const.«AtomicNucleus»])) (mkExists (fun («?NEUTRON» : Obj) => mkExists (fun («?PROTON» : Obj) => mkAnd [ap (Const.«component») ([«?NEUTRON», «?NUCLEUS»]), ap (Const.«component») ([«?PROTON», «?NUCLEUS»]), ap (Const.«instance») ([«?NEUTRON», Const.«Neutron»]), ap (Const.«instance») ([«?PROTON», Const.«Proton»])])))),
ap (Const.«subclass») ([Const.«Electron», Const.«SubatomicParticle»]),
ap (Const.«subclass») ([Const.«Proton», Const.«SubatomicParticle»]),
ap (Const.«subclass») ([Const.«Neutron», Const.«SubatomicParticle»]),
ap (Const.«subclass») ([Const.«CompoundSubstance», Const.«PureSubstance»]),
ap (Const.«subclass») ([Const.«Mixture», Const.«Substance»]),
mkForall (fun («?MIXTURE» : Obj) => mkImp (ap (Const.«instance») ([«?MIXTURE», Const.«Mixture»])) (mkExists (fun («?PURE1» : Obj) => mkExists (fun («?PURE2» : Obj) => mkAnd [ap (Const.«instance») ([«?PURE1», Const.«PureSubstance»]), ap (Const.«instance») ([«?PURE2», Const.«PureSubstance»]), mkNot (ap (Const.«equal») ([«?PURE1», «?PURE2»])), ap (Const.«piece») ([«?PURE1», «?MIXTURE»]), ap (Const.«piece») ([«?PURE2», «?MIXTURE»])])))),
mkForall (fun («?MIXTURE» : Obj) => mkForall (fun («?SUBSTANCE» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?MIXTURE», Const.«Mixture»]), ap (Const.«piece») ([«?SUBSTANCE», «?MIXTURE»]), mkNot (ap (Const.«instance») ([«?SUBSTANCE», Const.«Mixture»]))]) (ap (Const.«instance») ([«?SUBSTANCE», Const.«PureSubstance»])))),
ap (Const.«subrelation») ([Const.«ingredient», Const.«material»]),
ap (Const.«instance») ([Const.«ingredient», Const.«BinaryPredicate»]),
mkForall (fun («?ING» : Obj) => mkForall (fun («?S» : Obj) => mkImp (ap (Const.«ingredient») ([«?ING», «?S»])) (mkExists (fun («?PROC» : Obj) => mkExists (fun («?X» : Obj) => mkExists (fun («?Y» : Obj) => mkAnd [ap (Const.«instance») ([«?PROC», Const.«Process»]), ap (Const.«instance») ([«?X», «?ING»]), ap (Const.«patient») ([«?PROC», «?X»]), ap (Const.«instance») ([«?Y», «?S»]), ap (Const.«result») ([«?PROC», «?Y»])])))))),
ap (Const.«subclass») ([Const.«CorpuscularObject», Const.«SelfConnectedObject»]),
ap (Const.«disjoint») ([Const.«CorpuscularObject», Const.«Substance»]),
mkForall (fun («?OBJ» : Obj) => mkImp (ap (Const.«instance») ([«?OBJ», Const.«CorpuscularObject»])) (mkExists (fun («?SUBSTANCE1» : Obj) => mkExists (fun («?SUBSTANCE2» : Obj) => mkAnd [ap (Const.«subclass») ([«?SUBSTANCE1», Const.«Substance»]), ap (Const.«subclass») ([«?SUBSTANCE2», Const.«Substance»]), ap (Const.«material») ([«?SUBSTANCE1», «?OBJ»]), ap (Const.«material») ([«?SUBSTANCE2», «?OBJ»]), mkNot (ap (Const.«equal») ([«?SUBSTANCE1», «?SUBSTANCE2»]))])))),
ap (Const.«instance») ([Const.«substanceElement», Const.«BinaryPredicate»]),
ap (Const.«subclass») ([Const.«Region», Const.«Object»]),
ap (Const.«subclass») ([Const.«Collection», Const.«Physical»]),
ap (Const.«disjoint») ([Const.«Collection», Const.«SelfConnectedObject»]),
mkForall (fun («?COLL» : Obj) => mkImp (ap (Const.«instance») ([«?COLL», Const.«Collection»])) (mkExists (fun («?OBJ» : Obj) => ap (Const.«member») ([«?OBJ», «?COLL»])))),
ap (Const.«instance») ([Const.«member», Const.«AsymmetricRelation»]),
ap (Const.«instance») ([Const.«member», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«member», Const.«IntransitiveRelation»]),
ap (Const.«relatedInternalConcept») ([Const.«member», Const.«instance»]),
ap (Const.«relatedInternalConcept») ([Const.«member», Const.«element»]),
ap (Const.«instance») ([Const.«subCollection», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«subCollection», Const.«PartialOrderingRelation»]),
mkForall (fun («?COLL1» : Obj) => mkForall (fun («?COLL2» : Obj) => mkIff (ap (Const.«subCollection») ([«?COLL1», «?COLL2»])) (mkForall (fun («?MEMBER» : Obj) => mkImp (ap (Const.«member») ([«?MEMBER», «?COLL1»])) (ap (Const.«member») ([«?MEMBER», «?COLL2»])))))),
ap (Const.«subclass») ([Const.«ContentBearingPhysical», Const.«Physical»]),
mkForall (fun («?OBJ» : Obj) => mkImp (ap (Const.«instance») ([«?OBJ», Const.«ContentBearingPhysical»])) (mkExists (fun («?THING» : Obj) => ap (Const.«represents») ([«?OBJ», «?THING»])))),
ap (Const.«subclass») ([Const.«ContentBearingProcess», Const.«ContentBearingPhysical»]),
ap (Const.«subclass») ([Const.«ContentBearingProcess», Const.«Process»]),
ap (Const.«subclass») ([Const.«ContentBearingObject», Const.«CorpuscularObject»]),
ap (Const.«subclass») ([Const.«ContentBearingObject», Const.«ContentBearingPhysical»]),
ap (Const.«relatedInternalConcept») ([Const.«ContentBearingObject», Const.«containsInformation»]),
ap (Const.«subclass») ([Const.«SymbolicString», Const.«ContentBearingPhysical»]),
ap (Const.«subclass») ([Const.«Character», Const.«SymbolicString»]),
mkForall (fun («?STRING» : Obj) => mkImp (ap (Const.«instance») ([«?STRING», Const.«SymbolicString»])) (mkExists (fun («?PART» : Obj) => mkAnd [ap (Const.«part») ([«?PART», «?STRING»]), ap (Const.«instance») ([«?PART», Const.«Character»])]))),
ap (Const.«instance») ([Const.«containsInformation», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«containsInformation», Const.«AsymmetricRelation»]),
ap (Const.«subrelation») ([Const.«containsInformation», Const.«represents»]),
ap (Const.«instance») ([Const.«containsFormula», Const.«BinaryPredicate»]),
ap (Const.«relatedInternalConcept») ([Const.«containsInformation», Const.«containsFormula»]),
ap (Const.«subclass») ([Const.«Icon», Const.«ContentBearingPhysical»]),
ap (Const.«subclass») ([Const.«Recording», Const.«ContentBearingObject»]),
ap (Const.«subclass») ([Const.«MotionPicture», Const.«Recording»]),
ap (Const.«subclass») ([Const.«MotionPicture», Const.«Text»]),
ap (Const.«subclass») ([Const.«LinguisticExpression», Const.«ContentBearingPhysical»]),
ap (Const.«disjoint») ([Const.«LinguisticExpression», Const.«Icon»]),
ap (Const.«subclass») ([Const.«Language», Const.«LinguisticExpression»]),
ap (Const.«disjointDecomposition») ([Const.«Language», Const.«AnimalLanguage», Const.«HumanLanguage», Const.«ComputerLanguage»]),
ap (Const.«subclass») ([Const.«WrittenLanguage», Const.«Language»]),
ap (Const.«subclass») ([Const.«AnimalLanguage», Const.«Language»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?LANG» : Obj) => mkForall (fun («?PROC» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?LANG», Const.«AnimalLanguage»]), ap (Const.«agent») ([«?PROC», «?AGENT»]), ap (Const.«instrument») ([«?PROC», «?LANG»])]) (mkAnd [ap (Const.«instance») ([«?AGENT», Const.«Animal»]), mkNot (ap (Const.«instance») ([«?AGENT», Const.«Human»]))])))),
ap (Const.«subclass») ([Const.«ArtificialLanguage», Const.«Language»]),
ap (Const.«subclass») ([Const.«ComputerLanguage», Const.«ArtificialLanguage»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?LANG» : Obj) => mkForall (fun («?PROC» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?LANG», Const.«ComputerLanguage»]), ap (Const.«agent») ([«?PROC», «?AGENT»]), ap (Const.«instrument») ([«?PROC», «?LANG»])]) (ap (Const.«instance») ([«?AGENT», Const.«Machine»]))))),
ap (Const.«subclass») ([Const.«HumanLanguage», Const.«Language»]),
ap (Const.«partition») ([Const.«HumanLanguage», Const.«NaturalLanguage», Const.«ConstructedLanguage»]),
ap (Const.«partition») ([Const.«HumanLanguage», Const.«SpokenHumanLanguage», Const.«ManualHumanLanguage»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?LANG» : Obj) => mkForall (fun («?PROC» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?LANG», Const.«HumanLanguage»]), ap (Const.«agent») ([«?PROC», «?AGENT»]), ap (Const.«instrument») ([«?PROC», «?LANG»])]) (ap (Const.«instance») ([«?AGENT», Const.«Human»]))))),
ap (Const.«subclass») ([Const.«ConstructedLanguage», Const.«HumanLanguage»]),
ap (Const.«subclass») ([Const.«ConstructedLanguage», Const.«ArtificialLanguage»]),
mkForall (fun («?LANG» : Obj) => mkImp (ap (Const.«instance») ([«?LANG», Const.«ConstructedLanguage»])) (mkExists (fun («?PLAN» : Obj) => mkAnd [ap (Const.«instance») ([«?PLAN», Const.«Planning»]), ap (Const.«result») ([«?PLAN», «?LANG»])]))),
ap (Const.«subclass») ([Const.«NaturalLanguage», Const.«HumanLanguage»]),
ap (Const.«subclass») ([Const.«ManualHumanLanguage», Const.«HumanLanguage»]),
ap (Const.«subclass») ([Const.«SpokenHumanLanguage», Const.«HumanLanguage»]),
ap (Const.«instance») ([Const.«language», Const.«BinaryPredicate»]),
ap (Const.«subclass») ([Const.«WrittenHumanLanguage», Const.«HumanLanguage»]),
mkForall (fun («?W» : Obj) => mkImp (ap (Const.«instance») ([«?W», Const.«Writing»])) (mkExists (fun («?S» : Obj) => mkExists (fun («?L» : Obj) => mkAnd [ap (Const.«instance») ([«?S», Const.«Text»]), ap (Const.«instance») ([«?L», Const.«WrittenHumanLanguage»]), ap (Const.«language») ([«?S», «?L»])])))),
ap (Const.«instance») ([Const.«ChineseTraditionalLanguage», Const.«WrittenHumanLanguage»]),
ap (Const.«instance») ([Const.«ChineseSimplifiedWriting», Const.«WrittenHumanLanguage»]),
ap (Const.«instance») ([Const.«ChinesePinyinWriting», Const.«WrittenHumanLanguage»]),
ap (Const.«instance») ([Const.«EnglishLanguage», Const.«NaturalLanguage»]),
ap (Const.«instance») ([Const.«EnglishLanguage», Const.«SpokenHumanLanguage»]),
ap (Const.«subclass») ([Const.«Word», Const.«LinguisticExpression»]),
ap (Const.«subclass») ([Const.«Formula», Const.«Sentence»]),
ap (Const.«subclass») ([Const.«AutonomousAgent», Const.«Object»]),
mkForall (fun («?AGENT» : Obj) => mkImp (ap (Const.«instance») ([«?AGENT», Const.«AutonomousAgent»])) (mkExists (fun («?PROC» : Obj) => ap (Const.«capability») ([«?PROC», Const.«agent», «?AGENT»])))),
ap (Const.«subclass») ([Const.«SentientAgent», Const.«AutonomousAgent»]),
ap (Const.«subclass») ([Const.«CognitiveAgent», Const.«SentientAgent»]),
ap (Const.«subclass») ([Const.«LegalAgent», Const.«RelationalAttribute»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?TIME» : Obj) => mkIff (ap (Const.«holdsDuring») ([«?TIME», ap (Const.«attribute») ([«?AGENT», Const.«LegalAgent»])])) (ap (Const.«holdsDuring») ([«?TIME», mkOr [ap (Const.«capability») ([Const.«LegalAction», Const.«agent», «?AGENT»]), ap (Const.«capability») ([Const.«LegalAction», Const.«patient», «?AGENT»])]])))),
ap (Const.«instance») ([Const.«leader», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«leader», Const.«AsymmetricRelation»]),
ap (Const.«instance») ([Const.«leader», Const.«SingleValuedRelation»]),
mkForall (fun («?TIME» : Obj) => mkForall (fun («?X» : Obj) => mkForall (fun («?Y» : Obj) => mkImp (ap (Const.«holdsDuring») ([«?TIME», ap (Const.«leader») ([«?X», «?Y»])])) (ap (Const.«holdsDuring») ([«?TIME», ap (Const.«attribute») ([«?Y», Const.«Living»])]))))),
ap (Const.«subclass») ([Const.«Process», Const.«Physical»]),
ap (Const.«subclass») ([Const.«DualObjectProcess», Const.«Process»]),
mkForall (fun («?PROCESS» : Obj) => mkImp (ap (Const.«instance») ([«?PROCESS», Const.«DualObjectProcess»])) (mkExists (fun («?OBJ1» : Obj) => mkExists (fun («?OBJ2» : Obj) => mkAnd [ap (Const.«patient») ([«?PROCESS», «?OBJ1»]), ap (Const.«patient») ([«?PROCESS», «?OBJ2»]), mkNot (ap (Const.«equal») ([«?OBJ1», «?OBJ2»]))])))),
ap (Const.«subclass») ([Const.«SingleAgentProcess», Const.«Process»]),
mkForall (fun («?PROC» : Obj) => mkImp (ap (Const.«instance») ([«?PROC», Const.«SingleAgentProcess»])) (mkExists (fun («?AGENT» : Obj) => ap (Const.«agent») ([«?PROC», «?AGENT»])))),
mkForall (fun («?AGENT1» : Obj) => mkForall (fun («?AGENT2» : Obj) => mkForall (fun («?PROC» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?PROC», Const.«SingleAgentProcess»]), ap (Const.«agent») ([«?PROC», «?AGENT1»]), ap (Const.«agent») ([«?PROC», «?AGENT2»])]) (mkAnd [ap (Const.«equal») ([«?AGENT1», «?AGENT2»]), mkNot (mkExists (fun («?AGENT3» : Obj) => mkAnd [ap (Const.«agent») ([«?PROC», «?AGENT3»]), mkNot (ap (Const.«equal») ([«?AGENT3», «?AGENT1»]))]))])))),
ap (Const.«subclass») ([Const.«Abstract», Const.«Entity»]),
ap (Const.«disjointDecomposition») ([Const.«Abstract», Const.«Quantity», Const.«Attribute», Const.«Relation», Const.«Proposition», Const.«List»]),
ap (Const.«subclass») ([Const.«Quantity», Const.«Abstract»]),
ap (Const.«subclass») ([Const.«Attribute», Const.«Abstract»]),
ap (Const.«partition») ([Const.«Attribute», Const.«InternalAttribute», Const.«RelationalAttribute»]),
ap (Const.«instance») ([Const.«property», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«attribute», Const.«AsymmetricRelation»]),
ap (Const.«instance») ([Const.«attribute», Const.«IrreflexiveRelation»]),
ap (Const.«instance») ([Const.«attribute», Const.«TotalValuedRelation»]),
ap (Const.«instance») ([Const.«attribute», Const.«BinaryPredicate»]),
ap (Const.«subrelation») ([Const.«attribute», Const.«property»]),
ap (Const.«instance») ([Const.«manner», Const.«AsymmetricRelation»]),
ap (Const.«instance») ([Const.«manner», Const.«IrreflexiveRelation»]),
ap (Const.«instance») ([Const.«manner», Const.«TotalValuedRelation»]),
ap (Const.«instance») ([Const.«manner», Const.«BinaryPredicate»]),
ap (Const.«subrelation») ([Const.«manner», Const.«property»]),
ap (Const.«disjointRelation») ([Const.«manner», Const.«attribute»]),
ap (Const.«instance») ([Const.«ExtensionFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«ExtensionFn», Const.«PartialValuedRelation»]),
ap (Const.«instance») ([Const.«AttrFn», Const.«BinaryFunction»]),
ap (Const.«instance») ([Const.«AttrFn», Const.«PartialValuedRelation»]),
mkForall (fun («?ATTR» : Obj) => mkForall (fun («?CLASS» : Obj) => mkForall (fun («?I» : Obj) => mkForall (fun («?X» : Obj) => mkImp (mkAnd [ap (Const.«equal») ([«?X», ap (Const.«AttrFn») ([«?CLASS», «?ATTR»])]), ap (Const.«instance») ([«?I», «?X»])]) (mkAnd [ap (Const.«instance») ([«?I», «?CLASS»]), ap (Const.«subclass») ([«?X», «?CLASS»]), ap (Const.«attribute») ([«?I», «?ATTR»])]))))),
mkForall (fun («?ATTR» : Obj) => mkForall (fun («?CLASS» : Obj) => mkForall (fun («?X» : Obj) => mkImp (ap (Const.«instance») ([«?X», ap (Const.«AttrFn») ([«?CLASS», «?ATTR»])])) (mkAnd [ap (Const.«instance») ([«?X», «?CLASS»]), ap (Const.«attribute») ([«?X», «?ATTR»])])))),
mkForall (fun («?ATTR» : Obj) => mkForall (fun («?CLASS» : Obj) => mkForall (fun («?X» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?X», «?CLASS»]), ap (Const.«attribute») ([«?X», «?ATTR»])]) (ap (Const.«instance») ([«?X», ap (Const.«AttrFn») ([«?CLASS», «?ATTR»])]))))),
ap (Const.«subclass») ([Const.«InternalAttribute», Const.«Attribute»]),
ap (Const.«subclass») ([Const.«PhysicalAttribute», Const.«InternalAttribute»]),
ap (Const.«subclass») ([Const.«RelationalAttribute», Const.«Attribute»]),
ap (Const.«subclass») ([Const.«Number», Const.«Quantity»]),
ap (Const.«partition») ([Const.«Number», Const.«RealNumber», Const.«ImaginaryNumber», Const.«ComplexNumber»]),
ap (Const.«instance») ([Const.«lessThan», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«lessThan», Const.«TransitiveRelation»]),
ap (Const.«instance») ([Const.«lessThan», Const.«IrreflexiveRelation»]),
ap (Const.«instance») ([Const.«lessThan», Const.«RelationExtendedToQuantities»]),
ap (Const.«trichotomizingOn») ([Const.«lessThan», Const.«RealNumber»]),
ap (Const.«instance») ([Const.«greaterThan», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«greaterThan», Const.«TotalValuedRelation»]),
ap (Const.«instance») ([Const.«greaterThan», Const.«TransitiveRelation»]),
ap (Const.«instance») ([Const.«greaterThan», Const.«IrreflexiveRelation»]),
ap (Const.«instance») ([Const.«greaterThan», Const.«RelationExtendedToQuantities»]),
ap (Const.«trichotomizingOn») ([Const.«greaterThan», Const.«RealNumber»]),
ap (Const.«inverse») ([Const.«greaterThan», Const.«lessThan»]),
ap (Const.«instance») ([Const.«lessThanOrEqualTo», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«lessThanOrEqualTo», Const.«PartialOrderingRelation»]),
ap (Const.«instance») ([Const.«lessThanOrEqualTo», Const.«RelationExtendedToQuantities»]),
ap (Const.«trichotomizingOn») ([Const.«lessThanOrEqualTo», Const.«RealNumber»]),
mkForall (fun («?NUMBER1» : Obj) => mkForall (fun («?NUMBER2» : Obj) => mkIff (ap (Const.«lessThanOrEqualTo») ([«?NUMBER1», «?NUMBER2»])) (mkOr [ap (Const.«equal») ([«?NUMBER1», «?NUMBER2»]), ap (Const.«lessThan») ([«?NUMBER1», «?NUMBER2»])]))),
ap (Const.«instance») ([Const.«greaterThanOrEqualTo», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«greaterThanOrEqualTo», Const.«PartialOrderingRelation»]),
ap (Const.«instance») ([Const.«greaterThanOrEqualTo», Const.«RelationExtendedToQuantities»]),
ap (Const.«trichotomizingOn») ([Const.«greaterThanOrEqualTo», Const.«RealNumber»]),
ap (Const.«inverse») ([Const.«greaterThanOrEqualTo», Const.«lessThanOrEqualTo»]),
ap (Const.«subclass») ([Const.«RealNumber», Const.«Number»]),
ap (Const.«partition») ([Const.«RealNumber», Const.«NegativeRealNumber», Const.«NonnegativeRealNumber»]),
ap (Const.«partition») ([Const.«RealNumber», Const.«RationalNumber», Const.«IrrationalNumber»]),
ap (Const.«subclass») ([Const.«ImaginaryNumber», Const.«Number»]),
ap (Const.«subclass») ([Const.«RationalNumber», Const.«RealNumber»]),
ap (Const.«subclass») ([Const.«IrrationalNumber», Const.«RealNumber»]),
ap (Const.«subclass») ([Const.«NonnegativeRealNumber», Const.«RealNumber»]),
mkForall (fun («?NUMBER» : Obj) => mkIff (ap (Const.«instance») ([«?NUMBER», Const.«NonnegativeRealNumber»])) (mkAnd [ap (Const.«greaterThanOrEqualTo») ([«?NUMBER», numLit "0"]), ap (Const.«instance») ([«?NUMBER», Const.«RealNumber»])])),
ap (Const.«subclass») ([Const.«PositiveRealNumber», Const.«NonnegativeRealNumber»]),
mkForall (fun («?NUMBER» : Obj) => mkIff (ap (Const.«instance») ([«?NUMBER», Const.«PositiveRealNumber»])) (mkAnd [ap (Const.«greaterThan») ([«?NUMBER», numLit "0"]), ap (Const.«instance») ([«?NUMBER», Const.«RealNumber»])])),
ap (Const.«subclass») ([Const.«NegativeRealNumber», Const.«RealNumber»]),
mkForall (fun («?NUMBER» : Obj) => mkIff (ap (Const.«instance») ([«?NUMBER», Const.«NegativeRealNumber»])) (mkAnd [ap (Const.«lessThan») ([«?NUMBER», numLit "0"]), ap (Const.«instance») ([«?NUMBER», Const.«RealNumber»])])),
ap (Const.«subclass») ([Const.«Integer», Const.«RationalNumber»]),
ap (Const.«partition») ([Const.«Integer», Const.«OddInteger», Const.«EvenInteger»]),
ap (Const.«partition») ([Const.«Integer», Const.«NegativeInteger», Const.«NonnegativeInteger»]),
ap (Const.«subclass») ([Const.«EvenInteger», Const.«Integer»]),
ap (Const.«subclass») ([Const.«OddInteger», Const.«Integer»]),
ap (Const.«subclass») ([Const.«PrimeNumber», Const.«Integer»]),
ap (Const.«subclass») ([Const.«NonnegativeInteger», Const.«Integer»]),
ap (Const.«subclass») ([Const.«NonnegativeInteger», Const.«NonnegativeRealNumber»]),
mkForall (fun («?X» : Obj) => mkImp (ap (Const.«instance») ([«?X», Const.«NonnegativeInteger»])) (ap (Const.«greaterThan») ([«?X», numLit "-1"]))),
ap (Const.«subclass») ([Const.«NegativeInteger», Const.«Integer»]),
ap (Const.«subclass») ([Const.«NegativeInteger», Const.«NegativeRealNumber»]),
mkForall (fun («?X» : Obj) => mkImp (ap (Const.«instance») ([«?X», Const.«NegativeInteger»])) (ap (Const.«greaterThan») ([numLit "0", «?X»]))),
ap (Const.«subclass») ([Const.«PositiveInteger», Const.«NonnegativeInteger»]),
ap (Const.«subclass») ([Const.«PositiveInteger», Const.«PositiveRealNumber»]),
mkForall (fun («?X» : Obj) => mkImp (ap (Const.«instance») ([«?X», Const.«PositiveInteger»])) (ap (Const.«greaterThan») ([«?X», numLit "0"]))),
ap (Const.«subclass») ([Const.«BinaryNumber», Const.«RealNumber»]),
ap (Const.«subclass») ([Const.«ComplexNumber», Const.«Number»]),
ap (Const.«disjoint») ([Const.«ComplexNumber», Const.«RealNumber»]),
ap (Const.«subclass») ([Const.«PhysicalQuantity», Const.«Quantity»]),
ap (Const.«partition») ([Const.«PhysicalQuantity», Const.«ConstantQuantity», Const.«FunctionQuantity»]),
ap (Const.«subclass») ([Const.«ConstantQuantity», Const.«PhysicalQuantity»]),
ap (Const.«subclass») ([Const.«TimeMeasure», Const.«ConstantQuantity»]),
ap (Const.«subclass») ([Const.«TimeDuration», Const.«TimeMeasure»]),
ap (Const.«subclass») ([Const.«TimePosition», Const.«TimeMeasure»]),
ap (Const.«partition») ([Const.«TimePosition», Const.«TimeInterval», Const.«TimePoint»]),
ap (Const.«subclass») ([Const.«TimeInterval», Const.«TimePosition»]),
ap (Const.«subclass») ([Const.«TimePoint», Const.«TimePosition»]),
ap (Const.«subclass») ([Const.«FunctionQuantity», Const.«PhysicalQuantity»]),
ap (Const.«subclass») ([Const.«UnaryConstantFunctionQuantity», Const.«FunctionQuantity»]),
ap (Const.«subclass») ([Const.«TimeDependentQuantity», Const.«UnaryConstantFunctionQuantity»]),
ap (Const.«subclass») ([Const.«SetOrClass», Const.«Abstract»]),
ap (Const.«partition») ([Const.«SetOrClass», Const.«Set», Const.«Class»]),
ap (Const.«subclass») ([Const.«Class», Const.«SetOrClass»]),
ap (Const.«subclass») ([Const.«Set», Const.«SetOrClass»]),
ap (Const.«subclass») ([Const.«Relation», Const.«Abstract»]),
ap (Const.«disjointDecomposition») ([Const.«Relation», Const.«BinaryRelation», Const.«TernaryRelation», Const.«QuaternaryRelation», Const.«QuintaryRelation», Const.«VariableArityRelation»]),
ap (Const.«partition») ([Const.«Relation», Const.«Predicate», Const.«Function»]),
ap (Const.«partition») ([Const.«Relation», Const.«TotalValuedRelation», Const.«PartialValuedRelation»]),
ap (Const.«subclass») ([Const.«SingleValuedRelation», Const.«Relation»]),
ap (Const.«subclass») ([Const.«SingleValuedRelation», Const.«InheritableRelation»]),
ap (Const.«subclass») ([Const.«TotalValuedRelation», Const.«Relation»]),
ap (Const.«subclass») ([Const.«TotalValuedRelation», Const.«InheritableRelation»]),
ap (Const.«subclass») ([Const.«PartialValuedRelation», Const.«Relation»]),
ap (Const.«subclass») ([Const.«BinaryRelation», Const.«Relation»]),
ap (Const.«subclass») ([Const.«BinaryRelation», Const.«InheritableRelation»]),
ap (Const.«subclass») ([Const.«ReflexiveRelation», Const.«BinaryRelation»]),
ap (Const.«subclass») ([Const.«IrreflexiveRelation», Const.«BinaryRelation»]),
mkForall (fun («?REL» : Obj) => mkImp (ap (Const.«instance») ([«?REL», Const.«IrreflexiveRelation»])) (mkForall (fun («?INST» : Obj) => mkNot (ap («?REL») ([«?INST», «?INST»]))))),
ap (Const.«subclass») ([Const.«SymmetricRelation», Const.«BinaryRelation»]),
ap (Const.«disjoint») ([Const.«SymmetricRelation», Const.«AntisymmetricRelation»]),
mkForall (fun («?REL» : Obj) => mkImp (ap (Const.«instance») ([«?REL», Const.«SymmetricRelation»])) (mkForall (fun («?INST1» : Obj) => mkForall (fun («?INST2» : Obj) => mkImp (ap («?REL») ([«?INST1», «?INST2»])) (ap («?REL») ([«?INST2», «?INST1»])))))),
ap (Const.«subclass») ([Const.«AsymmetricRelation», Const.«IrreflexiveRelation»]),
ap (Const.«subclass») ([Const.«AsymmetricRelation», Const.«AntisymmetricRelation»]),
mkForall (fun («?REL» : Obj) => mkImp (ap (Const.«instance») ([«?REL», Const.«AsymmetricRelation»])) (mkAnd [ap (Const.«instance») ([«?REL», Const.«AntisymmetricRelation»]), ap (Const.«instance») ([«?REL», Const.«IrreflexiveRelation»])])),
mkForall (fun («?REL» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?REL», Const.«AntisymmetricRelation»]), ap (Const.«instance») ([«?REL», Const.«IrreflexiveRelation»])]) (ap (Const.«instance») ([«?REL», Const.«AsymmetricRelation»]))),
ap (Const.«subclass») ([Const.«AntisymmetricRelation», Const.«BinaryRelation»]),
mkForall (fun («?REL» : Obj) => mkImp (ap (Const.«instance») ([«?REL», Const.«AntisymmetricRelation»])) (mkForall (fun («?INST1» : Obj) => mkForall (fun («?INST2» : Obj) => mkImp (mkAnd [ap («?REL») ([«?INST1», «?INST2»]), ap («?REL») ([«?INST2», «?INST1»])]) (ap (Const.«equal») ([«?INST1», «?INST2»])))))),
ap (Const.«subclass») ([Const.«TrichotomizingRelation», Const.«BinaryRelation»]),
mkForall (fun («?REL» : Obj) => mkImp (ap (Const.«instance») ([«?REL», Const.«TrichotomizingRelation»])) (mkForall (fun («?INST1» : Obj) => mkForall (fun («?INST2» : Obj) => mkOr [mkAnd [ap («?REL») ([«?INST1», «?INST2»]), mkNot (ap (Const.«equal») ([«?INST1», «?INST2»])), mkNot (ap («?REL») ([«?INST2», «?INST1»]))], mkAnd [mkNot (ap («?REL») ([«?INST1», «?INST2»])), ap (Const.«equal») ([«?INST1», «?INST2»]), mkNot (ap («?REL») ([«?INST2», «?INST1»]))], mkAnd [mkNot (ap («?REL») ([«?INST1», «?INST2»])), mkNot (ap (Const.«equal») ([«?INST1», «?INST2»])), ap («?REL») ([«?INST2», «?INST1»])]])))),
ap (Const.«subclass») ([Const.«TransitiveRelation», Const.«BinaryRelation»]),
ap (Const.«disjoint») ([Const.«TransitiveRelation», Const.«IntransitiveRelation»]),
mkForall (fun («?REL» : Obj) => mkImp (ap (Const.«instance») ([«?REL», Const.«TransitiveRelation»])) (mkForall (fun («?INST1» : Obj) => mkForall (fun («?INST2» : Obj) => mkForall (fun («?INST3» : Obj) => mkImp (mkAnd [ap («?REL») ([«?INST1», «?INST2»]), ap («?REL») ([«?INST2», «?INST3»])]) (ap («?REL») ([«?INST1», «?INST3»]))))))),
ap (Const.«subclass») ([Const.«IntransitiveRelation», Const.«BinaryRelation»]),
mkForall (fun («?REL» : Obj) => mkImp (ap (Const.«instance») ([«?REL», Const.«IntransitiveRelation»])) (mkForall (fun («?INST1» : Obj) => mkForall (fun («?INST2» : Obj) => mkForall (fun («?INST3» : Obj) => mkImp (mkAnd [ap («?REL») ([«?INST1», «?INST2»]), ap («?REL») ([«?INST2», «?INST3»])]) (mkNot (ap («?REL») ([«?INST1», «?INST3»])))))))),
ap (Const.«subclass») ([Const.«PartialOrderingRelation», Const.«TransitiveRelation»]),
ap (Const.«subclass») ([Const.«PartialOrderingRelation», Const.«AntisymmetricRelation»]),
ap (Const.«subclass») ([Const.«PartialOrderingRelation», Const.«ReflexiveRelation»]),
ap (Const.«subclass») ([Const.«PartialOrderingRelation», Const.«TotalValuedRelation»]),
ap (Const.«subclass») ([Const.«TotalOrderingRelation», Const.«PartialOrderingRelation»]),
ap (Const.«subclass») ([Const.«TotalOrderingRelation», Const.«TrichotomizingRelation»]),
mkForall (fun («?REL» : Obj) => mkImp (ap (Const.«instance») ([«?REL», Const.«TotalOrderingRelation»])) (mkForall (fun («?INST1» : Obj) => mkForall (fun («?INST2» : Obj) => mkAnd [mkOr [ap («?REL») ([«?INST1», «?INST2»]), ap («?REL») ([«?INST2», «?INST1»])], mkOr [mkNot (ap («?REL») ([«?INST1», «?INST2»])), mkNot (ap («?REL») ([«?INST2», «?INST1»]))]])))),
ap (Const.«subclass») ([Const.«EquivalenceRelation», Const.«TransitiveRelation»]),
ap (Const.«subclass») ([Const.«EquivalenceRelation», Const.«SymmetricRelation»]),
ap (Const.«subclass») ([Const.«EquivalenceRelation», Const.«ReflexiveRelation»]),
ap (Const.«subclass») ([Const.«CaseRole», Const.«BinaryPredicate»]),
ap (Const.«subclass») ([Const.«CaseRole», Const.«InheritableRelation»]),
ap (Const.«subclass») ([Const.«CaseRole», Const.«AsymmetricRelation»]),
ap (Const.«instance») ([Const.«involvedInEvent», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«involvedInEvent», Const.«AsymmetricRelation»]),
mkForall (fun («?R» : Obj) => mkImp (ap (Const.«instance») ([«?R», Const.«CaseRole»])) (ap (Const.«subrelation») ([«?R», Const.«involvedInEvent»]))),
ap (Const.«instance») ([Const.«agent», Const.«CaseRole»]),
ap (Const.«instance») ([Const.«agent», Const.«PartialValuedRelation»]),
ap (Const.«subrelation») ([Const.«agent», Const.«involvedInEvent»]),
ap (Const.«instance») ([Const.«destination», Const.«CaseRole»]),
ap (Const.«instance») ([Const.«destination», Const.«PartialValuedRelation»]),
ap (Const.«subrelation») ([Const.«destination», Const.«involvedInEvent»]),
ap (Const.«instance») ([Const.«experiencer», Const.«CaseRole»]),
ap (Const.«instance») ([Const.«experiencer», Const.«PartialValuedRelation»]),
ap (Const.«subrelation») ([Const.«experiencer», Const.«involvedInEvent»]),
ap (Const.«subrelation») ([Const.«instrument», Const.«patient»]),
ap (Const.«instance») ([Const.«instrument», Const.«CaseRole»]),
ap (Const.«instance») ([Const.«instrument», Const.«PartialValuedRelation»]),
ap (Const.«instance») ([Const.«origin», Const.«CaseRole»]),
ap (Const.«instance») ([Const.«origin», Const.«PartialValuedRelation»]),
ap (Const.«subrelation») ([Const.«origin», Const.«involvedInEvent»]),
ap (Const.«instance») ([Const.«patient», Const.«CaseRole»]),
ap (Const.«instance») ([Const.«patient», Const.«PartialValuedRelation»]),
ap (Const.«subrelation») ([Const.«patient», Const.«involvedInEvent»]),
ap (Const.«subrelation») ([Const.«resource», Const.«patient»]),
ap (Const.«instance») ([Const.«resource», Const.«CaseRole»]),
ap (Const.«instance») ([Const.«resource», Const.«PartialValuedRelation»]),
ap (Const.«disjointRelation») ([Const.«resource», Const.«result»]),
ap (Const.«disjointRelation») ([Const.«resource», Const.«instrument»]),
ap (Const.«disjointRelation») ([Const.«result», Const.«instrument»]),
ap (Const.«instance») ([Const.«resourceExhausted», Const.«CaseRole»]),
ap (Const.«instance») ([Const.«resourceExhausted», Const.«AsymmetricRelation»]),
ap (Const.«instance») ([Const.«resourceExhausted», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«resourceExhausted», Const.«PartialValuedRelation»]),
mkForall (fun («?C» : Obj) => mkForall (fun («?P» : Obj) => mkForall (fun («?R» : Obj) => mkImp (mkAnd [ap (Const.«resourceExhausted») ([«?P», «?R»]), ap (Const.«instance») ([«?R», «?C»])]) (ap (Const.«holdsDuring») ([ap (Const.«ImmediateFutureFn») ([ap (Const.«WhenFn») ([«?P»])]), mkNot (mkExists (fun («?OBJ1» : Obj) => mkAnd [ap (Const.«part») ([«?OBJ1», «?R»]), ap (Const.«instance») ([«?OBJ1», «?C»])]))]))))),
ap (Const.«subrelation») ([Const.«result», Const.«patient»]),
ap (Const.«instance») ([Const.«result», Const.«CaseRole»]),
ap (Const.«instance») ([Const.«result», Const.«PartialValuedRelation»]),
ap (Const.«subclass») ([Const.«InheritableRelation», Const.«Relation»]),
ap (Const.«subclass») ([Const.«ProbabilityRelation», Const.«Relation»]),
ap (Const.«subclass») ([Const.«ProbabilityRelation», Const.«InheritableRelation»]),
ap (Const.«instance») ([Const.«ProbabilityFn», Const.«ProbabilityRelation»]),
ap (Const.«instance») ([Const.«ProbabilityFn», Const.«TotalValuedRelation»]),
ap (Const.«instance») ([Const.«ProbabilityFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«conditionalProbability», Const.«ProbabilityRelation»]),
ap (Const.«instance») ([Const.«conditionalProbability», Const.«TernaryPredicate»]),
ap (Const.«instance») ([Const.«increasesLikelihood», Const.«ProbabilityRelation»]),
ap (Const.«instance») ([Const.«increasesLikelihood», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«increasesLikelihood», Const.«IrreflexiveRelation»]),
ap (Const.«disjointRelation») ([Const.«increasesLikelihood», Const.«decreasesLikelihood»]),
ap (Const.«disjointRelation») ([Const.«increasesLikelihood», Const.«independentProbability»]),
ap (Const.«disjointRelation») ([Const.«decreasesLikelihood», Const.«independentProbability»]),
mkForall (fun («?FORMULA1» : Obj) => mkForall (fun («?FORMULA2» : Obj) => mkForall (fun («?NUMBER1» : Obj) => mkForall (fun («?NUMBER2» : Obj) => mkImp (mkAnd [ap (Const.«increasesLikelihood») ([«?FORMULA1», «?FORMULA2»]), ap (Const.«equal») ([ap (Const.«ProbabilityFn») ([«?FORMULA2»]), «?NUMBER1»]), ap (Const.«conditionalProbability») ([«?FORMULA1», «?FORMULA2», «?NUMBER2»])]) (ap (Const.«greaterThan») ([«?NUMBER2», «?NUMBER1»])))))),
ap (Const.«instance») ([Const.«decreasesLikelihood», Const.«ProbabilityRelation»]),
ap (Const.«instance») ([Const.«decreasesLikelihood», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«decreasesLikelihood», Const.«IrreflexiveRelation»]),
mkForall (fun («?FORMULA1» : Obj) => mkForall (fun («?FORMULA2» : Obj) => mkForall (fun («?NUMBER1» : Obj) => mkForall (fun («?NUMBER2» : Obj) => mkImp (mkAnd [ap (Const.«decreasesLikelihood») ([«?FORMULA1», «?FORMULA2»]), ap (Const.«equal») ([ap (Const.«ProbabilityFn») ([«?FORMULA2»]), «?NUMBER1»]), ap (Const.«conditionalProbability») ([«?FORMULA1», «?FORMULA2», «?NUMBER2»])]) (ap (Const.«lessThan») ([«?NUMBER2», «?NUMBER1»])))))),
ap (Const.«instance») ([Const.«independentProbability», Const.«ProbabilityRelation»]),
ap (Const.«instance») ([Const.«independentProbability», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«independentProbability», Const.«SymmetricRelation»]),
mkForall (fun («?FORMULA1» : Obj) => mkForall (fun («?FORMULA2» : Obj) => mkForall (fun («?NUMBER1» : Obj) => mkForall (fun («?NUMBER2» : Obj) => mkImp (mkAnd [ap (Const.«independentProbability») ([«?FORMULA1», «?FORMULA2»]), ap (Const.«equal») ([ap (Const.«ProbabilityFn») ([«?FORMULA2»]), «?NUMBER1»]), ap (Const.«conditionalProbability») ([«?FORMULA1», «?FORMULA2», «?NUMBER2»])]) (ap (Const.«equal») ([«?NUMBER2», «?NUMBER1»])))))),
mkForall (fun («?FORMULA1» : Obj) => mkForall (fun («?FORMULA2» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?FORMULA1», Const.«Formula»]), ap (Const.«instance») ([«?FORMULA2», Const.«Formula»])]) (mkOr [ap (Const.«increasesLikelihood») ([«?FORMULA1», «?FORMULA2»]), ap (Const.«decreasesLikelihood») ([«?FORMULA1», «?FORMULA2»]), ap (Const.«independentProbability») ([«?FORMULA1», «?FORMULA2»])]))),
ap (Const.«subclass») ([Const.«SpatialRelation», Const.«Relation»]),
ap (Const.«subclass») ([Const.«SpatialRelation», Const.«InheritableRelation»]),
ap (Const.«subclass») ([Const.«TemporalRelation», Const.«Relation»]),
ap (Const.«subclass») ([Const.«TemporalRelation», Const.«InheritableRelation»]),
ap (Const.«subclass») ([Const.«IntentionalRelation», Const.«InheritableRelation»]),
ap (Const.«subclass») ([Const.«IntentionalRelation», Const.«Relation»]),
mkForallRow (fun («@ROW» : List Obj) => mkForall (fun («?AGENT» : Obj) => mkForall (fun («?OBJ» : Obj) => mkForall (fun («?REL» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?REL», Const.«IntentionalRelation»]), ap («?REL») ([«?AGENT»] ++ «@ROW»), ap (Const.«inList») ([«?OBJ», ap (Const.«ListFn») («@ROW»)])]) (ap (Const.«inScopeOfInterest») ([«?AGENT», «?OBJ»])))))),
ap (Const.«instance») ([Const.«prefers», Const.«TernaryPredicate»]),
ap (Const.«instance») ([Const.«prefers», Const.«IntentionalRelation»]),
ap (Const.«subclass») ([Const.«PropositionalAttitude», Const.«IntentionalRelation»]),
ap (Const.«subclass») ([Const.«PropositionalAttitude», Const.«AsymmetricRelation»]),
ap (Const.«subclass») ([Const.«PropositionalAttitude», Const.«InheritableRelation»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?FORMULA» : Obj) => mkForall (fun («?REL» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?REL», Const.«PropositionalAttitude»]), ap («?REL») ([«?AGENT», «?FORMULA»])]) (ap (Const.«instance») ([«?FORMULA», Const.«Formula»]))))),
ap (Const.«subclass») ([Const.«ObjectAttitude», Const.«IntentionalRelation»]),
ap (Const.«subclass») ([Const.«ObjectAttitude», Const.«InheritableRelation»]),
ap (Const.«disjoint») ([Const.«ObjectAttitude», Const.«PropositionalAttitude»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?REL» : Obj) => mkForall (fun («?THING» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?REL», Const.«ObjectAttitude»]), ap («?REL») ([«?AGENT», «?THING»])]) (ap (Const.«instance») ([«?THING», Const.«Physical»]))))),
ap (Const.«instance») ([Const.«inScopeOfInterest», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«inScopeOfInterest», Const.«IntentionalRelation»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?OBJECT» : Obj) => mkForall (fun («?PROCESS» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?PROCESS», Const.«IntentionalProcess»]), ap (Const.«agent») ([«?PROCESS», «?AGENT»]), ap (Const.«instance») ([«?AGENT», Const.«CognitiveAgent»]), ap (Const.«patient») ([«?PROCESS», «?OBJECT»])]) (ap (Const.«inScopeOfInterest») ([«?AGENT», «?OBJECT»]))))),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?OBJECT» : Obj) => mkImp (ap (Const.«inScopeOfInterest») ([«?AGENT», «?OBJECT»])) (mkExists (fun («?PROCESS» : Obj) => mkAnd [ap (Const.«instance») ([«?PROCESS», Const.«IntentionalProcess»]), ap (Const.«agent») ([«?PROCESS», «?AGENT»]), ap (Const.«patient») ([«?PROCESS», «?OBJECT»])])))),
ap (Const.«instance») ([Const.«needs», Const.«ObjectAttitude»]),
ap (Const.«instance») ([Const.«needs», Const.«BinaryPredicate»]),
ap (Const.«subrelation») ([Const.«needs», Const.«inScopeOfInterest»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?OBJECT» : Obj) => mkImp (ap (Const.«needs») ([«?AGENT», «?OBJECT»])) (ap (Const.«wants») ([«?AGENT», «?OBJECT»])))),
ap (Const.«instance») ([Const.«wants», Const.«ObjectAttitude»]),
ap (Const.«instance») ([Const.«wants», Const.«BinaryPredicate»]),
ap (Const.«subrelation») ([Const.«wants», Const.«inScopeOfInterest»]),
ap (Const.«relatedInternalConcept») ([Const.«wants», Const.«desires»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (ap (Const.«wants») ([«?AGENT», «?OBJ»])) (mkExists (fun («?PURP» : Obj) => ap (Const.«hasPurposeForAgent») ([«?OBJ», «?PURP», «?AGENT»]))))),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (mkAnd [ap (Const.«wants») ([«?AGENT», «?OBJ»]), ap (Const.«instance») ([«?OBJ», Const.«Object»])]) (ap (Const.«desires») ([«?AGENT», ap (Const.«possesses») ([«?AGENT», «?OBJ»])])))),
ap (Const.«instance») ([Const.«desires», Const.«PropositionalAttitude»]),
ap (Const.«instance») ([Const.«desires», Const.«BinaryPredicate»]),
ap (Const.«subrelation») ([Const.«desires», Const.«inScopeOfInterest»]),
ap (Const.«relatedInternalConcept») ([Const.«desires», Const.«wants»]),
ap (Const.«instance») ([Const.«considers», Const.«PropositionalAttitude»]),
ap (Const.«instance») ([Const.«considers», Const.«BinaryPredicate»]),
ap (Const.«subrelation») ([Const.«considers», Const.«inScopeOfInterest»]),
ap (Const.«instance») ([Const.«believes», Const.«PropositionalAttitude»]),
ap (Const.«instance») ([Const.«believes», Const.«BinaryPredicate»]),
ap (Const.«subrelation») ([Const.«believes», Const.«inScopeOfInterest»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?FORMULA» : Obj) => mkImp (ap (Const.«believes») ([«?AGENT», «?FORMULA»])) (mkExists (fun («?TIME» : Obj) => ap (Const.«holdsDuring») ([«?TIME», ap (Const.«considers») ([«?AGENT», «?FORMULA»])]))))),
ap (Const.«instance») ([Const.«knows», Const.«PropositionalAttitude»]),
ap (Const.«instance») ([Const.«knows», Const.«BinaryPredicate»]),
ap (Const.«subrelation») ([Const.«knows», Const.«inScopeOfInterest»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?FORMULA» : Obj) => mkImp (ap (Const.«knows») ([«?AGENT», «?FORMULA»])) (ap (Const.«believes») ([«?AGENT», «?FORMULA»])))),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?FORMULA» : Obj) => mkImp (ap (Const.«knows») ([«?AGENT», «?FORMULA»])) (ap (Const.«truth») ([«?FORMULA», Const.«True»])))),
ap (Const.«instance») ([Const.«says», Const.«PropositionalAttitude»]),
ap (Const.«instance») ([Const.«says», Const.«BinaryPredicate»]),
ap (Const.«subrelation») ([Const.«says», Const.«inScopeOfInterest»]),
ap (Const.«subclass») ([Const.«TernaryRelation», Const.«Relation»]),
ap (Const.«subclass») ([Const.«TernaryRelation», Const.«InheritableRelation»]),
ap (Const.«subclass») ([Const.«QuaternaryRelation», Const.«Relation»]),
ap (Const.«subclass») ([Const.«QuaternaryRelation», Const.«InheritableRelation»]),
ap (Const.«subclass») ([Const.«QuintaryRelation», Const.«Relation»]),
ap (Const.«subclass») ([Const.«QuintaryRelation», Const.«InheritableRelation»]),
ap (Const.«subclass») ([Const.«List», Const.«Abstract»]),
ap (Const.«subclass») ([Const.«UniqueList», Const.«List»]),
mkForall (fun («?LIST» : Obj) => mkImp (ap (Const.«instance») ([«?LIST», Const.«UniqueList»])) (mkForall (fun («?NUMBER1» : Obj) => mkForall (fun («?NUMBER2» : Obj) => mkImp (ap (Const.«equal») ([ap (Const.«ListOrderFn») ([«?LIST», «?NUMBER1»]), ap (Const.«ListOrderFn») ([«?LIST», «?NUMBER2»])])) (ap (Const.«equal») ([«?NUMBER1», «?NUMBER2»])))))),
ap (Const.«instance») ([Const.«NullList», Const.«List»]),
ap (Const.«instance») ([Const.«ListFn», Const.«Function»]),
ap (Const.«instance») ([Const.«ListFn», Const.«VariableArityRelation»]),
mkForallRow (fun («@ROW» : List Obj) => mkForall (fun («?CLASS» : Obj) => mkImp (ap (Const.«exhaustiveDecomposition») ([«?CLASS»] ++ «@ROW»)) (mkForall (fun («?OBJ» : Obj) => mkImp (ap (Const.«instance») ([«?OBJ», «?CLASS»])) (mkExists (fun («?ITEM» : Obj) => mkAnd [ap (Const.«inList») ([«?ITEM», ap (Const.«ListFn») («@ROW»)]), ap (Const.«instance») ([«?OBJ», «?ITEM»])])))))),
mkForallRow (fun («@ROW» : List Obj) => mkForall (fun («?CLASS» : Obj) => mkImp (ap (Const.«disjointDecomposition») ([«?CLASS»] ++ «@ROW»)) (mkForall (fun («?ITEM» : Obj) => mkImp (ap (Const.«inList») ([«?ITEM», ap (Const.«ListFn») («@ROW»)])) (ap (Const.«subclass») ([«?ITEM», «?CLASS»])))))),
mkForallRow (fun («@ROW» : List Obj) => mkForall (fun («?CLASS» : Obj) => mkImp (ap (Const.«disjointDecomposition») ([«?CLASS»] ++ «@ROW»)) (mkForall (fun («?ITEM1» : Obj) => mkForall (fun («?ITEM2» : Obj) => mkImp (mkAnd [ap (Const.«inList») ([«?ITEM1», ap (Const.«ListFn») («@ROW»)]), ap (Const.«inList») ([«?ITEM2», ap (Const.«ListFn») («@ROW»)]), mkNot (ap (Const.«equal») ([«?ITEM1», «?ITEM2»]))]) (ap (Const.«disjoint») ([«?ITEM1», «?ITEM2»]))))))),
mkForall (fun («?CLASS» : Obj) => mkForall (fun («?ROW1» : Obj) => mkForall (fun («?ROW2» : Obj) => mkForall (fun («?ROW3» : Obj) => mkImp (ap (Const.«disjointDecomposition») ([«?CLASS», «?ROW1», «?ROW2», «?ROW3»])) (mkAnd [ap (Const.«disjoint») ([«?ROW1», «?ROW2»]), ap (Const.«disjoint») ([«?ROW2», «?ROW3»]), ap (Const.«disjoint») ([«?ROW3», «?ROW1»])]))))),
ap (Const.«instance») ([Const.«ListOrderFn», Const.«BinaryFunction»]),
ap (Const.«instance») ([Const.«ListOrderFn», Const.«PartialValuedRelation»]),
mkForallRow (fun («@ROW» : List Obj) => mkForall (fun («?CLASS» : Obj) => mkForall (fun («?NUMBER» : Obj) => mkForall (fun («?REL» : Obj) => mkImp (mkAnd [ap (Const.«domain») ([«?REL», «?NUMBER», «?CLASS»]), ap (Const.«instance») ([«?REL», Const.«Predicate»]), ap («?REL») («@ROW»)]) (ap (Const.«instance») ([ap (Const.«ListOrderFn») ([ap (Const.«ListFn») («@ROW»), «?NUMBER»]), «?CLASS»])))))),
mkForallRow (fun («@ROW» : List Obj) => mkForall (fun («?CLASS» : Obj) => mkForall (fun («?NUMBER» : Obj) => mkForall (fun («?REL» : Obj) => mkImp (mkAnd [ap (Const.«domainSubclass») ([«?REL», «?NUMBER», «?CLASS»]), ap (Const.«instance») ([«?REL», Const.«Predicate»]), ap («?REL») («@ROW»)]) (ap (Const.«subclass») ([ap (Const.«ListOrderFn») ([ap (Const.«ListFn») («@ROW»), «?NUMBER»]), «?CLASS»])))))),
ap (Const.«instance») ([Const.«ListLengthFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«ListLengthFn», Const.«TotalValuedRelation»]),
mkForallRow (fun («@ROW» : List Obj) => mkForall (fun («?ITEM» : Obj) => ap (Const.«equal») ([ap (Const.«ListLengthFn») ([ap (Const.«ListFn») («@ROW» ++ [«?ITEM»])]), ap (Const.«SuccessorFn») ([ap (Const.«ListLengthFn») ([ap (Const.«ListFn») («@ROW»)])])]))),
mkForallRow (fun («@ROW» : List Obj) => mkForall (fun («?ITEM» : Obj) => ap (Const.«equal») ([ap (Const.«ListOrderFn») ([ap (Const.«ListFn») («@ROW» ++ [«?ITEM»]), ap (Const.«ListLengthFn») ([ap (Const.«ListFn») («@ROW» ++ [«?ITEM»])])]), «?ITEM»]))),
mkForall (fun («?NUMBER» : Obj) => mkForall (fun («?REL» : Obj) => mkImp (mkAnd [ap (Const.«valence») ([«?REL», «?NUMBER»]), ap (Const.«instance») ([«?REL», Const.«Predicate»])]) (mkForallRow (fun («@ROW» : List Obj) => mkImp (ap («?REL») («@ROW»)) (ap (Const.«equal») ([ap (Const.«ListLengthFn») ([ap (Const.«ListFn») («@ROW»)]), «?NUMBER»])))))),
ap (Const.«instance») ([Const.«ListConcatenateFn», Const.«BinaryFunction»]),
ap (Const.«instance») ([Const.«ListConcatenateFn», Const.«TotalValuedRelation»]),
mkForall (fun («?LIST1» : Obj) => mkForall (fun («?LIST2» : Obj) => mkForall (fun («?LIST3» : Obj) => mkForall (fun («?NUMBER1» : Obj) => mkForall (fun («?NUMBER2» : Obj) => mkImp (mkAnd [ap (Const.«equal») ([«?LIST3», ap (Const.«ListConcatenateFn») ([«?LIST1», «?LIST2»])]), mkNot (ap (Const.«equal») ([«?LIST1», Const.«NullList»])), mkNot (ap (Const.«equal») ([«?LIST2», Const.«NullList»])), ap (Const.«lessThanOrEqualTo») ([«?NUMBER1», ap (Const.«ListLengthFn») ([«?LIST1»])]), ap (Const.«lessThanOrEqualTo») ([«?NUMBER2», ap (Const.«ListLengthFn») ([«?LIST2»])]), ap (Const.«instance») ([«?NUMBER1», Const.«PositiveInteger»]), ap (Const.«instance») ([«?NUMBER2», Const.«PositiveInteger»])]) (mkAnd [ap (Const.«equal») ([ap (Const.«ListOrderFn») ([«?LIST3», «?NUMBER1»]), ap (Const.«ListOrderFn») ([«?LIST1», «?NUMBER1»])]), ap (Const.«equal») ([ap (Const.«ListOrderFn») ([«?LIST3», ap (Const.«AdditionFn») ([ap (Const.«ListLengthFn») ([«?LIST1»]), «?NUMBER2»])]), ap (Const.«ListOrderFn») ([«?LIST2», «?NUMBER2»])])])))))),
ap (Const.«instance») ([Const.«inList», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«inList», Const.«PartialValuedRelation»]),
mkForall (fun («?ITEM» : Obj) => mkForall (fun («?LIST» : Obj) => mkImp (ap (Const.«inList») ([«?ITEM», «?LIST»])) (mkExists (fun («?NUMBER» : Obj) => ap (Const.«equal») ([ap (Const.«ListOrderFn») ([«?LIST», «?NUMBER»]), «?ITEM»]))))),
ap (Const.«instance») ([Const.«subList», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«subList», Const.«PartialOrderingRelation»]),
ap (Const.«instance») ([Const.«SubListFn», Const.«TernaryFunction»]),
mkForall (fun («?E» : Obj) => mkForall (fun («?L» : Obj) => mkForall (fun («?R» : Obj) => mkForall (fun («?S» : Obj) => mkImp (mkAnd [ap (Const.«equal») ([«?R», ap (Const.«SubListFn») ([«?S», «?E», «?L»])]), ap (Const.«equal») ([ap (Const.«SubtractionFn») ([«?E», «?S»]), numLit "0"])]) (ap (Const.«equal») ([«?R», Const.«NullList»])))))),
mkForall (fun («?E» : Obj) => mkForall (fun («?L» : Obj) => mkForall (fun («?R» : Obj) => mkForall (fun («?S» : Obj) => mkImp (mkAnd [ap (Const.«equal») ([«?R», ap (Const.«SubListFn») ([«?S», «?E», «?L»])]), ap (Const.«equal») ([ap (Const.«SubtractionFn») ([«?E», «?S»]), numLit "1"])]) (ap (Const.«equal») ([«?R», ap (Const.«ListFn») ([ap (Const.«ListOrderFn») ([«?L», «?S»])])])))))),
mkForall (fun («?E» : Obj) => mkForall (fun («?L» : Obj) => mkForall (fun («?R» : Obj) => mkForall (fun («?S» : Obj) => mkImp (mkAnd [ap (Const.«equal») ([«?R», ap (Const.«SubListFn») ([«?S», «?E», «?L»])]), ap (Const.«greaterThan») ([ap (Const.«SubtractionFn») ([«?E», «?S»]), numLit "1"])]) (ap (Const.«equal») ([«?R», ap (Const.«ListConcatenateFn») ([ap (Const.«ListFn») ([ap (Const.«ListOrderFn») ([«?L», «?S»])]), ap (Const.«SubListFn») ([ap (Const.«AdditionFn») ([numLit "1", «?S»]), «?E», «?L»])])])))))),
ap (Const.«instance») ([Const.«LastFn», Const.«UnaryFunction»]),
mkForall (fun («?ITEM» : Obj) => mkForall (fun («?LIST» : Obj) => mkImp (ap (Const.«equal») ([ap (Const.«LastFn») ([«?LIST»]), «?ITEM»])) (mkExists (fun («?NUMBER» : Obj) => mkAnd [ap (Const.«equal») ([ap (Const.«ListLengthFn») ([«?LIST»]), «?NUMBER»]), ap (Const.«equal») ([ap (Const.«ListOrderFn») ([«?LIST», «?NUMBER»]), «?ITEM»])])))),
mkForall (fun («?ITEM» : Obj) => mkForall (fun («?LIST» : Obj) => mkForall (fun («?NUMBER» : Obj) => mkImp (mkAnd [ap (Const.«equal») ([ap (Const.«ListLengthFn») ([«?LIST»]), «?NUMBER»]), ap (Const.«equal») ([ap (Const.«ListOrderFn») ([«?LIST», «?NUMBER»]), «?ITEM»])]) (ap (Const.«equal») ([ap (Const.«LastFn») ([«?LIST»]), «?ITEM»]))))),
ap (Const.«instance») ([Const.«FirstFn», Const.«UnaryFunction»]),
mkForall (fun («?LIST» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?LIST», Const.«List»]), mkNot (ap (Const.«equal») ([«?LIST», Const.«NullList»]))]) (ap (Const.«equal») ([ap (Const.«FirstFn») ([«?LIST»]), ap (Const.«ListOrderFn») ([«?LIST», numLit "1"])]))),
ap (Const.«instance») ([Const.«ListSumFn», Const.«UnaryFunction»]),
mkForall (fun («?A» : Obj) => mkForall (fun («?L» : Obj) => mkImp (mkAnd [ap (Const.«equal») ([«?A», ap (Const.«ListSumFn») ([«?L»])]), ap (Const.«equal») ([numLit "1", ap (Const.«ListLengthFn») ([«?L»])])]) (ap (Const.«equal») ([«?A», ap (Const.«ListOrderFn») ([«?L», numLit "1"])])))),
mkForall (fun («?A» : Obj) => mkForall (fun («?L» : Obj) => mkImp (mkAnd [ap (Const.«equal») ([«?A», ap (Const.«ListSumFn») ([«?L»])]), ap (Const.«greaterThan») ([ap (Const.«ListLengthFn») ([«?L»]), numLit "1"])]) (ap (Const.«equal») ([«?A», ap (Const.«AdditionFn») ([ap (Const.«FirstFn») ([«?L»]), ap (Const.«ListSumFn») ([ap (Const.«SubListFn») ([numLit "2", ap (Const.«ListLengthFn») ([«?L»]), «?L»])])])])))),
ap (Const.«instance») ([Const.«AverageFn», Const.«UnaryFunction»]),
mkForall (fun («?A» : Obj) => mkForall (fun («?L» : Obj) => mkImp (mkAnd [ap (Const.«equal») ([«?A», ap (Const.«AverageFn») ([«?L»])]), ap (Const.«greaterThan») ([ap (Const.«ListLengthFn») ([«?L»]), numLit "0"])]) (ap (Const.«equal») ([«?A», ap (Const.«DivisionFn») ([ap (Const.«ListSumFn») ([«?L»]), ap (Const.«ListLengthFn») ([«?L»])])])))),
mkForall (fun («?A» : Obj) => mkForall (fun («?L» : Obj) => mkForall (fun («?N» : Obj) => mkImp (mkAnd [ap (Const.«equal») ([«?A», ap (Const.«AverageFn») ([«?L»])]), ap (Const.«inList») ([«?N», «?L»])]) (ap (Const.«instance») ([«?N», Const.«Number»]))))),
ap (Const.«instance») ([Const.«initialList», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«initialList», Const.«PartialOrderingRelation»]),
ap (Const.«subrelation») ([Const.«initialList», Const.«subList»]),
mkForallRow (fun («@ROW» : List Obj) => mkForall (fun («?ITEM» : Obj) => ap (Const.«initialList») ([ap (Const.«ListFn») («@ROW»), ap (Const.«ListFn») («@ROW» ++ [«?ITEM»])]))),
ap (Const.«instance») ([Const.«identicalListItems», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«identicalListItems», Const.«EquivalenceRelation»]),
ap (Const.«subclass») ([Const.«Predicate», Const.«Relation»]),
ap (Const.«subclass») ([Const.«Predicate», Const.«InheritableRelation»]),
ap (Const.«subclass») ([Const.«Function», Const.«SingleValuedRelation»]),
ap (Const.«subclass») ([Const.«Function», Const.«InheritableRelation»]),
ap (Const.«subclass») ([Const.«UnaryFunction», Const.«Function»]),
ap (Const.«subclass») ([Const.«UnaryFunction», Const.«BinaryRelation»]),
ap (Const.«subclass») ([Const.«UnaryFunction», Const.«InheritableRelation»]),
mkForall (fun («?FUNCTION» : Obj) => mkImp (ap (Const.«instance») ([«?FUNCTION», Const.«UnaryFunction»])) (ap (Const.«valence») ([«?FUNCTION», numLit "1"]))),
ap (Const.«subclass») ([Const.«OneToOneFunction», Const.«UnaryFunction»]),
mkForall (fun («?FUN» : Obj) => mkImp (ap (Const.«instance») ([«?FUN», Const.«OneToOneFunction»])) (mkForall (fun («?ARG1» : Obj) => mkForall (fun («?ARG2» : Obj) => mkImp (mkExists (fun («?CLASS» : Obj) => mkAnd [ap (Const.«domain») ([«?FUN», numLit "1", «?CLASS»]), ap (Const.«instance») ([«?ARG1», «?CLASS»]), ap (Const.«instance») ([«?ARG2», «?CLASS»]), mkNot (ap (Const.«equal») ([«?ARG1», «?ARG2»]))])) (mkNot (ap (Const.«equal») ([ap (Const.«AssignmentFn») ([«?FUN», «?ARG1»]), ap (Const.«AssignmentFn») ([«?FUN», «?ARG2»])]))))))),
ap (Const.«subclass») ([Const.«SequenceFunction», Const.«OneToOneFunction»]),
mkForall (fun («?CLASS» : Obj) => mkForall (fun («?SEQ» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?SEQ», Const.«SequenceFunction»]), ap (Const.«range») ([«?SEQ», «?CLASS»])]) (ap (Const.«subclass») ([«?CLASS», Const.«Integer»])))),
ap (Const.«subclass») ([Const.«BinaryFunction», Const.«Function»]),
ap (Const.«subclass») ([Const.«BinaryFunction», Const.«TernaryRelation»]),
ap (Const.«subclass») ([Const.«BinaryFunction», Const.«InheritableRelation»]),
mkForall (fun («?FUNCTION» : Obj) => mkImp (ap (Const.«instance») ([«?FUNCTION», Const.«BinaryFunction»])) (ap (Const.«valence») ([«?FUNCTION», numLit "2"]))),
ap (Const.«subclass») ([Const.«AssociativeFunction», Const.«BinaryFunction»]),
mkForall (fun («?FUNCTION» : Obj) => mkImp (ap (Const.«instance») ([«?FUNCTION», Const.«AssociativeFunction»])) (mkForall (fun («?INST1» : Obj) => mkForall (fun («?INST2» : Obj) => mkForall (fun («?INST3» : Obj) => mkForall (fun («?CLASS» : Obj) => mkImp (mkAnd [ap (Const.«domain») ([«?FUNCTION», numLit "1", «?CLASS»]), ap (Const.«instance») ([«?INST1», «?CLASS»]), ap (Const.«instance») ([«?INST2», «?CLASS»]), ap (Const.«instance») ([«?INST3», «?CLASS»])]) (ap (Const.«equal») ([ap (Const.«AssignmentFn») ([«?FUNCTION», «?INST1», ap (Const.«AssignmentFn») ([«?FUNCTION», «?INST2», «?INST3»])]), ap (Const.«AssignmentFn») ([«?FUNCTION», ap (Const.«AssignmentFn») ([«?FUNCTION», «?INST1», «?INST2»]), «?INST3»])])))))))),
ap (Const.«subclass») ([Const.«CommutativeFunction», Const.«BinaryFunction»]),
mkForall (fun («?FUNCTION» : Obj) => mkImp (ap (Const.«instance») ([«?FUNCTION», Const.«CommutativeFunction»])) (mkForall (fun («?INST1» : Obj) => mkForall (fun («?INST2» : Obj) => mkForall (fun («?CLASS» : Obj) => mkImp (mkAnd [ap (Const.«domain») ([«?FUNCTION», numLit "1", «?CLASS»]), ap (Const.«instance») ([«?INST1», «?CLASS»]), ap (Const.«instance») ([«?INST2», «?CLASS»])]) (ap (Const.«equal») ([ap (Const.«AssignmentFn») ([«?FUNCTION», «?INST1», «?INST2»]), ap (Const.«AssignmentFn») ([«?FUNCTION», «?INST2», «?INST1»])]))))))),
ap (Const.«subclass») ([Const.«TernaryFunction», Const.«Function»]),
ap (Const.«subclass») ([Const.«TernaryFunction», Const.«QuaternaryRelation»]),
ap (Const.«subclass») ([Const.«TernaryFunction», Const.«InheritableRelation»]),
mkForall (fun («?FUNCTION» : Obj) => mkImp (ap (Const.«instance») ([«?FUNCTION», Const.«TernaryFunction»])) (ap (Const.«valence») ([«?FUNCTION», numLit "3"]))),
ap (Const.«subclass») ([Const.«QuaternaryFunction», Const.«Function»]),
ap (Const.«subclass») ([Const.«QuaternaryFunction», Const.«QuintaryRelation»]),
ap (Const.«subclass») ([Const.«QuaternaryFunction», Const.«InheritableRelation»]),
mkForall (fun («?FUNCTION» : Obj) => mkImp (ap (Const.«instance») ([«?FUNCTION», Const.«QuaternaryFunction»])) (ap (Const.«valence») ([«?FUNCTION», numLit "4"]))),
ap (Const.«subclass») ([Const.«ContinuousFunction», Const.«Function»]),
ap (Const.«subclass») ([Const.«BinaryPredicate», Const.«Predicate»]),
ap (Const.«subclass») ([Const.«BinaryPredicate», Const.«BinaryRelation»]),
ap (Const.«subclass») ([Const.«BinaryPredicate», Const.«InheritableRelation»]),
mkForall (fun («?REL» : Obj) => mkImp (ap (Const.«instance») ([«?REL», Const.«BinaryPredicate»])) (ap (Const.«valence») ([«?REL», numLit "2"]))),
ap (Const.«subclass») ([Const.«TernaryPredicate», Const.«Predicate»]),
ap (Const.«subclass») ([Const.«TernaryPredicate», Const.«TernaryRelation»]),
ap (Const.«subclass») ([Const.«TernaryPredicate», Const.«InheritableRelation»]),
mkForall (fun («?REL» : Obj) => mkImp (ap (Const.«instance») ([«?REL», Const.«TernaryPredicate»])) (ap (Const.«valence») ([«?REL», numLit "3"]))),
ap (Const.«subclass») ([Const.«QuaternaryPredicate», Const.«Predicate»]),
ap (Const.«subclass») ([Const.«QuaternaryPredicate», Const.«QuaternaryRelation»]),
ap (Const.«subclass») ([Const.«QuaternaryPredicate», Const.«InheritableRelation»]),
mkForall (fun («?REL» : Obj) => mkImp (ap (Const.«instance») ([«?REL», Const.«QuaternaryPredicate»])) (ap (Const.«valence») ([«?REL», numLit "4"]))),
ap (Const.«subclass») ([Const.«QuintaryPredicate», Const.«Predicate»]),
ap (Const.«subclass») ([Const.«QuintaryPredicate», Const.«QuintaryRelation»]),
ap (Const.«subclass») ([Const.«QuintaryPredicate», Const.«InheritableRelation»]),
mkForall (fun («?REL» : Obj) => mkImp (ap (Const.«instance») ([«?REL», Const.«QuintaryPredicate»])) (ap (Const.«valence») ([«?REL», numLit "5"]))),
ap (Const.«subclass») ([Const.«VariableArityRelation», Const.«Relation»]),
mkForall (fun («?REL» : Obj) => mkImp (ap (Const.«instance») ([«?REL», Const.«VariableArityRelation»])) (mkNot (mkExists (fun («?INT» : Obj) => ap (Const.«valence») ([«?REL», «?INT»]))))),
ap (Const.«subclass») ([Const.«RelationExtendedToQuantities», Const.«Relation»]),
ap (Const.«subclass») ([Const.«RelationExtendedToQuantities», Const.«InheritableRelation»]),
ap (Const.«subclass») ([Const.«LogicalOperator», Const.«Predicate»]),
ap (Const.«subclass») ([Const.«Proposition», Const.«Abstract»]),
ap (Const.«instance») ([Const.«closedOn», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«closedOn», Const.«AsymmetricRelation»]),
ap (Const.«instance») ([Const.«reflexiveOn», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«reflexiveOn», Const.«AsymmetricRelation»]),
mkForall (fun («?CLASS» : Obj) => mkForall (fun («?RELATION» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?RELATION», Const.«ReflexiveRelation»]), ap (Const.«reflexiveOn») ([«?RELATION», «?CLASS»]), ap (Const.«instance») ([«?RELATION», Const.«Predicate»])]) (mkForall (fun («?INST» : Obj) => mkImp (ap (Const.«instance») ([«?INST», «?CLASS»])) (ap («?RELATION») ([«?INST», «?INST»])))))),
ap (Const.«instance») ([Const.«partialOrderingOn», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«partialOrderingOn», Const.«AsymmetricRelation»]),
mkForall (fun («?CLASS» : Obj) => mkForall (fun («?RELATION» : Obj) => mkImp (ap (Const.«partialOrderingOn») ([«?RELATION», «?CLASS»])) (mkAnd [ap (Const.«reflexiveOn») ([«?RELATION», «?CLASS»]), ap (Const.«instance») ([«?RELATION», Const.«TransitiveRelation»]), ap (Const.«instance») ([«?RELATION», Const.«AntisymmetricRelation»])]))),
ap (Const.«instance») ([Const.«totalOrderingOn», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«totalOrderingOn», Const.«AsymmetricRelation»]),
mkForall (fun («?CLASS» : Obj) => mkForall (fun («?RELATION» : Obj) => mkImp (ap (Const.«totalOrderingOn») ([«?RELATION», «?CLASS»])) (mkAnd [ap (Const.«partialOrderingOn») ([«?RELATION», «?CLASS»]), ap (Const.«trichotomizingOn») ([«?RELATION», «?CLASS»])]))),
mkForall (fun («?CLASS» : Obj) => mkForall (fun («?RELATION» : Obj) => mkImp (mkAnd [ap (Const.«partialOrderingOn») ([«?RELATION», «?CLASS»]), ap (Const.«trichotomizingOn») ([«?RELATION», «?CLASS»])]) (ap (Const.«totalOrderingOn») ([«?RELATION», «?CLASS»])))),
ap (Const.«instance») ([Const.«trichotomizingOn», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«trichotomizingOn», Const.«AsymmetricRelation»]),
mkForall (fun («?CLASS» : Obj) => mkForall (fun («?RELATION» : Obj) => mkImp (mkAnd [ap (Const.«trichotomizingOn») ([«?RELATION», «?CLASS»]), ap (Const.«instance») ([«?RELATION», Const.«RelationExtendedToQuantities»])]) (mkForall (fun («?INST1» : Obj) => mkForall (fun («?INST2» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?INST1», «?CLASS»]), ap (Const.«instance») ([«?INST2», «?CLASS»])]) (mkOr [ap («?RELATION») ([«?INST1», «?INST2»]), ap («?RELATION») ([«?INST2», «?INST1»]), ap (Const.«equal») ([«?INST1», «?INST2»])])))))),
ap (Const.«instance») ([Const.«equivalenceRelationOn», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«equivalenceRelationOn», Const.«AsymmetricRelation»]),
mkForall (fun («?CLASS» : Obj) => mkForall (fun («?RELATION» : Obj) => mkImp (ap (Const.«equivalenceRelationOn») ([«?RELATION», «?CLASS»])) (mkAnd [ap (Const.«instance») ([«?RELATION», Const.«TransitiveRelation»]), ap (Const.«instance») ([«?RELATION», Const.«SymmetricRelation»]), ap (Const.«reflexiveOn») ([«?RELATION», «?CLASS»])]))),
ap (Const.«instance») ([Const.«distributes», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«subProcess», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«subProcess», Const.«PartialOrderingRelation»]),
ap (Const.«instance») ([Const.«relatedEvent», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«relatedEvent», Const.«SymmetricRelation»]),
mkForall (fun («?P» : Obj) => mkForall (fun («?S1» : Obj) => mkForall (fun («?S2» : Obj) => mkImp (mkAnd [ap (Const.«subProcess») ([«?S1», «?P»]), ap (Const.«subProcess») ([«?S2», «?P»])]) (ap (Const.«relatedEvent») ([«?S1», «?S2»]))))),
ap (Const.«instance») ([Const.«causes», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«causes», Const.«AsymmetricRelation»]),
ap (Const.«relatedInternalConcept») ([Const.«causes», Const.«causesSubclass»]),
mkForall (fun («?P1» : Obj) => mkForall (fun («?P2» : Obj) => mkImp (ap (Const.«causes») ([«?P1», «?P2»])) (ap (Const.«relatedEvent») ([«?P1», «?P2»])))),
mkForall (fun («?PROC1» : Obj) => mkImp (ap (Const.«instance») ([«?PROC1», Const.«Process»])) (mkExists (fun («?PROC2» : Obj) => ap (Const.«causes») ([«?PROC2», «?PROC1»])))),
mkForall (fun («?P1» : Obj) => mkForall (fun («?P2» : Obj) => mkImp (ap (Const.«causes») ([«?P1», «?P2»])) (ap (Const.«earlier») ([ap (Const.«WhenFn») ([«?P1»]), ap (Const.«WhenFn») ([«?P2»])])))),
ap (Const.«instance») ([Const.«causesSubclass», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«causesSubclass», Const.«AsymmetricRelation»]),
mkForall (fun («?PROC1» : Obj) => mkForall (fun («?PROC2» : Obj) => mkImp (ap (Const.«causesSubclass») ([«?PROC1», «?PROC2»])) (mkExists (fun («?INST1» : Obj) => mkExists (fun («?INST2» : Obj) => mkAnd [ap (Const.«instance») ([«?INST2», «?PROC2»]), ap (Const.«instance») ([«?INST1», «?PROC1»]), ap (Const.«causes») ([«?INST1», «?INST2»])]))))),
ap (Const.«instance») ([Const.«causesProposition», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«causesProposition», Const.«AsymmetricRelation»]),
mkForall (fun («?SIT1» : Obj) => mkForall (fun («?SIT2» : Obj) => mkForall (fun («?T1» : Obj) => mkForall (fun («?T2» : Obj) => mkImp (mkAnd [ap (Const.«holdsDuring») ([«?T2», «?SIT2»]), ap (Const.«holdsDuring») ([«?T1», «?SIT1»]), ap (Const.«instance») ([«?T1», Const.«TimeInterval»]), ap (Const.«instance») ([«?T2», Const.«TimeInterval»]), ap (Const.«causesProposition») ([«?SIT1», «?SIT2»])]) (ap (Const.«beforeOrEqual») ([ap (Const.«BeginFn») ([«?T1»]), ap (Const.«BeginFn») ([«?T2»])])))))),
ap (Const.«instance») ([Const.«copy», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«copy», Const.«EquivalenceRelation»]),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkImp (ap (Const.«copy») ([«?OBJ1», «?OBJ2»])) (mkForall (fun («?ATTR» : Obj) => mkImp (ap (Const.«attribute») ([«?OBJ1», «?ATTR»])) (ap (Const.«attribute») ([«?OBJ2», «?ATTR»])))))),
ap (Const.«instance») ([Const.«time», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«time», Const.«TemporalRelation»]),
ap (Const.«instance») ([Const.«time», Const.«AsymmetricRelation»]),
ap (Const.«instance») ([Const.«time», Const.«TotalValuedRelation»]),
ap (Const.«relatedInternalConcept») ([Const.«time», Const.«located»]),
ap (Const.«relatedInternalConcept») ([Const.«time», Const.«holdsDuring»]),
ap (Const.«instance») ([Const.«holdsDuring», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«holdsDuring», Const.«AsymmetricRelation»]),
mkForall (fun («?SITUATION1» : Obj) => mkForall (fun («?SITUATION2» : Obj) => mkForall (fun («?TIME» : Obj) => mkImp (mkAnd [ap (Const.«holdsDuring») ([«?TIME», «?SITUATION1»]), ap (Const.«entails») ([«?SITUATION1», «?SITUATION2»])]) (ap (Const.«holdsDuring») ([«?TIME», «?SITUATION2»]))))),
mkForall (fun («?SITUATION» : Obj) => mkForall (fun («?TIME» : Obj) => mkImp (ap (Const.«holdsDuring») ([«?TIME», mkNot («?SITUATION»)])) (mkNot (ap (Const.«holdsDuring») ([«?TIME», «?SITUATION»]))))),
ap (Const.«instance») ([Const.«capability», Const.«TernaryPredicate»]),
mkForall (fun («?ARG1» : Obj) => mkForall (fun («?ARG2» : Obj) => mkForall (fun («?PROC» : Obj) => mkForall (fun («?ROLE» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?ROLE», Const.«CaseRole»]), ap («?ROLE») ([«?ARG1», «?ARG2»]), ap (Const.«instance») ([«?ARG1», «?PROC»]), ap (Const.«subclass») ([«?PROC», Const.«Process»])]) (ap (Const.«capability») ([«?PROC», «?ROLE», «?ARG2»])))))),
mkForall (fun («?OBJ» : Obj) => mkForall (fun («?PROCESS» : Obj) => mkForall (fun («?ROLE» : Obj) => mkImp (mkAnd [ap (Const.«capability») ([«?PROCESS», «?ROLE», «?OBJ»]), ap (Const.«instance») ([«?OBJ», Const.«Device»]), mkNot (ap (Const.«attribute») ([«?OBJ», Const.«DeviceDamaged»]))]) (ap (Const.«modalAttribute») ([mkExists (fun («?P» : Obj) => mkAnd [ap (Const.«instance») ([«?P», «?PROCESS»]), ap («?ROLE») ([«?P», «?OBJ»])]), Const.«Possibility»]))))),
ap (Const.«instance») ([Const.«exploits», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«exploits», Const.«AsymmetricRelation»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (ap (Const.«exploits») ([«?OBJ», «?AGENT»])) (mkExists (fun («?PROCESS» : Obj) => mkAnd [ap (Const.«agent») ([«?PROCESS», «?AGENT»]), ap (Const.«resource») ([«?PROCESS», «?OBJ»])])))),
ap (Const.«instance») ([Const.«hasPurpose», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«hasPurpose», Const.«AsymmetricRelation»]),
ap (Const.«instance») ([Const.«hasPurposeForAgent», Const.«TernaryPredicate»]),
mkForall (fun («?PURPOSE» : Obj) => mkForall (fun («?THING» : Obj) => mkImp (ap (Const.«hasPurpose») ([«?THING», «?PURPOSE»])) (mkExists (fun («?AGENT» : Obj) => ap (Const.«hasPurposeForAgent») ([«?THING», «?PURPOSE», «?AGENT»]))))),
ap (Const.«instance») ([Const.«hasSkill», Const.«BinaryPredicate»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?PROC» : Obj) => mkImp (ap (Const.«hasSkill») ([«?PROC», «?AGENT»])) (ap (Const.«capability») ([«?PROC», Const.«agent», «?AGENT»])))),
ap (Const.«instance») ([Const.«confersNorm», Const.«TernaryPredicate»]),
mkForall (fun («?ENTITY» : Obj) => mkForall (fun («?FORMULA» : Obj) => mkForall (fun («?NORM» : Obj) => mkForall (fun («?TIME» : Obj) => mkImp (ap (Const.«holdsDuring») ([«?TIME», ap (Const.«confersNorm») ([«?ENTITY», «?FORMULA», «?NORM»])])) (mkAnd [ap (Const.«holdsDuring») ([ap (Const.«ImmediatePastFn») ([«?TIME»]), mkNot (ap (Const.«modalAttribute») ([«?FORMULA», «?NORM»]))]), ap (Const.«holdsDuring») ([ap (Const.«ImmediateFutureFn») ([«?TIME»]), ap (Const.«modalAttribute») ([«?FORMULA», «?NORM»])])]))))),
ap (Const.«instance») ([Const.«deprivesNorm», Const.«TernaryPredicate»]),
ap (Const.«disjointRelation») ([Const.«deprivesNorm», Const.«confersNorm»]),
mkForall (fun («?ENTITY» : Obj) => mkForall (fun («?FORMULA» : Obj) => mkForall (fun («?NORM» : Obj) => mkForall (fun («?TIME» : Obj) => mkImp (ap (Const.«holdsDuring») ([«?TIME», ap (Const.«deprivesNorm») ([«?ENTITY», «?FORMULA», «?NORM»])])) (mkAnd [ap (Const.«holdsDuring») ([ap (Const.«ImmediatePastFn») ([«?TIME»]), ap (Const.«modalAttribute») ([«?FORMULA», «?NORM»])]), ap (Const.«holdsDuring») ([ap (Const.«ImmediateFutureFn») ([«?TIME»]), mkNot (ap (Const.«modalAttribute») ([«?FORMULA», «?NORM»]))])]))))),
ap (Const.«subrelation») ([Const.«overlapsSpatially», Const.«connected»]),
ap (Const.«instance») ([Const.«overlapsSpatially», Const.«ReflexiveRelation»]),
ap (Const.«instance») ([Const.«overlapsSpatially», Const.«SymmetricRelation»]),
ap (Const.«instance») ([Const.«partlyLocated», Const.«SpatialRelation»]),
ap (Const.«instance») ([Const.«partlyLocated», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«partlyLocated», Const.«TotalValuedRelation»]),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?OBJ1», Const.«Object»]), ap (Const.«partlyLocated») ([«?OBJ1», «?OBJ2»])]) (ap (Const.«overlapsSpatially») ([«?OBJ1», «?OBJ2»])))),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?OBJ1», Const.«Object»]), ap (Const.«partlyLocated») ([«?OBJ1», «?OBJ2»])]) (mkExists (fun («?SUB» : Obj) => mkAnd [ap (Const.«part») ([«?SUB», «?OBJ1»]), ap (Const.«located») ([«?SUB», «?OBJ2»])])))),
ap (Const.«instance») ([Const.«located», Const.«AntisymmetricRelation»]),
ap (Const.«instance») ([Const.«located», Const.«TransitiveRelation»]),
ap (Const.«instance») ([Const.«located», Const.«TotalValuedRelation»]),
ap (Const.«subrelation») ([Const.«located», Const.«partlyLocated»]),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkImp (ap (Const.«located») ([«?OBJ1», «?OBJ2»])) (mkForall (fun («?SUB» : Obj) => mkImp (ap (Const.«part») ([«?SUB», «?OBJ1»])) (ap (Const.«located») ([«?SUB», «?OBJ2»])))))),
ap (Const.«instance») ([Const.«eventPartlyLocated», Const.«CaseRole»]),
ap (Const.«instance») ([Const.«eventPartlyLocated», Const.«PartialValuedRelation»]),
mkForall (fun («?OJB» : Obj) => mkForall (fun («?PROC» : Obj) => mkImp (ap (Const.«eventPartlyLocated») ([«?PROC», «?OJB»])) (ap (Const.«partlyLocated») ([«?PROC», «?OJB»])))),
mkForall (fun («?OBJ» : Obj) => mkForall (fun («?PROC» : Obj) => mkImp (ap (Const.«eventPartlyLocated») ([«?PROC», «?OBJ»])) (mkExists (fun («?SUB» : Obj) => mkAnd [ap (Const.«subProcess») ([«?SUB», «?PROC»]), ap (Const.«eventLocated») ([«?SUB», «?OBJ»])])))),
mkForall (fun («?LOC» : Obj) => mkForall (fun («?PROCESS» : Obj) => mkImp (ap (Const.«origin») ([«?PROCESS», «?LOC»])) (ap (Const.«eventPartlyLocated») ([«?PROCESS», «?LOC»])))),
mkForall (fun («?LOC» : Obj) => mkForall (fun («?PROCESS» : Obj) => mkImp (ap (Const.«destination») ([«?PROCESS», «?LOC»])) (ap (Const.«eventPartlyLocated») ([«?PROCESS», «?LOC»])))),
ap (Const.«subrelation») ([Const.«eventPartlyLocated», Const.«involvedInEvent»]),
ap (Const.«subrelation») ([Const.«eventLocated», Const.«eventPartlyLocated»]),
ap (Const.«instance») ([Const.«eventLocated», Const.«CaseRole»]),
ap (Const.«instance») ([Const.«eventLocated», Const.«TotalValuedRelation»]),
mkForall (fun («?OBJ» : Obj) => mkForall (fun («?PROCESS» : Obj) => mkImp (ap (Const.«eventLocated») ([«?PROCESS», «?OBJ»])) (mkForall (fun («?SUB» : Obj) => mkImp (ap (Const.«subProcess») ([«?SUB», «?PROCESS»])) (ap (Const.«eventLocated») ([«?SUB», «?OBJ»])))))),
ap (Const.«subrelation») ([Const.«exactlyLocated», Const.«located»]),
ap (Const.«instance») ([Const.«exactlyLocated», Const.«BinaryPredicate»]),
mkForall (fun («?OBJ» : Obj) => mkForall (fun («?REGION» : Obj) => mkImp (ap (Const.«exactlyLocated») ([«?OBJ», «?REGION»])) (mkNot (mkExists (fun («?OTHEROBJ» : Obj) => mkAnd [ap (Const.«exactlyLocated») ([«?OTHEROBJ», «?REGION»]), mkNot (ap (Const.«equal») ([«?OTHEROBJ», «?OBJ»]))]))))),
ap (Const.«instance») ([Const.«between», Const.«SpatialRelation»]),
ap (Const.«instance») ([Const.«between», Const.«TernaryPredicate»]),
mkForall (fun («?END1» : Obj) => mkForall (fun («?END2» : Obj) => mkForall (fun («?MID» : Obj) => mkImp (ap (Const.«between») ([«?END1», «?MID», «?END2»])) (ap (Const.«between») ([«?END2», «?MID», «?END1»]))))),
ap (Const.«instance») ([Const.«betweenOnPath», Const.«SpatialRelation»]),
ap (Const.«instance») ([Const.«betweenOnPath», Const.«QuaternaryPredicate»]),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkForall (fun («?OBJ3» : Obj) => mkForall (fun («?PATH» : Obj) => mkImp (ap (Const.«betweenOnPath») ([«?OBJ1», «?OBJ2», «?OBJ3», «?PATH»])) (ap (Const.«between») ([«?OBJ1», «?OBJ2», «?OBJ3»])))))),
ap (Const.«instance») ([Const.«traverses», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«traverses», Const.«SpatialRelation»]),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkImp (ap (Const.«traverses») ([«?OBJ1», «?OBJ2»])) (mkOr [ap (Const.«crosses») ([«?OBJ1», «?OBJ2»]), ap (Const.«penetrates») ([«?OBJ1», «?OBJ2»])]))),
ap (Const.«subrelation») ([Const.«crosses», Const.«traverses»]),
ap (Const.«instance») ([Const.«crosses», Const.«AsymmetricRelation»]),
ap (Const.«instance») ([Const.«crosses», Const.«TransitiveRelation»]),
ap (Const.«disjointRelation») ([Const.«crosses», Const.«connected»]),
ap (Const.«subrelation») ([Const.«penetrates», Const.«traverses»]),
ap (Const.«instance») ([Const.«penetrates», Const.«AsymmetricRelation»]),
ap (Const.«instance») ([Const.«penetrates», Const.«IntransitiveRelation»]),
ap (Const.«instance») ([Const.«penetrates», Const.«PartialValuedRelation»]),
mkForall (fun («?X» : Obj) => mkForall (fun («?Y» : Obj) => mkImp (ap (Const.«penetrates») ([«?X», «?Y»])) (ap (Const.«meetsSpatially») ([«?X», «?Y»])))),
ap (Const.«instance») ([Const.«WhereFn», Const.«BinaryFunction»]),
ap (Const.«instance») ([Const.«WhereFn», Const.«SpatialRelation»]),
ap (Const.«instance») ([Const.«WhereFn», Const.«TotalValuedRelation»]),
ap (Const.«relatedInternalConcept») ([Const.«WhereFn», Const.«WhenFn»]),
mkForall (fun («?REGION» : Obj) => mkForall (fun («?THING» : Obj) => mkForall (fun («?TIME» : Obj) => mkImp (ap (Const.«equal») ([ap (Const.«WhereFn») ([«?THING», «?TIME»]), «?REGION»])) (ap (Const.«holdsDuring») ([«?TIME», ap (Const.«exactlyLocated») ([«?THING», «?REGION»])]))))),
mkForall (fun («?REGION» : Obj) => mkForall (fun («?THING» : Obj) => mkForall (fun («?TIME» : Obj) => mkImp (ap (Const.«holdsDuring») ([«?TIME», ap (Const.«exactlyLocated») ([«?THING», «?REGION»])])) (ap (Const.«equal») ([ap (Const.«WhereFn») ([«?THING», «?TIME»]), «?REGION»]))))),
ap (Const.«instance») ([Const.«possesses», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«possesses», Const.«AsymmetricRelation»]),
mkForall (fun («?OBJ» : Obj) => mkForall (fun («?PERSON» : Obj) => mkImp (ap (Const.«possesses») ([«?PERSON», «?OBJ»])) (ap (Const.«modalAttribute») ([ap (Const.«uses») ([«?OBJ», «?PERSON»]), Const.«Permission»])))),
mkForall (fun («?OBJ» : Obj) => mkForall (fun («?P» : Obj) => mkForall (fun («?PERSON» : Obj) => mkForall (fun («?T» : Obj) => mkImp (mkAnd [ap (Const.«holdsDuring») ([«?T», ap (Const.«possesses») ([«?PERSON», «?OBJ»])]), ap (Const.«part») ([«?P», «?OBJ»])]) (ap (Const.«holdsDuring») ([«?T», ap (Const.«possesses») ([«?PERSON», «?P»])])))))),
mkForall (fun («?AGENT1» : Obj) => mkForall (fun («?AGENT2» : Obj) => mkForall (fun («?OBJ» : Obj) => mkForall (fun («?TIME» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?TIME», Const.«TimePosition»]), ap (Const.«holdsDuring») ([«?TIME», ap (Const.«possesses») ([«?AGENT1», «?OBJ»])]), ap (Const.«holdsDuring») ([«?TIME», ap (Const.«possesses») ([«?AGENT2», «?OBJ»])])]) (ap (Const.«equal») ([«?AGENT1», «?AGENT2»])))))),
ap (Const.«instance») ([Const.«PropertyFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«PropertyFn», Const.«TotalValuedRelation»]),
mkForall (fun («?OBJ» : Obj) => mkForall (fun («?PERSON» : Obj) => mkImp (ap (Const.«element») ([«?OBJ», ap (Const.«PropertyFn») ([«?PERSON»])])) (ap (Const.«possesses») ([«?PERSON», «?OBJ»])))),
mkForall (fun («?OBJ» : Obj) => mkForall (fun («?PERSON» : Obj) => mkImp (ap (Const.«possesses») ([«?PERSON», «?OBJ»])) (ap (Const.«element») ([«?OBJ», ap (Const.«PropertyFn») ([«?PERSON»])])))),
ap (Const.«instance») ([Const.«precondition», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«precondition», Const.«AsymmetricRelation»]),
ap (Const.«instance») ([Const.«precondition», Const.«TransitiveRelation»]),
mkForall (fun («?PROC1» : Obj) => mkForall (fun («?PROC2» : Obj) => mkImp (ap (Const.«precondition») ([«?PROC1», «?PROC2»])) (mkImp (mkExists (fun («?INST2» : Obj) => ap (Const.«instance») ([«?INST2», «?PROC2»]))) (mkExists (fun («?INST1» : Obj) => ap (Const.«instance») ([«?INST1», «?PROC1»])))))),
ap (Const.«instance») ([Const.«hindersSubclass», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«hindersSubclass», Const.«IrreflexiveRelation»]),
ap (Const.«instance») ([Const.«hindersSubclass», Const.«PartialValuedRelation»]),
mkForall (fun («?PROC1» : Obj) => mkForall (fun («?PROC2» : Obj) => mkImp (ap (Const.«hindersSubclass») ([«?PROC1», «?PROC2»])) (mkForall (fun («?TIME» : Obj) => mkForall (fun («?PLACE» : Obj) => ap (Const.«decreasesLikelihood») ([ap (Const.«holdsDuring») ([«?TIME», mkExists (fun («?INST1» : Obj) => mkAnd [ap (Const.«instance») ([«?INST1», «?PROC1»]), ap (Const.«eventLocated») ([«?INST1», «?PLACE»])])]), ap (Const.«holdsDuring») ([«?TIME», mkExists (fun («?INST2» : Obj) => mkAnd [ap (Const.«instance») ([«?INST2», «?PROC2»]), ap (Const.«eventLocated») ([«?INST2», «?PLACE»])])])])))))),
ap (Const.«instance») ([Const.«preventsSubclass», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«preventsSubclass», Const.«IrreflexiveRelation»]),
ap (Const.«instance») ([Const.«preventsSubclass», Const.«PartialValuedRelation»]),
ap (Const.«relatedInternalConcept») ([Const.«preventsSubclass», Const.«hindersSubclass»]),
mkForall (fun («?PROC1» : Obj) => mkForall (fun («?PROC2» : Obj) => mkImp (ap (Const.«preventsSubclass») ([«?PROC1», «?PROC2»])) (mkForall (fun («?TIME» : Obj) => mkForall (fun («?PLACE» : Obj) => mkImp (ap (Const.«holdsDuring») ([«?TIME», mkExists (fun («?INST1» : Obj) => mkAnd [ap (Const.«instance») ([«?INST1», «?PROC1»]), ap (Const.«eventLocated») ([«?INST1», «?PLACE»])])])) (mkNot (ap (Const.«holdsDuring») ([«?TIME», mkExists (fun («?INST2» : Obj) => mkAnd [ap (Const.«instance») ([«?INST2», «?PROC2»]), ap (Const.«eventLocated») ([«?INST2», «?PLACE»])])])))))))),
ap (Const.«instance») ([Const.«prevents», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«prevents», Const.«PartialValuedRelation»]),
ap (Const.«relatedInternalConcept») ([Const.«prevents», Const.«preventsSubclass»]),
ap (Const.«relatedInternalConcept») ([Const.«prevents», Const.«hinders»]),
mkForall (fun («?L» : Obj) => mkForall (fun («?P» : Obj) => mkForall (fun («?T» : Obj) => mkForall (fun («?X» : Obj) => mkImp (mkAnd [ap (Const.«prevents») ([«?X», «?P»]), ap (Const.«equal») ([ap (Const.«WhenFn») ([«?X»]), «?T»]), ap (Const.«eventLocated») ([«?X», «?L»])]) (mkNot (ap (Const.«holdsDuring») ([«?T», mkExists (fun («?Y» : Obj) => mkAnd [ap (Const.«instance») ([«?Y», «?P»]), ap (Const.«eventLocated») ([«?Y», «?L»])])]))))))),
ap (Const.«instance») ([Const.«hinders», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«hinders», Const.«PartialValuedRelation»]),
ap (Const.«relatedInternalConcept») ([Const.«hinders», Const.«hindersSubclass»]),
mkForall (fun («?PROC» : Obj) => mkForall (fun («?X» : Obj) => mkImp (ap (Const.«hinders») ([«?X», «?PROC»])) (mkExists (fun («?L» : Obj) => mkExists (fun («?T» : Obj) => ap (Const.«decreasesLikelihood») ([mkAnd [ap (Const.«equal») ([ap (Const.«WhenFn») ([«?X»]), «?T»]), ap (Const.«eventLocated») ([«?X», «?L»])], ap (Const.«holdsDuring») ([«?T», mkExists (fun («?Y» : Obj) => mkAnd [ap (Const.«instance») ([«?Y», «?PROC»]), ap (Const.«eventLocated») ([«?Y», «?L»])])])])))))),
ap (Const.«instance») ([Const.«refers», Const.«BinaryPredicate»]),
ap (Const.«subrelation») ([Const.«names», Const.«refers»]),
ap (Const.«instance») ([Const.«names», Const.«BinaryPredicate»]),
ap (Const.«subrelation») ([Const.«uniqueIdentifier», Const.«names»]),
ap (Const.«instance») ([Const.«uniqueIdentifier», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«uniqueIdentifier», Const.«SingleValuedRelation»]),
ap (Const.«instance») ([Const.«uniqueIdentifier», Const.«PartialValuedRelation»]),
ap (Const.«subrelation») ([Const.«represents», Const.«refers»]),
ap (Const.«instance») ([Const.«represents», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«representsForAgent», Const.«TernaryPredicate»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?ENTITY» : Obj) => mkForall (fun («?REP» : Obj) => mkImp (ap (Const.«representsForAgent») ([«?REP», «?ENTITY», «?AGENT»])) (ap (Const.«represents») ([«?REP», «?ENTITY»]))))),
ap (Const.«instance») ([Const.«representsInLanguage», Const.«TernaryPredicate»]),
mkForall (fun («?ENTITY» : Obj) => mkForall (fun («?LANGUAGE» : Obj) => mkForall (fun («?REP» : Obj) => mkImp (ap (Const.«representsInLanguage») ([«?REP», «?ENTITY», «?LANGUAGE»])) (mkExists (fun («?AGENT» : Obj) => ap (Const.«representsForAgent») ([«?REP», «?ENTITY», «?AGENT»])))))),
ap (Const.«instance») ([Const.«equivalentContentClass», Const.«EquivalenceRelation»]),
ap (Const.«instance») ([Const.«equivalentContentClass», Const.«BinaryPredicate»]),
mkForall (fun («?CLASS1» : Obj) => mkForall (fun («?CLASS2» : Obj) => mkImp (mkAnd [ap (Const.«subsumesContentClass») ([«?CLASS1», «?CLASS2»]), ap (Const.«subsumesContentClass») ([«?CLASS2», «?CLASS1»])]) (ap (Const.«equivalentContentClass») ([«?CLASS1», «?CLASS2»])))),
mkForall (fun («?CLASS1» : Obj) => mkForall (fun («?CLASS2» : Obj) => mkImp (ap (Const.«equivalentContentClass») ([«?CLASS1», «?CLASS2»])) (mkAnd [ap (Const.«subsumesContentClass») ([«?CLASS1», «?CLASS2»]), ap (Const.«subsumesContentClass») ([«?CLASS2», «?CLASS1»])]))),
ap (Const.«instance») ([Const.«subsumesContentClass», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«subsumesContentClass», Const.«PartialOrderingRelation»]),
mkForall (fun («?CLASS1» : Obj) => mkForall (fun («?CLASS2» : Obj) => mkImp (ap (Const.«subsumesContentClass») ([«?CLASS1», «?CLASS2»])) (mkForall (fun («?OBJ2» : Obj) => mkForall (fun («?INFO» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?OBJ2», «?CLASS2»]), ap (Const.«containsInformation») ([«?OBJ2», «?INFO»])]) (mkExists (fun («?OBJ1» : Obj) => mkAnd [ap (Const.«instance») ([«?OBJ1», «?CLASS1»]), ap (Const.«containsInformation») ([«?OBJ1», «?INFO»])]))))))),
ap (Const.«instance») ([Const.«equivalentContentInstance», Const.«EquivalenceRelation»]),
ap (Const.«instance») ([Const.«equivalentContentInstance», Const.«BinaryPredicate»]),
ap (Const.«relatedInternalConcept») ([Const.«equivalentContentInstance», Const.«equivalentContentClass»]),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkImp (mkAnd [ap (Const.«subsumesContentInstance») ([«?OBJ1», «?OBJ2»]), ap (Const.«subsumesContentInstance») ([«?OBJ2», «?OBJ1»])]) (ap (Const.«equivalentContentInstance») ([«?OBJ1», «?OBJ2»])))),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkImp (ap (Const.«equivalentContentInstance») ([«?OBJ1», «?OBJ2»])) (mkAnd [ap (Const.«subsumesContentInstance») ([«?OBJ1», «?OBJ2»]), ap (Const.«subsumesContentInstance») ([«?OBJ2», «?OBJ1»])]))),
ap (Const.«instance») ([Const.«subsumesContentInstance», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«subsumesContentInstance», Const.«PartialOrderingRelation»]),
ap (Const.«relatedInternalConcept») ([Const.«subsumesContentInstance», Const.«subsumesContentClass»]),
mkForall (fun («?INFO» : Obj) => mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkImp (mkAnd [ap (Const.«subsumesContentInstance») ([«?OBJ1», «?OBJ2»]), ap (Const.«containsInformation») ([«?OBJ2», «?INFO»])]) (ap (Const.«containsInformation») ([«?OBJ1», «?INFO»]))))),
ap (Const.«subrelation») ([Const.«realization», Const.«represents»]),
ap (Const.«instance») ([Const.«realization», Const.«AsymmetricRelation»]),
ap (Const.«relatedInternalConcept») ([Const.«realization», Const.«equivalentContentInstance»]),
ap (Const.«relatedInternalConcept») ([Const.«realization», Const.«containsInformation»]),
mkForall (fun («?PROCESS» : Obj) => mkForall (fun («?PROP» : Obj) => mkImp (ap (Const.«realization») ([«?PROCESS», «?PROP»])) (mkExists (fun («?OBJ» : Obj) => mkAnd [ap (Const.«instance») ([«?OBJ», Const.«ContentBearingObject»]), ap (Const.«containsInformation») ([«?OBJ», «?PROP»])])))),
ap (Const.«instance») ([Const.«expressedInLanguage», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«expressedInLanguage», Const.«AsymmetricRelation»]),
mkForall (fun («?EXPRESS» : Obj) => mkForall (fun («?LANGUAGE» : Obj) => mkImp (ap (Const.«expressedInLanguage») ([«?EXPRESS», «?LANGUAGE»])) (mkExists (fun («?PROP» : Obj) => ap (Const.«representsInLanguage») ([«?EXPRESS», «?PROP», «?LANGUAGE»]))))),
mkForall (fun («?EXPRESS» : Obj) => mkForall (fun («?LANGUAGE» : Obj) => mkForall (fun («?PROP» : Obj) => mkImp (ap (Const.«representsInLanguage») ([«?EXPRESS», «?PROP», «?LANGUAGE»])) (ap (Const.«expressedInLanguage») ([«?EXPRESS», «?LANGUAGE»]))))),
ap (Const.«instance») ([Const.«subProposition», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«subProposition», Const.«TransitiveRelation»]),
ap (Const.«instance») ([Const.«subProposition», Const.«IrreflexiveRelation»]),
ap (Const.«instance») ([Const.«subProposition», Const.«PartialValuedRelation»]),
mkForall (fun («?PROP1» : Obj) => mkForall (fun («?PROP2» : Obj) => mkImp (ap (Const.«subProposition») ([«?PROP1», «?PROP2»])) (mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkImp (mkAnd [ap (Const.«containsInformation») ([«?OBJ1», «?PROP1»]), ap (Const.«containsInformation») ([«?OBJ2», «?PROP2»])]) (ap (Const.«subsumesContentInstance») ([«?OBJ2», «?OBJ1»]))))))),
ap (Const.«subrelation») ([Const.«subPlan», Const.«subProposition»]),
ap (Const.«instance») ([Const.«subPlan», Const.«TransitiveRelation»]),
ap (Const.«instance») ([Const.«subPlan», Const.«IrreflexiveRelation»]),
ap (Const.«instance») ([Const.«subPlan», Const.«PartialValuedRelation»]),
ap (Const.«instance») ([Const.«uses», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«uses», Const.«AsymmetricRelation»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (ap (Const.«uses») ([«?OBJ», «?AGENT»])) (mkExists (fun («?PROC» : Obj) => mkAnd [ap (Const.«agent») ([«?PROC», «?AGENT»]), ap (Const.«instrument») ([«?PROC», «?OBJ»])])))),
ap (Const.«instance») ([Const.«MultiplicationFn», Const.«BinaryFunction»]),
ap (Const.«instance») ([Const.«MultiplicationFn», Const.«AssociativeFunction»]),
ap (Const.«instance») ([Const.«MultiplicationFn», Const.«CommutativeFunction»]),
ap (Const.«instance») ([Const.«MultiplicationFn», Const.«TotalValuedRelation»]),
ap (Const.«instance») ([Const.«AdditionFn», Const.«BinaryFunction»]),
ap (Const.«instance») ([Const.«AdditionFn», Const.«AssociativeFunction»]),
ap (Const.«instance») ([Const.«AdditionFn», Const.«CommutativeFunction»]),
ap (Const.«instance») ([Const.«AdditionFn», Const.«TotalValuedRelation»]),
mkForall (fun («?NUMBER» : Obj) => ap (Const.«equal») ([ap (Const.«SuccessorFn») ([«?NUMBER»]), ap (Const.«AdditionFn») ([«?NUMBER», numLit "1"])])),
ap (Const.«instance») ([Const.«SubtractionFn», Const.«BinaryFunction»]),
ap (Const.«instance») ([Const.«SubtractionFn», Const.«TotalValuedRelation»]),
mkForall (fun («?NUMBER» : Obj) => ap (Const.«equal») ([ap (Const.«PredecessorFn») ([«?NUMBER»]), ap (Const.«SubtractionFn») ([«?NUMBER», numLit "1"])])),
ap (Const.«instance») ([Const.«DivisionFn», Const.«BinaryFunction»]),
ap (Const.«instance») ([Const.«DivisionFn», Const.«PartialValuedRelation»]),
ap (Const.«instance») ([Const.«AbsoluteValueFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«AbsoluteValueFn», Const.«TotalValuedRelation»]),
mkForall (fun («?NUMBER1» : Obj) => mkForall (fun («?NUMBER2» : Obj) => mkIff (mkAnd [ap (Const.«equal») ([ap (Const.«AbsoluteValueFn») ([«?NUMBER1»]), «?NUMBER2»]), ap (Const.«instance») ([«?NUMBER1», Const.«RealNumber»]), ap (Const.«instance») ([«?NUMBER2», Const.«RealNumber»])]) (mkOr [mkAnd [ap (Const.«instance») ([«?NUMBER1», Const.«NonnegativeRealNumber»]), ap (Const.«equal») ([«?NUMBER1», «?NUMBER2»])], mkAnd [ap (Const.«instance») ([«?NUMBER1», Const.«NegativeRealNumber»]), ap (Const.«equal») ([«?NUMBER2», ap (Const.«SubtractionFn») ([numLit "0.0", «?NUMBER1»])])]]))),
ap (Const.«instance») ([Const.«CeilingFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«CeilingFn», Const.«TotalValuedRelation»]),
ap (Const.«instance») ([Const.«CosineFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«CosineFn», Const.«TotalValuedRelation»]),
ap (Const.«instance») ([Const.«DenominatorFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«DenominatorFn», Const.«TotalValuedRelation»]),
ap (Const.«instance») ([Const.«ExponentiationFn», Const.«BinaryFunction»]),
ap (Const.«instance») ([Const.«ExponentiationFn», Const.«TotalValuedRelation»]),
ap (Const.«instance») ([Const.«FloorFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«FloorFn», Const.«TotalValuedRelation»]),
ap (Const.«instance») ([Const.«GreatestCommonDivisorFn», Const.«Function»]),
ap (Const.«instance») ([Const.«GreatestCommonDivisorFn», Const.«VariableArityRelation»]),
ap (Const.«instance») ([Const.«GreatestCommonDivisorFn», Const.«PartialValuedRelation»]),
mkForallRow (fun («@ROW» : List Obj) => mkForall (fun («?ELEMENT» : Obj) => mkForall (fun («?NUMBER» : Obj) => mkImp (ap (Const.«equal») ([ap (Const.«GreatestCommonDivisorFn») («@ROW»), «?NUMBER»])) (mkImp (ap (Const.«inList») ([«?ELEMENT», ap (Const.«ListFn») («@ROW»)])) (ap (Const.«instance») ([«?ELEMENT», Const.«Number»])))))),
mkForallRow (fun («@ROW» : List Obj) => mkForall (fun («?NUMBER» : Obj) => mkImp (mkAnd [ap (Const.«equal») ([ap (Const.«GreatestCommonDivisorFn») («@ROW»), «?NUMBER»]), mkNot (ap (Const.«equal») ([«?NUMBER», numLit "0"]))]) (mkForall (fun («?ELEMENT» : Obj) => mkImp (ap (Const.«inList») ([«?ELEMENT», ap (Const.«ListFn») («@ROW»)])) (ap (Const.«equal») ([ap (Const.«RemainderFn») ([«?ELEMENT», «?NUMBER»]), numLit "0"])))))),
mkForallRow (fun («@ROW» : List Obj) => mkForall (fun («?NUMBER» : Obj) => mkImp (mkAnd [ap (Const.«equal») ([ap (Const.«GreatestCommonDivisorFn») («@ROW»), «?NUMBER»]), mkNot (ap (Const.«equal») ([«?NUMBER», numLit "0"]))]) (mkNot (mkExists (fun («?GREATER» : Obj) => mkAnd [ap (Const.«greaterThan») ([«?GREATER», «?NUMBER»]), mkForall (fun («?ELEMENT» : Obj) => mkImp (ap (Const.«inList») ([«?ELEMENT», ap (Const.«ListFn») («@ROW»)])) (ap (Const.«equal») ([ap (Const.«RemainderFn») ([«?ELEMENT», «?GREATER»]), numLit "0"])))]))))),
ap (Const.«instance») ([Const.«multiplicativeFactor», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«multiplicativeFactor», Const.«TransitiveRelation»]),
mkForall (fun («?N1» : Obj) => mkForall (fun («?N2» : Obj) => mkImp (ap (Const.«multiplicativeFactor») ([«?N1», «?N2»])) (mkExists (fun («?I» : Obj) => mkAnd [ap (Const.«instance») ([«?I», Const.«Integer»]), ap (Const.«equal») ([«?N2», ap (Const.«MultiplicationFn») ([«?N1», «?I»])])])))),
ap (Const.«instance») ([Const.«ImaginaryPartFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«ImaginaryPartFn», Const.«TotalValuedRelation»]),
ap (Const.«instance») ([Const.«IntegerSquareRootFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«IntegerSquareRootFn», Const.«PartialValuedRelation»]),
ap (Const.«instance») ([Const.«LeastCommonMultipleFn», Const.«Function»]),
ap (Const.«instance») ([Const.«LeastCommonMultipleFn», Const.«PartialValuedRelation»]),
ap (Const.«instance») ([Const.«LeastCommonMultipleFn», Const.«VariableArityRelation»]),
mkForallRow (fun («@ROW» : List Obj) => mkForall (fun («?ELEMENT» : Obj) => mkForall (fun («?NUMBER» : Obj) => mkImp (ap (Const.«equal») ([ap (Const.«LeastCommonMultipleFn») («@ROW»), «?NUMBER»])) (mkImp (ap (Const.«inList») ([«?ELEMENT», ap (Const.«ListFn») («@ROW»)])) (ap (Const.«instance») ([«?ELEMENT», Const.«Number»])))))),
mkForallRow (fun («@ROW» : List Obj) => mkForall (fun («?NUMBER» : Obj) => mkImp (mkAnd [ap (Const.«equal») ([ap (Const.«LeastCommonMultipleFn») («@ROW»), «?NUMBER»]), mkNot (ap (Const.«equal») ([«?NUMBER», numLit "0"]))]) (mkForall (fun («?ELEMENT» : Obj) => mkImp (ap (Const.«inList») ([«?ELEMENT», ap (Const.«ListFn») («@ROW»)])) (ap (Const.«equal») ([ap (Const.«RemainderFn») ([«?NUMBER», «?ELEMENT»]), numLit "0"])))))),
mkForallRow (fun («@ROW» : List Obj) => mkForall (fun («?NUMBER» : Obj) => mkImp (mkAnd [ap (Const.«equal») ([ap (Const.«LeastCommonMultipleFn») («@ROW»), «?NUMBER»]), mkNot (ap (Const.«equal») ([«?NUMBER», numLit "0"]))]) (mkNot (mkExists (fun («?LESS» : Obj) => mkAnd [ap (Const.«lessThan») ([«?LESS», «?NUMBER»]), mkForall (fun («?ELEMENT» : Obj) => mkImp (ap (Const.«inList») ([«?ELEMENT», ap (Const.«ListFn») («@ROW»)])) (ap (Const.«equal») ([ap (Const.«RemainderFn») ([«?LESS», «?ELEMENT»]), numLit "0"])))]))))),
ap (Const.«instance») ([Const.«LogFn», Const.«BinaryFunction»]),
ap (Const.«instance») ([Const.«MaxFn», Const.«BinaryFunction»]),
ap (Const.«instance») ([Const.«MaxFn», Const.«AssociativeFunction»]),
ap (Const.«instance») ([Const.«MaxFn», Const.«CommutativeFunction»]),
ap (Const.«instance») ([Const.«MaxFn», Const.«TotalValuedRelation»]),
mkForall (fun («?NUMBER» : Obj) => mkForall (fun («?NUMBER1» : Obj) => mkForall (fun («?NUMBER2» : Obj) => mkImp (ap (Const.«equal») ([ap (Const.«MaxFn») ([«?NUMBER1», «?NUMBER2»]), «?NUMBER»])) (mkOr [mkAnd [ap (Const.«equal») ([«?NUMBER», «?NUMBER1»]), ap (Const.«greaterThan») ([«?NUMBER1», «?NUMBER2»])], mkAnd [ap (Const.«equal») ([«?NUMBER», «?NUMBER2»]), ap (Const.«greaterThan») ([«?NUMBER2», «?NUMBER1»])], mkAnd [ap (Const.«equal») ([«?NUMBER», «?NUMBER1»]), ap (Const.«equal») ([«?NUMBER», «?NUMBER2»])]])))),
ap (Const.«instance») ([Const.«MinFn», Const.«BinaryFunction»]),
ap (Const.«instance») ([Const.«MinFn», Const.«AssociativeFunction»]),
ap (Const.«instance») ([Const.«MinFn», Const.«CommutativeFunction»]),
ap (Const.«instance») ([Const.«MinFn», Const.«TotalValuedRelation»]),
mkForall (fun («?NUMBER» : Obj) => mkForall (fun («?NUMBER1» : Obj) => mkForall (fun («?NUMBER2» : Obj) => mkImp (ap (Const.«equal») ([ap (Const.«MinFn») ([«?NUMBER1», «?NUMBER2»]), «?NUMBER»])) (mkOr [mkAnd [ap (Const.«equal») ([«?NUMBER», «?NUMBER1»]), ap (Const.«lessThan») ([«?NUMBER1», «?NUMBER2»])], mkAnd [ap (Const.«equal») ([«?NUMBER», «?NUMBER2»]), ap (Const.«lessThan») ([«?NUMBER2», «?NUMBER1»])], mkAnd [ap (Const.«equal») ([«?NUMBER», «?NUMBER1»]), ap (Const.«equal») ([«?NUMBER», «?NUMBER2»])]])))),
ap (Const.«instance») ([Const.«NumeratorFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«NumeratorFn», Const.«TotalValuedRelation»]),
ap (Const.«instance») ([Const.«Pi», Const.«PositiveRealNumber»]),
ap (Const.«instance») ([Const.«NumberE», Const.«PositiveRealNumber»]),
ap (Const.«instance») ([Const.«RationalNumberFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«RealNumberFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«ReciprocalFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«ReciprocalFn», Const.«TotalValuedRelation»]),
mkForall (fun («?NUMBER» : Obj) => mkImp (ap (Const.«instance») ([«?NUMBER», Const.«Integer»])) (ap (Const.«equal») ([ap (Const.«ReciprocalFn») ([«?NUMBER»]), ap (Const.«ExponentiationFn») ([«?NUMBER», numLit "-1"])]))),
mkForall (fun («?NUMBER» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?NUMBER», Const.«Integer»]), mkNot (ap (Const.«equal») ([«?NUMBER», numLit "0"]))]) (ap (Const.«equal») ([numLit "1", ap (Const.«MultiplicationFn») ([«?NUMBER», ap (Const.«ReciprocalFn») ([«?NUMBER»])])]))),
ap (Const.«instance») ([Const.«RemainderFn», Const.«BinaryFunction»]),
ap (Const.«instance») ([Const.«RemainderFn», Const.«PartialValuedRelation»]),
mkForall (fun («?NUMBER» : Obj) => mkForall (fun («?NUMBER1» : Obj) => mkForall (fun («?NUMBER2» : Obj) => mkImp (mkAnd [ap (Const.«equal») ([ap (Const.«RemainderFn») ([«?NUMBER1», «?NUMBER2»]), «?NUMBER»]), mkNot (ap (Const.«equal») ([«?NUMBER2», numLit "0"]))]) (ap (Const.«equal») ([ap (Const.«AdditionFn») ([ap (Const.«MultiplicationFn») ([ap (Const.«FloorFn») ([ap (Const.«DivisionFn») ([«?NUMBER1», «?NUMBER2»])]), «?NUMBER2»]), «?NUMBER»]), «?NUMBER1»]))))),
mkForall (fun («?NUMBER» : Obj) => mkForall (fun («?NUMBER1» : Obj) => mkForall (fun («?NUMBER2» : Obj) => mkImp (mkAnd [mkNot (ap (Const.«equal») ([«?NUMBER2», numLit "0"])), ap (Const.«equal») ([ap (Const.«AdditionFn») ([ap (Const.«MultiplicationFn») ([ap (Const.«FloorFn») ([ap (Const.«DivisionFn») ([«?NUMBER1», «?NUMBER2»])]), «?NUMBER2»]), «?NUMBER»]), «?NUMBER1»])]) (ap (Const.«equal») ([ap (Const.«RemainderFn») ([«?NUMBER1», «?NUMBER2»]), «?NUMBER»]))))),
mkForall (fun («?NUMBER» : Obj) => mkForall (fun («?NUMBER1» : Obj) => mkForall (fun («?NUMBER2» : Obj) => mkImp (mkAnd [ap (Const.«equal») ([ap (Const.«RemainderFn») ([«?NUMBER1», «?NUMBER2»]), «?NUMBER»]), mkNot (ap (Const.«equal») ([«?NUMBER», numLit "0"])), mkNot (ap (Const.«equal») ([«?NUMBER1», numLit "0"])), mkNot (ap (Const.«equal») ([«?NUMBER2», numLit "0"]))]) (ap (Const.«equal») ([ap (Const.«SignumFn») ([«?NUMBER2»]), ap (Const.«SignumFn») ([«?NUMBER»])]))))),
mkForall (fun («?NUMBER» : Obj) => mkImp (ap (Const.«instance») ([«?NUMBER», Const.«EvenInteger»])) (ap (Const.«equal») ([ap (Const.«RemainderFn») ([«?NUMBER», numLit "2"]), numLit "0"]))),
mkForall (fun («?NUMBER» : Obj) => mkImp (ap (Const.«instance») ([«?NUMBER», Const.«OddInteger»])) (ap (Const.«equal») ([ap (Const.«RemainderFn») ([«?NUMBER», numLit "2"]), numLit "1"]))),
mkForall (fun («?PRIME» : Obj) => mkImp (ap (Const.«instance») ([«?PRIME», Const.«PrimeNumber»])) (mkForall (fun («?NUMBER» : Obj) => mkImp (mkAnd [ap (Const.«equal») ([ap (Const.«RemainderFn») ([«?PRIME», «?NUMBER»]), numLit "0"]), mkNot (ap (Const.«equal») ([«?NUMBER», numLit "0"]))]) (mkOr [ap (Const.«equal») ([«?NUMBER», numLit "1"]), ap (Const.«equal») ([«?NUMBER», «?PRIME»])])))),
ap (Const.«instance») ([Const.«RoundFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«RoundFn», Const.«TotalValuedRelation»]),
ap (Const.«instance») ([Const.«SignumFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«SignumFn», Const.«TotalValuedRelation»]),
mkForall (fun («?NUMBER» : Obj) => mkImp (ap (Const.«instance») ([«?NUMBER», Const.«NonnegativeRealNumber»])) (mkOr [ap (Const.«equal») ([ap (Const.«SignumFn») ([«?NUMBER»]), numLit "1"]), ap (Const.«equal») ([ap (Const.«SignumFn») ([«?NUMBER»]), numLit "0"])])),
mkForall (fun («?NUMBER» : Obj) => mkImp (ap (Const.«instance») ([«?NUMBER», Const.«PositiveRealNumber»])) (ap (Const.«equal») ([ap (Const.«SignumFn») ([«?NUMBER»]), numLit "1"]))),
mkForall (fun («?NUMBER» : Obj) => mkImp (ap (Const.«instance») ([«?NUMBER», Const.«NegativeRealNumber»])) (ap (Const.«equal») ([ap (Const.«SignumFn») ([«?NUMBER»]), numLit "-1"]))),
ap (Const.«instance») ([Const.«SineFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«SineFn», Const.«TotalValuedRelation»]),
ap (Const.«instance») ([Const.«SquareRootFn», Const.«UnaryFunction»]),
mkForall (fun («?NUMBER1» : Obj) => mkForall (fun («?NUMBER2» : Obj) => mkImp (ap (Const.«equal») ([ap (Const.«SquareRootFn») ([«?NUMBER1»]), «?NUMBER2»])) (ap (Const.«equal») ([ap (Const.«MultiplicationFn») ([«?NUMBER2», «?NUMBER2»]), «?NUMBER1»])))),
ap (Const.«instance») ([Const.«TangentFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«TangentFn», Const.«TotalValuedRelation»]),
mkForall (fun («?DEGREE» : Obj) => mkImp (ap (Const.«instance») ([«?DEGREE», Const.«RealNumber»])) (ap (Const.«equal») ([ap (Const.«TangentFn») ([«?DEGREE»]), ap (Const.«DivisionFn») ([ap (Const.«SineFn») ([«?DEGREE»]), ap (Const.«CosineFn») ([«?DEGREE»])])]))),
ap (Const.«instance») ([Const.«ArcTangentFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«ArcTangentFn», Const.«TotalValuedRelation»]),
mkForall (fun («?X» : Obj) => ap (Const.«equal») ([ap (Const.«ArcTangentFn») ([ap (Const.«TangentFn») ([«?X»])]), «?X»])),
ap (Const.«instance») ([Const.«ArcCosineFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«ArcCosineFn», Const.«TotalValuedRelation»]),
mkForall (fun («?X» : Obj) => ap (Const.«equal») ([ap (Const.«ArcCosineFn») ([ap (Const.«CosineFn») ([«?X»])]), «?X»])),
ap (Const.«instance») ([Const.«ArcSineFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«ArcSineFn», Const.«TotalValuedRelation»]),
mkForall (fun («?X» : Obj) => ap (Const.«equal») ([ap (Const.«ArcSineFn») ([ap (Const.«SineFn») ([«?X»])]), «?X»])),
ap (Const.«instance») ([Const.«identityElement», Const.«BinaryPredicate»]),
ap (Const.«identityElement») ([Const.«MultiplicationFn», numLit "1"]),
ap (Const.«identityElement») ([Const.«AdditionFn», numLit "0"]),
ap (Const.«identityElement») ([Const.«SubtractionFn», numLit "0"]),
ap (Const.«identityElement») ([Const.«DivisionFn», numLit "1"]),
ap (Const.«instance») ([Const.«SuccessorFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«SuccessorFn», Const.«TotalValuedRelation»]),
mkForall (fun («?INT1» : Obj) => mkForall (fun («?INT2» : Obj) => mkImp (ap (Const.«equal») ([ap (Const.«SuccessorFn») ([«?INT1»]), ap (Const.«SuccessorFn») ([«?INT2»])])) (ap (Const.«equal») ([«?INT1», «?INT2»])))),
mkForall (fun («?INT» : Obj) => mkImp (ap (Const.«instance») ([«?INT», Const.«Integer»])) (ap (Const.«lessThan») ([«?INT», ap (Const.«SuccessorFn») ([«?INT»])]))),
mkForall (fun («?INT» : Obj) => mkImp (ap (Const.«instance») ([«?INT», Const.«Integer»])) (ap (Const.«equal») ([«?INT», ap (Const.«SuccessorFn») ([ap (Const.«PredecessorFn») ([«?INT»])])]))),
mkForall (fun («?INT» : Obj) => mkImp (ap (Const.«instance») ([«?INT», Const.«Integer»])) (ap (Const.«equal») ([«?INT», ap (Const.«PredecessorFn») ([ap (Const.«SuccessorFn») ([«?INT»])])]))),
ap (Const.«instance») ([Const.«PredecessorFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«PredecessorFn», Const.«TotalValuedRelation»]),
mkForall (fun («?INT1» : Obj) => mkForall (fun («?INT2» : Obj) => mkImp (ap (Const.«equal») ([ap (Const.«PredecessorFn») ([«?INT1»]), ap (Const.«PredecessorFn») ([«?INT2»])])) (ap (Const.«equal») ([«?INT1», «?INT2»])))),
mkForall (fun («?INT» : Obj) => mkImp (ap (Const.«instance») ([«?INT», Const.«Integer»])) (ap (Const.«greaterThan») ([«?INT», ap (Const.«PredecessorFn») ([«?INT»])]))),
ap (Const.«instance») ([Const.«average», Const.«PartialValuedRelation»]),
ap (Const.«instance») ([Const.«average», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«average», Const.«SingleValuedRelation»]),
mkForall (fun («?AVERAGE» : Obj) => mkForall (fun («?LIST» : Obj) => mkImp (ap (Const.«average») ([«?LIST», «?AVERAGE»])) (mkForall (fun («?LISTITEM» : Obj) => mkImp (ap (Const.«inList») ([«?LISTITEM», «?LIST»])) (ap (Const.«instance») ([«?LISTITEM», Const.«RealNumber»])))))),
ap (Const.«instance») ([Const.«subset», Const.«BinaryPredicate»]),
mkForall (fun («?ELEMENT» : Obj) => mkForall (fun («?SET» : Obj) => mkForall (fun («?SUBSET» : Obj) => mkImp (mkAnd [ap (Const.«subset») ([«?SUBSET», «?SET»]), ap (Const.«element») ([«?ELEMENT», «?SUBSET»])]) (ap (Const.«element») ([«?ELEMENT», «?SET»]))))),
mkForall (fun («?ELEMENT» : Obj) => mkForall (fun («?SET» : Obj) => mkForall (fun («?SUBSET» : Obj) => mkImp (mkImp (ap (Const.«element») ([«?ELEMENT», «?SUBSET»])) (ap (Const.«element») ([«?ELEMENT», «?SET»]))) (ap (Const.«subset») ([«?SUBSET», «?SET»]))))),
ap (Const.«instance») ([Const.«element», Const.«BinaryPredicate»]),
mkForall (fun («?ELEMENT» : Obj) => mkForall (fun («?SET1» : Obj) => mkForall (fun («?SET2» : Obj) => mkImp (mkIff (ap (Const.«element») ([«?ELEMENT», «?SET1»])) (ap (Const.«element») ([«?ELEMENT», «?SET2»]))) (ap (Const.«equal») ([«?SET1», «?SET2»]))))),
ap (Const.«instance») ([Const.«UnionFn», Const.«BinaryFunction»]),
ap (Const.«instance») ([Const.«UnionFn», Const.«TotalValuedRelation»]),
ap (Const.«instance») ([Const.«IntersectionFn», Const.«BinaryFunction»]),
ap (Const.«instance») ([Const.«IntersectionFn», Const.«TotalValuedRelation»]),
ap (Const.«instance») ([Const.«RelativeComplementFn», Const.«BinaryFunction»]),
ap (Const.«instance») ([Const.«RelativeComplementFn», Const.«TotalValuedRelation»]),
ap (Const.«instance») ([Const.«ComplementFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«ComplementFn», Const.«TotalValuedRelation»]),
ap (Const.«instance») ([Const.«GeneralizedUnionFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«GeneralizedUnionFn», Const.«TotalValuedRelation»]),
ap (Const.«instance») ([Const.«GeneralizedIntersectionFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«GeneralizedIntersectionFn», Const.«TotalValuedRelation»]),
ap (Const.«instance») ([Const.«CardinalityFn», Const.«UnaryFunction»]),
ap (Const.«subclass») ([Const.«NullSet», Const.«Set»]),
mkForall (fun («?SET» : Obj) => mkImp (ap (Const.«instance») ([«?SET», Const.«NullSet»])) (mkNot (mkExists (fun («?INST» : Obj) => ap (Const.«element») ([«?INST», «?SET»]))))),
ap (Const.«subclass») ([Const.«NonNullSet», Const.«Set»]),
mkForall (fun («?SET» : Obj) => mkImp (ap (Const.«instance») ([«?SET», Const.«NonNullSet»])) (mkExists (fun («?INST» : Obj) => ap (Const.«element») ([«?INST», «?SET»])))),
ap (Const.«subclass») ([Const.«FiniteSet», Const.«Set»]),
mkForall (fun («?SET» : Obj) => mkImp (ap (Const.«instance») ([«?SET», Const.«FiniteSet»])) (mkExists (fun («?NUMBER» : Obj) => mkAnd [ap (Const.«instance») ([«?NUMBER», Const.«NonnegativeInteger»]), ap (Const.«equal») ([«?NUMBER», ap (Const.«CardinalityFn») ([«?SET»])])]))),
ap (Const.«instance») ([Const.«KappaFn», Const.«BinaryFunction»]),
ap (Const.«instance») ([Const.«KappaFn», Const.«PartialValuedRelation»]),
ap (Const.«subclass») ([Const.«Graph», Const.«Proposition»]),
mkForall (fun («?GRAPH» : Obj) => mkForall (fun («?NODE1» : Obj) => mkForall (fun («?NODE2» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?GRAPH», Const.«Graph»]), ap (Const.«instance») ([«?NODE1», Const.«GraphNode»]), ap (Const.«instance») ([«?NODE2», Const.«GraphNode»]), ap (Const.«graphPart») ([«?NODE1», «?GRAPH»]), ap (Const.«graphPart») ([«?NODE2», «?GRAPH»]), mkNot (ap (Const.«equal») ([«?NODE1», «?NODE2»]))]) (mkExists (fun («?ARC» : Obj) => mkExists (fun («?PATH» : Obj) => mkOr [ap (Const.«links») ([«?NODE1», «?NODE2», «?ARC»]), mkAnd [ap (Const.«subGraph») ([«?PATH», «?GRAPH»]), ap (Const.«instance») ([«?PATH», Const.«GraphPath»]), mkOr [mkAnd [ap (Const.«equal») ([ap (Const.«BeginNodeFn») ([«?PATH»]), «?NODE1»]), ap (Const.«equal») ([ap (Const.«EndNodeFn») ([«?PATH»]), «?NODE2»])], mkAnd [ap (Const.«equal») ([ap (Const.«BeginNodeFn») ([«?PATH»]), «?NODE2»]), ap (Const.«equal») ([ap (Const.«EndNodeFn») ([«?PATH»]), «?NODE1»])]]]])))))),
mkForall (fun («?GRAPH» : Obj) => mkImp (ap (Const.«instance») ([«?GRAPH», Const.«Graph»])) (mkExists (fun («?NODE1» : Obj) => mkExists (fun («?NODE2» : Obj) => mkExists (fun («?NODE3» : Obj) => mkExists (fun («?ARC1» : Obj) => mkExists (fun («?ARC2» : Obj) => mkAnd [ap (Const.«graphPart») ([«?NODE1», «?GRAPH»]), ap (Const.«graphPart») ([«?NODE2», «?GRAPH»]), ap (Const.«graphPart») ([«?NODE3», «?GRAPH»]), ap (Const.«graphPart») ([«?ARC1», «?GRAPH»]), ap (Const.«graphPart») ([«?ARC2», «?GRAPH»]), ap (Const.«links») ([«?NODE1», «?NODE2», «?ARC1»]), ap (Const.«links») ([«?NODE2», «?NODE3», «?ARC2»]), mkNot (ap (Const.«equal») ([«?NODE1», «?NODE2»])), mkNot (ap (Const.«equal») ([«?NODE2», «?NODE3»])), mkNot (ap (Const.«equal») ([«?NODE1», «?NODE3»])), mkNot (ap (Const.«equal») ([«?ARC1», «?ARC2»]))]))))))),
ap (Const.«subclass») ([Const.«DirectedGraph», Const.«Graph»]),
mkForall (fun («?ARC» : Obj) => mkForall (fun («?GRAPH» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?GRAPH», Const.«DirectedGraph»]), ap (Const.«instance») ([«?ARC», Const.«GraphArc»]), ap (Const.«graphPart») ([«?ARC», «?GRAPH»])]) (mkExists (fun («?NODE1» : Obj) => mkExists (fun («?NODE2» : Obj) => mkAnd [ap (Const.«equal») ([ap (Const.«InitialNodeFn») ([«?ARC»]), «?NODE1»]), ap (Const.«equal») ([ap (Const.«TerminalNodeFn») ([«?ARC»]), «?NODE2»])]))))),
ap (Const.«subclass») ([Const.«Tree», Const.«DirectedGraph»]),
mkForall (fun («?GRAPH» : Obj) => mkImp (ap (Const.«instance») ([«?GRAPH», Const.«Tree»])) (mkNot (mkExists (fun («?LOOP» : Obj) => mkAnd [ap (Const.«instance») ([«?LOOP», Const.«GraphLoop»]), ap (Const.«graphPart») ([«?LOOP», «?GRAPH»])])))),
mkForall (fun («?GRAPH» : Obj) => mkImp (ap (Const.«instance») ([«?GRAPH», Const.«Tree»])) (mkNot (mkExists (fun («?LOOP» : Obj) => mkAnd [ap (Const.«instance») ([«?LOOP», Const.«GraphCircuit»]), ap (Const.«graphPart») ([«?LOOP», «?GRAPH»])])))),
mkForall (fun («?GRAPH» : Obj) => mkImp (ap (Const.«instance») ([«?GRAPH», Const.«Tree»])) (mkNot (mkExists (fun («?ARC1» : Obj) => mkExists (fun («?ARC2» : Obj) => mkExists (fun («?NODE» : Obj) => mkAnd [ap (Const.«graphPart») ([«?ARC1», «?GRAPH»]), ap (Const.«graphPart») ([«?ARC2», «?GRAPH»]), ap (Const.«graphPart») ([«?NODE», «?GRAPH»]), ap (Const.«equal») ([ap (Const.«TerminalNodeFn») ([«?ARC1»]), «?NODE»]), ap (Const.«equal») ([ap (Const.«TerminalNodeFn») ([«?ARC2»]), «?NODE»]), mkNot (ap (Const.«equal») ([«?ARC1», «?ARC2»]))])))))),
ap (Const.«subclass») ([Const.«GraphPath», Const.«DirectedGraph»]),
mkForall (fun («?ARC» : Obj) => mkForall (fun («?GRAPH» : Obj) => mkForall (fun («?NODE» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?GRAPH», Const.«GraphPath»]), ap (Const.«instance») ([«?ARC», Const.«GraphArc»]), ap (Const.«graphPart») ([«?ARC», «?GRAPH»]), ap (Const.«equal») ([ap (Const.«InitialNodeFn») ([«?ARC»]), «?NODE»])]) (mkNot (mkExists (fun («?OTHER» : Obj) => mkAnd [ap (Const.«equal») ([ap (Const.«InitialNodeFn») ([«?OTHER»]), «?NODE»]), mkNot (ap (Const.«equal») ([«?OTHER», «?ARC»]))])))))),
mkForall (fun («?ARC» : Obj) => mkForall (fun («?GRAPH» : Obj) => mkForall (fun («?NODE» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?GRAPH», Const.«GraphPath»]), ap (Const.«instance») ([«?ARC», Const.«GraphArc»]), ap (Const.«graphPart») ([«?ARC», «?GRAPH»]), ap (Const.«equal») ([ap (Const.«TerminalNodeFn») ([«?ARC»]), «?NODE»])]) (mkNot (mkExists (fun («?OTHER» : Obj) => mkAnd [ap (Const.«equal») ([ap (Const.«TerminalNodeFn») ([«?OTHER»]), «?NODE»]), mkNot (ap (Const.«equal») ([«?OTHER», «?ARC»]))])))))),
ap (Const.«subclass») ([Const.«GraphCircuit», Const.«GraphPath»]),
mkForall (fun («?GRAPH» : Obj) => mkImp (ap (Const.«instance») ([«?GRAPH», Const.«GraphCircuit»])) (mkExists (fun («?NODE» : Obj) => mkAnd [ap (Const.«equal») ([ap (Const.«BeginNodeFn») ([«?GRAPH»]), «?NODE»]), ap (Const.«equal») ([ap (Const.«EndNodeFn») ([«?GRAPH»]), «?NODE»])]))),
mkForall (fun («?GRAPH» : Obj) => mkForall (fun («?NODE» : Obj) => mkImp (mkAnd [ap (Const.«equal») ([ap (Const.«BeginNodeFn») ([«?GRAPH»]), «?NODE»]), ap (Const.«equal») ([ap (Const.«EndNodeFn») ([«?GRAPH»]), «?NODE»])]) (ap (Const.«instance») ([«?GRAPH», Const.«GraphCircuit»])))),
ap (Const.«subclass») ([Const.«MultiGraph», Const.«Graph»]),
mkForall (fun («?GRAPH» : Obj) => mkImp (ap (Const.«instance») ([«?GRAPH», Const.«MultiGraph»])) (mkExists (fun («?ARC1» : Obj) => mkExists (fun («?ARC2» : Obj) => mkExists (fun («?NODE1» : Obj) => mkExists (fun («?NODE2» : Obj) => mkAnd [ap (Const.«graphPart») ([«?ARC1», «?GRAPH»]), ap (Const.«graphPart») ([«?ARC2», «?GRAPH»]), ap (Const.«graphPart») ([«?NODE1», «?GRAPH»]), ap (Const.«graphPart») ([«?NODE2», «?GRAPH»]), ap (Const.«links») ([«?NODE1», «?NODE2», «?ARC1»]), ap (Const.«links») ([«?NODE1», «?NODE2», «?ARC2»]), mkNot (ap (Const.«equal») ([«?ARC1», «?ARC2»]))])))))),
mkForall (fun («?ARC1» : Obj) => mkForall (fun («?ARC2» : Obj) => mkForall (fun («?GRAPH» : Obj) => mkForall (fun («?NODE1» : Obj) => mkForall (fun («?NODE2» : Obj) => mkImp (mkAnd [ap (Const.«graphPart») ([«?ARC1», «?GRAPH»]), ap (Const.«graphPart») ([«?ARC2», «?GRAPH»]), ap (Const.«graphPart») ([«?NODE1», «?GRAPH»]), ap (Const.«graphPart») ([«?NODE2», «?GRAPH»]), ap (Const.«links») ([«?NODE1», «?NODE2», «?ARC1»]), ap (Const.«links») ([«?NODE1», «?NODE2», «?ARC2»]), mkNot (ap (Const.«equal») ([«?ARC1», «?ARC2»]))]) (ap (Const.«instance») ([«?GRAPH», Const.«MultiGraph»]))))))),
ap (Const.«subclass») ([Const.«PseudoGraph», Const.«Graph»]),
mkForall (fun («?GRAPH» : Obj) => mkImp (ap (Const.«instance») ([«?GRAPH», Const.«PseudoGraph»])) (mkExists (fun («?LOOP» : Obj) => mkAnd [ap (Const.«instance») ([«?LOOP», Const.«GraphLoop»]), ap (Const.«graphPart») ([«?LOOP», «?GRAPH»])]))),
mkForall (fun («?GRAPH» : Obj) => mkForall (fun («?LOOP» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?LOOP», Const.«GraphLoop»]), ap (Const.«graphPart») ([«?LOOP», «?GRAPH»])]) (ap (Const.«instance») ([«?GRAPH», Const.«PseudoGraph»])))),
ap (Const.«subclass») ([Const.«GraphElement», Const.«Proposition»]),
ap (Const.«partition») ([Const.«GraphElement», Const.«GraphNode», Const.«GraphArc»]),
mkForall (fun («?PART» : Obj) => mkImp (ap (Const.«instance») ([«?PART», Const.«GraphElement»])) (mkExists (fun («?GRAPH» : Obj) => mkAnd [ap (Const.«instance») ([«?GRAPH», Const.«Graph»]), ap (Const.«graphPart») ([«?PART», «?GRAPH»])]))),
ap (Const.«subclass») ([Const.«GraphNode», Const.«GraphElement»]),
mkForall (fun («?NODE» : Obj) => mkImp (ap (Const.«instance») ([«?NODE», Const.«GraphNode»])) (mkExists (fun («?OTHER» : Obj) => mkExists (fun («?ARC» : Obj) => ap (Const.«links») ([«?NODE», «?OTHER», «?ARC»]))))),
ap (Const.«subclass») ([Const.«GraphArc», Const.«GraphElement»]),
mkForall (fun («?ARC» : Obj) => mkImp (ap (Const.«instance») ([«?ARC», Const.«GraphArc»])) (mkExists (fun («?NODE1» : Obj) => mkExists (fun («?NODE2» : Obj) => ap (Const.«links») ([«?NODE1», «?NODE2», «?ARC»]))))),
ap (Const.«subclass») ([Const.«GraphLoop», Const.«GraphArc»]),
mkForall (fun («?LOOP» : Obj) => mkImp (ap (Const.«instance») ([«?LOOP», Const.«GraphLoop»])) (mkExists (fun («?NODE» : Obj) => ap (Const.«links») ([«?NODE», «?NODE», «?LOOP»])))),
mkForall (fun («?LOOP» : Obj) => mkForall (fun («?NODE» : Obj) => mkImp (ap (Const.«links») ([«?NODE», «?NODE», «?LOOP»])) (ap (Const.«instance») ([«?LOOP», Const.«GraphLoop»])))),
mkForall (fun («?ARC» : Obj) => mkForall (fun («?NODE» : Obj) => mkImp (mkAnd [ap (Const.«equal») ([ap (Const.«InitialNodeFn») ([«?ARC»]), «?NODE»]), ap (Const.«equal») ([ap (Const.«TerminalNodeFn») ([«?ARC»]), «?NODE»])]) (ap (Const.«instance») ([«?ARC», Const.«GraphLoop»])))),
ap (Const.«instance») ([Const.«links», Const.«TernaryPredicate»]),
mkForall (fun («?ARC» : Obj) => mkForall (fun («?NODE1» : Obj) => mkForall (fun («?NODE2» : Obj) => mkImp (ap (Const.«links») ([«?NODE1», «?NODE2», «?ARC»])) (ap (Const.«links») ([«?NODE2», «?NODE1», «?ARC»]))))),
ap (Const.«instance») ([Const.«graphPart», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«graphPart», Const.«AsymmetricRelation»]),
ap (Const.«instance») ([Const.«graphPart», Const.«TotalValuedRelation»]),
ap (Const.«instance») ([Const.«graphPart», Const.«IrreflexiveRelation»]),
ap (Const.«instance») ([Const.«subGraph», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«subGraph», Const.«ReflexiveRelation»]),
ap (Const.«instance») ([Const.«subGraph», Const.«TransitiveRelation»]),
mkForall (fun («?ELEMENT» : Obj) => mkForall (fun («?GRAPH1» : Obj) => mkForall (fun («?GRAPH2» : Obj) => mkImp (mkAnd [ap (Const.«subGraph») ([«?GRAPH1», «?GRAPH2»]), ap (Const.«graphPart») ([«?ELEMENT», «?GRAPH1»])]) (ap (Const.«graphPart») ([«?ELEMENT», «?GRAPH2»]))))),
ap (Const.«instance») ([Const.«pathLength», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«InitialNodeFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«InitialNodeFn», Const.«PartialValuedRelation»]),
ap (Const.«instance») ([Const.«TerminalNodeFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«TerminalNodeFn», Const.«PartialValuedRelation»]),
ap (Const.«instance») ([Const.«BeginNodeFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«BeginNodeFn», Const.«TotalValuedRelation»]),
ap (Const.«relatedInternalConcept») ([Const.«BeginNodeFn», Const.«InitialNodeFn»]),
ap (Const.«instance») ([Const.«EndNodeFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«EndNodeFn», Const.«TotalValuedRelation»]),
ap (Const.«relatedInternalConcept») ([Const.«EndNodeFn», Const.«TerminalNodeFn»]),
ap (Const.«instance») ([Const.«arcWeight», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«arcWeight», Const.«SingleValuedRelation»]),
ap (Const.«instance») ([Const.«PathWeightFn», Const.«UnaryFunction»]),
mkForall (fun («?ARC1» : Obj) => mkForall (fun («?NUMBER1» : Obj) => mkForall (fun («?PATH» : Obj) => mkForall (fun («?SUBPATH» : Obj) => mkForall (fun («?SUM» : Obj) => mkImp (mkAnd [ap (Const.«equal») ([ap (Const.«PathWeightFn») ([«?PATH»]), «?SUM»]), ap (Const.«subGraph») ([«?SUBPATH», «?PATH»]), ap (Const.«graphPart») ([«?ARC1», «?PATH»]), ap (Const.«arcWeight») ([«?ARC1», «?NUMBER1»]), mkForall (fun («?ARC2» : Obj) => mkImp (ap (Const.«graphPart») ([«?ARC2», «?PATH»])) (mkOr [ap (Const.«graphPart») ([«?ARC2», «?SUBPATH»]), ap (Const.«equal») ([«?ARC2», «?ARC1»])]))]) (ap (Const.«equal») ([«?SUM», ap (Const.«AdditionFn») ([ap (Const.«PathWeightFn») ([«?SUBPATH»]), «?NUMBER1»])]))))))),
mkForall (fun («?ARC1» : Obj) => mkForall (fun («?ARC2» : Obj) => mkForall (fun («?NUMBER1» : Obj) => mkForall (fun («?NUMBER2» : Obj) => mkForall (fun («?PATH» : Obj) => mkForall (fun («?SUM» : Obj) => mkImp (mkAnd [ap (Const.«equal») ([ap (Const.«PathWeightFn») ([«?PATH»]), «?SUM»]), ap (Const.«graphPart») ([«?ARC1», «?PATH»]), ap (Const.«graphPart») ([«?ARC2», «?PATH»]), ap (Const.«arcWeight») ([«?ARC1», «?NUMBER1»]), ap (Const.«arcWeight») ([«?ARC2», «?NUMBER2»]), mkForall (fun («?ARC3» : Obj) => mkImp (ap (Const.«graphPart») ([«?ARC3», «?PATH»])) (mkOr [ap (Const.«equal») ([«?ARC3», «?ARC1»]), ap (Const.«equal») ([«?ARC3», «?ARC2»])]))]) (ap (Const.«equal») ([ap (Const.«PathWeightFn») ([«?PATH»]), ap (Const.«AdditionFn») ([«?NUMBER1», «?NUMBER2»])])))))))),
ap (Const.«instance») ([Const.«MinimalWeightedPathFn», Const.«BinaryFunction»]),
ap (Const.«instance») ([Const.«MinimalWeightedPathFn», Const.«TotalValuedRelation»]),
mkForall (fun («?NODE1» : Obj) => mkForall (fun («?NODE2» : Obj) => mkForall (fun («?PATH» : Obj) => mkImp (ap (Const.«equal») ([ap (Const.«MinimalWeightedPathFn») ([«?NODE1», «?NODE2»]), «?PATH»])) (ap (Const.«instance») ([«?PATH», ap (Const.«GraphPathFn») ([«?NODE1», «?NODE2»])]))))),
mkForall (fun («?NODE1» : Obj) => mkForall (fun («?NODE2» : Obj) => mkForall (fun («?NUMBER1» : Obj) => mkForall (fun («?NUMBER2» : Obj) => mkForall (fun («?PATH» : Obj) => mkForall (fun («?PATH2» : Obj) => mkImp (mkAnd [ap (Const.«equal») ([ap (Const.«MinimalWeightedPathFn») ([«?NODE1», «?NODE2»]), «?PATH»]), ap (Const.«equal») ([ap (Const.«PathWeightFn») ([«?PATH»]), «?NUMBER1»]), ap (Const.«instance») ([«?PATH2», ap (Const.«GraphPathFn») ([«?NODE1», «?NODE2»])]), ap (Const.«equal») ([ap (Const.«PathWeightFn») ([«?PATH2»]), «?NUMBER2»])]) (ap (Const.«greaterThanOrEqualTo») ([«?NUMBER2», «?NUMBER1»])))))))),
ap (Const.«instance») ([Const.«MaximalWeightedPathFn», Const.«BinaryFunction»]),
ap (Const.«instance») ([Const.«MaximalWeightedPathFn», Const.«TotalValuedRelation»]),
mkForall (fun («?NODE1» : Obj) => mkForall (fun («?NODE2» : Obj) => mkForall (fun («?PATH» : Obj) => mkImp (ap (Const.«equal») ([ap (Const.«MaximalWeightedPathFn») ([«?NODE1», «?NODE2»]), «?PATH»])) (ap (Const.«instance») ([«?PATH», ap (Const.«GraphPathFn») ([«?NODE1», «?NODE2»])]))))),
mkForall (fun («?NODE1» : Obj) => mkForall (fun («?NODE2» : Obj) => mkForall (fun («?NUMBER1» : Obj) => mkForall (fun («?NUMBER2» : Obj) => mkForall (fun («?PATH» : Obj) => mkForall (fun («?PATH2» : Obj) => mkImp (mkAnd [ap (Const.«equal») ([ap (Const.«MaximalWeightedPathFn») ([«?NODE1», «?NODE2»]), «?PATH»]), ap (Const.«equal») ([ap (Const.«PathWeightFn») ([«?PATH»]), «?NUMBER1»]), ap (Const.«instance») ([«?PATH2», ap (Const.«GraphPathFn») ([«?NODE1», «?NODE2»])]), ap (Const.«equal») ([ap (Const.«PathWeightFn») ([«?PATH2»]), «?NUMBER2»])]) (ap (Const.«lessThanOrEqualTo») ([«?NUMBER2», «?NUMBER1»])))))))),
ap (Const.«instance») ([Const.«GraphPathFn», Const.«BinaryFunction»]),
ap (Const.«instance») ([Const.«GraphPathFn», Const.«TotalValuedRelation»]),
mkForall (fun («?GRAPH» : Obj) => mkForall (fun («?NODE1» : Obj) => mkForall (fun («?NODE2» : Obj) => mkForall (fun («?PATH» : Obj) => mkImp (mkAnd [ap (Const.«graphPart») ([«?PATH», «?GRAPH»]), mkNot (ap (Const.«instance») ([«?GRAPH», Const.«DirectedGraph»]))]) (mkIff (ap (Const.«instance») ([«?PATH», ap (Const.«GraphPathFn») ([«?NODE1», «?NODE2»])])) (ap (Const.«instance») ([«?PATH», ap (Const.«GraphPathFn») ([«?NODE2», «?NODE1»])]))))))),
ap (Const.«instance») ([Const.«CutSetFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«MinimalCutSetFn», Const.«UnaryFunction»]),
ap (Const.«relatedInternalConcept») ([Const.«MinimalCutSetFn», Const.«CutSetFn»]),
mkForall (fun («?GRAPH» : Obj) => mkImp (ap (Const.«instance») ([«?GRAPH», Const.«Graph»])) (ap (Const.«subclass») ([ap (Const.«MinimalCutSetFn») ([«?GRAPH»]), ap (Const.«CutSetFn») ([«?GRAPH»])]))),
mkForall (fun («?GRAPH» : Obj) => mkForall (fun («?PATHCLASS» : Obj) => mkImp (ap (Const.«equal») ([ap (Const.«MinimalCutSetFn») ([«?GRAPH»]), «?PATHCLASS»])) (mkExists (fun («?NUMBER» : Obj) => mkForall (fun («?PATH» : Obj) => mkImp (ap (Const.«instance») ([«?PATH», «?PATHCLASS»])) (ap (Const.«pathLength») ([«?PATH», «?NUMBER»]))))))),
mkForall (fun («?GRAPH» : Obj) => mkForall (fun («?NUMBER1» : Obj) => mkForall (fun («?NUMBER2» : Obj) => mkNot (mkExists (fun («?PATH1» : Obj) => mkExists (fun («?PATH2» : Obj) => mkAnd [ap (Const.«instance») ([«?PATH1», ap (Const.«CutSetFn») ([«?GRAPH»])]), ap (Const.«instance») ([«?PATH2», ap (Const.«MinimalCutSetFn») ([«?GRAPH»])]), ap (Const.«pathLength») ([«?PATH1», «?NUMBER1»]), ap (Const.«pathLength») ([«?PATH2», «?NUMBER2»]), ap (Const.«lessThan») ([«?NUMBER1», «?NUMBER2»])])))))),
ap (Const.«instance») ([Const.«abstractCounterpart», Const.«BinaryPredicate»]),
ap (Const.«subrelation») ([Const.«abstractCounterpart», Const.«represents»]),
ap (Const.«subclass») ([Const.«PhysicalSystem», Const.«Physical»]),
ap (Const.«instance») ([Const.«subSystem», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«systemPart», Const.«BinaryPredicate»]),
mkForall (fun («?PART» : Obj) => mkForall (fun («?SUB» : Obj) => mkForall (fun («?SYSTEM» : Obj) => mkImp (mkAnd [ap (Const.«subSystem») ([«?SUB», «?SYSTEM»]), ap (Const.«systemPart») ([«?PART», «?SUB»])]) (ap (Const.«systemPart») ([«?PART», «?SYSTEM»]))))),
ap (Const.«instance») ([Const.«graphMeasure», Const.«BinaryPredicate»]),
mkForall (fun («?G» : Obj) => mkForall (fun («?M» : Obj) => mkImp (ap (Const.«graphMeasure») ([«?G», «?M»])) (mkForall (fun («?AC» : Obj) => mkAnd [ap (Const.«graphPart») ([«?AC», «?G»]), mkExists (fun («?PC» : Obj) => ap (Const.«abstractCounterpart») ([«?AC», «?PC»]))])))),
mkForall (fun («?AA» : Obj) => mkForall (fun («?AN» : Obj) => mkForall (fun («?G» : Obj) => mkForall (fun («?M» : Obj) => mkForall (fun («?N» : Obj) => mkForall (fun («?PA» : Obj) => mkForall (fun («?PN» : Obj) => mkImp (mkAnd [ap (Const.«graphMeasure») ([«?G», «?M»]), ap (Const.«instance») ([«?AN», Const.«GraphNode»]), ap (Const.«graphPart») ([«?AN», «?G»]), ap (Const.«graphPart») ([«?AA», «?G»]), ap (Const.«instance») ([«?AA», Const.«GraphArc»]), ap (Const.«abstractCounterpart») ([«?AN», «?PN»]), ap (Const.«abstractCounterpart») ([«?AA», «?PA»]), ap (Const.«arcWeight») ([«?AA», «?N»])]) (ap (Const.«measure») ([«?PA», ap (Const.«MeasureFn») ([«?N», «?M»])]))))))))),
ap (Const.«subclass») ([Const.«UnitOfMeasure», Const.«PhysicalQuantity»]),
ap (Const.«subclass») ([Const.«CompositeUnitOfMeasure», Const.«UnitOfMeasure»]),
ap (Const.«subclass») ([Const.«CompositeUnitOfMeasure», Const.«FunctionQuantity»]),
ap (Const.«subclass») ([Const.«NonCompositeUnitOfMeasure», Const.«UnitOfMeasure»]),
ap (Const.«subclass») ([Const.«NonCompositeUnitOfMeasure», Const.«ConstantQuantity»]),
ap (Const.«partition») ([Const.«UnitOfMeasure», Const.«CompositeUnitOfMeasure», Const.«NonCompositeUnitOfMeasure»]),
mkForall (fun («?N» : Obj) => mkForall (fun («?QUANT» : Obj) => mkForall (fun («?UNIT» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?QUANT», ap (Const.«MeasureFn») ([«?N», «?UNIT»])]), ap (Const.«instance») ([«?UNIT», Const.«CompositeUnitOfMeasure»])]) (ap (Const.«instance») ([«?QUANT», Const.«FunctionQuantity»]))))),
mkForall (fun («?N» : Obj) => mkForall (fun («?QUANT» : Obj) => mkForall (fun («?UNIT» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?QUANT», ap (Const.«MeasureFn») ([«?N», «?UNIT»])]), ap (Const.«instance») ([«?UNIT», Const.«NonCompositeUnitOfMeasure»])]) (ap (Const.«instance») ([«?QUANT», Const.«ConstantQuantity»]))))),
ap (Const.«subclass») ([Const.«SystemeInternationalUnit», Const.«UnitOfMeasure»]),
ap (Const.«subclass») ([Const.«LengthMeasure», Const.«ConstantQuantity»]),
ap (Const.«subclass») ([Const.«UnitOfLength», Const.«NonCompositeUnitOfMeasure»]),
ap (Const.«subclass») ([Const.«MassMeasure», Const.«ConstantQuantity»]),
ap (Const.«subclass») ([Const.«UnitOfMass», Const.«NonCompositeUnitOfMeasure»]),
ap (Const.«subclass») ([Const.«AreaMeasure», Const.«FunctionQuantity»]),
ap (Const.«subclass») ([Const.«UnitOfArea», Const.«CompositeUnitOfMeasure»]),
ap (Const.«subclass») ([Const.«VolumeMeasure», Const.«FunctionQuantity»]),
ap (Const.«subclass») ([Const.«UnitOfVolume», Const.«CompositeUnitOfMeasure»]),
ap (Const.«subclass») ([Const.«TemperatureMeasure», Const.«ConstantQuantity»]),
ap (Const.«subclass») ([Const.«UnitOfTemperature», Const.«NonCompositeUnitOfMeasure»]),
ap (Const.«subclass») ([Const.«CurrencyMeasure», Const.«ConstantQuantity»]),
ap (Const.«subclass») ([Const.«UnitOfCurrency», Const.«NonCompositeUnitOfMeasure»]),
ap (Const.«subclass») ([Const.«AngleMeasure», Const.«ConstantQuantity»]),
ap (Const.«subclass») ([Const.«UnitOfAngularMeasure», Const.«NonCompositeUnitOfMeasure»]),
ap (Const.«subclass») ([Const.«PlaneAngleMeasure», Const.«AngleMeasure»]),
ap (Const.«subclass») ([Const.«SolidAngleMeasure», Const.«AngleMeasure»]),
ap (Const.«disjoint») ([Const.«SolidAngleMeasure», Const.«PlaneAngleMeasure»]),
ap (Const.«subclass») ([Const.«UnitOfInformation», Const.«NonCompositeUnitOfMeasure»]),
ap (Const.«subclass») ([Const.«UnitOfDuration», Const.«NonCompositeUnitOfMeasure»]),
ap (Const.«instance») ([Const.«MeasureFn», Const.«BinaryFunction»]),
ap (Const.«instance») ([Const.«MeasureFn», Const.«TotalValuedRelation»]),
mkForall (fun («?NUMBER» : Obj) => mkForall (fun («?QUANT» : Obj) => mkForall (fun («?UNIT» : Obj) => mkImp (mkAnd [ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?NUMBER», «?UNIT»]), «?QUANT»]), ap (Const.«instance») ([«?UNIT», Const.«UnitOfLength»])]) (ap (Const.«instance») ([«?QUANT», Const.«LengthMeasure»]))))),
mkForall (fun («?NUMBER» : Obj) => mkForall (fun («?QUANT» : Obj) => mkForall (fun («?UNIT» : Obj) => mkImp (mkAnd [ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?NUMBER», «?UNIT»]), «?QUANT»]), ap (Const.«instance») ([«?UNIT», Const.«UnitOfMass»])]) (ap (Const.«instance») ([«?QUANT», Const.«MassMeasure»]))))),
mkForall (fun («?NUMBER» : Obj) => mkForall (fun («?QUANT» : Obj) => mkForall (fun («?UNIT» : Obj) => mkImp (mkAnd [ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?NUMBER», «?UNIT»]), «?QUANT»]), ap (Const.«instance») ([«?UNIT», Const.«UnitOfArea»])]) (ap (Const.«instance») ([«?QUANT», Const.«AreaMeasure»]))))),
mkForall (fun («?NUMBER» : Obj) => mkForall (fun («?QUANT» : Obj) => mkForall (fun («?UNIT» : Obj) => mkImp (mkAnd [ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?NUMBER», «?UNIT»]), «?QUANT»]), ap (Const.«instance») ([«?UNIT», Const.«UnitOfVolume»])]) (ap (Const.«instance») ([«?QUANT», Const.«VolumeMeasure»]))))),
mkForall (fun («?NUMBER» : Obj) => mkForall (fun («?QUANT» : Obj) => mkForall (fun («?UNIT» : Obj) => mkImp (mkAnd [ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?NUMBER», «?UNIT»]), «?QUANT»]), ap (Const.«instance») ([«?UNIT», Const.«UnitOfTemperature»])]) (ap (Const.«instance») ([«?QUANT», Const.«TemperatureMeasure»]))))),
mkForall (fun («?NUMBER» : Obj) => mkForall (fun («?QUANT» : Obj) => mkForall (fun («?UNIT» : Obj) => mkImp (mkAnd [ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?NUMBER», «?UNIT»]), «?QUANT»]), ap (Const.«instance») ([«?UNIT», Const.«UnitOfCurrency»])]) (ap (Const.«instance») ([«?QUANT», Const.«CurrencyMeasure»]))))),
mkForall (fun («?NUMBER» : Obj) => mkForall (fun («?QUANT» : Obj) => mkForall (fun («?UNIT» : Obj) => mkImp (mkAnd [ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?NUMBER», «?UNIT»]), «?QUANT»]), ap (Const.«instance») ([«?UNIT», Const.«UnitOfAngularMeasure»])]) (ap (Const.«instance») ([«?QUANT», Const.«AngleMeasure»]))))),
mkForall (fun («?NUMBER» : Obj) => mkForall (fun («?QUANT» : Obj) => mkForall (fun («?UNIT» : Obj) => mkImp (mkAnd [ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?NUMBER», «?UNIT»]), «?QUANT»]), ap (Const.«instance») ([«?UNIT», Const.«UnitOfDuration»])]) (ap (Const.«instance») ([«?QUANT», Const.«TimeDuration»]))))),
mkForall (fun («?NUMBER» : Obj) => mkForall (fun («?QUANT» : Obj) => mkForall (fun («?UNIT» : Obj) => mkImp (mkAnd [ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?NUMBER», «?UNIT»]), «?QUANT»]), ap (Const.«instance») ([«?UNIT», Const.«UnitOfInformation»])]) (ap (Const.«instance») ([«?QUANT», Const.«InformationMeasure»]))))),
ap (Const.«subclass») ([Const.«UnitOfMeasureMultiplier», Const.«UnaryFunction»]),
ap (Const.«subclass») ([Const.«UnitOfMeasureMultiplier», Const.«TotalValuedRelation»]),
mkForall (fun («?FUNCTION» : Obj) => mkForall (fun («?UNIT» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?FUNCTION», Const.«UnitOfMeasureMultiplier»]), ap (Const.«instance») ([«?UNIT», Const.«CompositeUnitOfMeasure»])]) (ap (Const.«instance») ([ap («?FUNCTION») ([«?UNIT»]), Const.«CompositeUnitOfMeasure»])))),
mkForall (fun («?FUNCTION» : Obj) => mkForall (fun («?UNIT» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?FUNCTION», Const.«UnitOfMeasureMultiplier»]), ap (Const.«instance») ([«?UNIT», Const.«NonCompositeUnitOfMeasure»])]) (ap (Const.«instance») ([ap («?FUNCTION») ([«?UNIT»]), Const.«NonCompositeUnitOfMeasure»])))),
ap (Const.«instance») ([Const.«KiloFn», Const.«UnitOfMeasureMultiplier»]),
mkForall (fun («?KILOUNIT» : Obj) => mkForall (fun («?UNIT» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?UNIT», Const.«UnitOfMeasure»]), ap (Const.«equal») ([«?KILOUNIT», ap (Const.«KiloFn») ([«?UNIT»])])]) (ap (Const.«equal») ([ap (Const.«MeasureFn») ([numLit "1", «?KILOUNIT»]), ap (Const.«MeasureFn») ([numLit "1000", «?UNIT»])])))),
ap (Const.«instance») ([Const.«MegaFn», Const.«UnitOfMeasureMultiplier»]),
mkForall (fun («?MEGAUNIT» : Obj) => mkForall (fun («?UNIT» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?UNIT», Const.«UnitOfMeasure»]), ap (Const.«equal») ([«?MEGAUNIT», ap (Const.«MegaFn») ([«?UNIT»])])]) (ap (Const.«equal») ([ap (Const.«MeasureFn») ([numLit "1", «?MEGAUNIT»]), ap (Const.«MeasureFn») ([numLit "1000000", «?UNIT»])])))),
ap (Const.«instance») ([Const.«GigaFn», Const.«UnitOfMeasureMultiplier»]),
mkForall (fun («?GIGAUNIT» : Obj) => mkForall (fun («?UNIT» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?UNIT», Const.«UnitOfMeasure»]), ap (Const.«equal») ([«?GIGAUNIT», ap (Const.«GigaFn») ([«?UNIT»])])]) (ap (Const.«equal») ([ap (Const.«MeasureFn») ([numLit "1", «?GIGAUNIT»]), ap (Const.«MeasureFn») ([numLit "1000000", ap (Const.«KiloFn») ([«?UNIT»])])])))),
ap (Const.«instance») ([Const.«TeraFn», Const.«UnitOfMeasureMultiplier»]),
mkForall (fun («?TERAUNIT» : Obj) => mkForall (fun («?UNIT» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?UNIT», Const.«UnitOfMeasure»]), ap (Const.«equal») ([«?TERAUNIT», ap (Const.«TeraFn») ([«?UNIT»])])]) (ap (Const.«equal») ([ap (Const.«MeasureFn») ([numLit "1", «?TERAUNIT»]), ap (Const.«MeasureFn») ([numLit "1000000000", ap (Const.«KiloFn») ([«?UNIT»])])])))),
ap (Const.«instance») ([Const.«MilliFn», Const.«UnitOfMeasureMultiplier»]),
mkForall (fun («?MILLIUNIT» : Obj) => mkForall (fun («?UNIT» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?UNIT», Const.«UnitOfMeasure»]), ap (Const.«equal») ([«?MILLIUNIT», ap (Const.«MilliFn») ([«?UNIT»])])]) (ap (Const.«equal») ([ap (Const.«MeasureFn») ([numLit "1", «?MILLIUNIT»]), ap (Const.«MeasureFn») ([numLit "0.001", «?UNIT»])])))),
ap (Const.«instance») ([Const.«MicroFn», Const.«UnitOfMeasureMultiplier»]),
mkForall (fun («?MICROUNIT» : Obj) => mkForall (fun («?UNIT» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?UNIT», Const.«UnitOfMeasure»]), ap (Const.«equal») ([«?MICROUNIT», ap (Const.«MicroFn») ([«?UNIT»])])]) (ap (Const.«equal») ([ap (Const.«MeasureFn») ([numLit "1", «?MICROUNIT»]), ap (Const.«MeasureFn») ([numLit "0.000001", «?UNIT»])])))),
ap (Const.«instance») ([Const.«NanoFn», Const.«UnitOfMeasureMultiplier»]),
mkForall (fun («?NANOUNIT» : Obj) => mkForall (fun («?UNIT» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?UNIT», Const.«UnitOfMeasure»]), ap (Const.«equal») ([«?NANOUNIT», ap (Const.«NanoFn») ([«?UNIT»])])]) (ap (Const.«equal») ([ap (Const.«MeasureFn») ([numLit "1", «?NANOUNIT»]), ap (Const.«MeasureFn») ([numLit "0.000000001", «?UNIT»])])))),
ap (Const.«instance») ([Const.«PicoFn», Const.«UnitOfMeasureMultiplier»]),
mkForall (fun («?PICOUNIT» : Obj) => mkForall (fun («?UNIT» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?UNIT», Const.«UnitOfMeasure»]), ap (Const.«equal») ([«?PICOUNIT», ap (Const.«PicoFn») ([«?UNIT»])])]) (ap (Const.«equal») ([ap (Const.«MeasureFn») ([numLit "1", «?PICOUNIT»]), ap (Const.«MeasureFn») ([numLit "0.000000000001", «?UNIT»])])))),
ap (Const.«instance») ([Const.«IntervalFn», Const.«BinaryFunction»]),
ap (Const.«instance») ([Const.«IntervalFn», Const.«TotalValuedRelation»]),
ap (Const.«relatedInternalConcept») ([Const.«IntervalFn», Const.«RecurrentTimeIntervalFn»]),
mkForall (fun («?CLASS» : Obj) => mkForall (fun («?FROM» : Obj) => mkForall (fun («?QUANTITY» : Obj) => mkForall (fun («?TO» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?QUANTITY», ap (Const.«IntervalFn») ([«?FROM», «?TO»])]), ap (Const.«instance») ([«?FROM», «?CLASS»]), ap (Const.«instance») ([«?TO», «?CLASS»])]) (ap (Const.«instance») ([«?QUANTITY», «?CLASS»])))))),
ap (Const.«instance») ([Const.«UnitFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«UnitFn», Const.«TotalValuedRelation»]),
mkForall (fun («?NUMBER» : Obj) => mkForall (fun («?QUANT» : Obj) => mkForall (fun («?UNIT» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?QUANT», Const.«PhysicalQuantity»]), ap (Const.«instance») ([«?UNIT», Const.«UnitOfMeasure»]), ap (Const.«equal») ([«?QUANT», ap (Const.«MeasureFn») ([«?NUMBER», «?UNIT»])])]) (ap (Const.«equal») ([ap (Const.«UnitFn») ([«?QUANT»]), «?UNIT»]))))),
ap (Const.«instance») ([Const.«PerFn», Const.«BinaryFunction»]),
ap (Const.«instance») ([Const.«PerFn», Const.«TotalValuedRelation»]),
ap (Const.«subrelation») ([Const.«DensityFn», Const.«PerFn»]),
ap (Const.«instance») ([Const.«DensityFn», Const.«TotalValuedRelation»]),
ap (Const.«instance») ([Const.«DensityFn», Const.«BinaryFunction»]),
ap (Const.«subrelation») ([Const.«SpeedFn», Const.«PerFn»]),
ap (Const.«instance») ([Const.«SpeedFn», Const.«TotalValuedRelation»]),
ap (Const.«instance») ([Const.«SpeedFn», Const.«BinaryFunction»]),
ap (Const.«instance») ([Const.«VelocityFn», Const.«QuaternaryFunction»]),
ap (Const.«instance») ([Const.«VelocityFn», Const.«TotalValuedRelation»]),
mkForall (fun («?DIRECTION» : Obj) => mkForall (fun («?DISTANCE» : Obj) => mkForall (fun («?OBJECT» : Obj) => mkForall (fun («?REF» : Obj) => mkForall (fun («?TIME» : Obj) => mkImp (ap (Const.«measure») ([«?OBJECT», ap (Const.«VelocityFn») ([«?DISTANCE», «?TIME», «?REF», «?DIRECTION»])])) (ap (Const.«measure») ([«?OBJECT», ap (Const.«SpeedFn») ([«?DISTANCE», «?TIME»])]))))))),
ap (Const.«instance») ([Const.«Meter», Const.«UnitOfLength»]),
ap (Const.«instance») ([Const.«Meter», Const.«SystemeInternationalUnit»]),
ap (Const.«instance») ([Const.«Gram», Const.«UnitOfMass»]),
ap (Const.«instance») ([Const.«Gram», Const.«SystemeInternationalUnit»]),
ap (Const.«instance») ([Const.«SecondDuration», Const.«UnitOfDuration»]),
ap (Const.«instance») ([Const.«SecondDuration», Const.«TimeDuration»]),
ap (Const.«instance») ([Const.«SecondDuration», Const.«SystemeInternationalUnit»]),
ap (Const.«instance») ([Const.«Ampere», Const.«CompositeUnitOfMeasure»]),
ap (Const.«instance») ([Const.«Ampere», Const.«SystemeInternationalUnit»]),
ap (Const.«instance») ([Const.«KelvinDegree», Const.«UnitOfTemperature»]),
ap (Const.«instance») ([Const.«KelvinDegree», Const.«SystemeInternationalUnit»]),
ap (Const.«instance») ([Const.«Mole», Const.«UnitOfMass»]),
ap (Const.«instance») ([Const.«Mole», Const.«SystemeInternationalUnit»]),
ap (Const.«instance») ([Const.«Candela», Const.«CompositeUnitOfMeasure»]),
ap (Const.«instance») ([Const.«Candela», Const.«SystemeInternationalUnit»]),
ap (Const.«instance») ([Const.«Liter», Const.«UnitOfVolume»]),
ap (Const.«instance») ([Const.«Centimeter», Const.«UnitOfLength»]),
mkForall (fun («?NUMBER» : Obj) => ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?NUMBER», Const.«Centimeter»]), ap (Const.«MeasureFn») ([ap (Const.«MultiplicationFn») ([«?NUMBER», numLit "0.01"]), Const.«Meter»])])),
ap (Const.«instance») ([Const.«Millimeter», Const.«UnitOfLength»]),
mkForall (fun («?NUMBER» : Obj) => ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?NUMBER», Const.«Millimeter»]), ap (Const.«MeasureFn») ([ap (Const.«MultiplicationFn») ([«?NUMBER», numLit "0.001"]), Const.«Meter»])])),
ap (Const.«instance») ([Const.«Kilometer», Const.«UnitOfLength»]),
mkForall (fun («?NUMBER» : Obj) => ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?NUMBER», Const.«Kilometer»]), ap (Const.«MeasureFn») ([ap (Const.«MultiplicationFn») ([«?NUMBER», numLit "1000"]), Const.«Meter»])])),
ap (Const.«instance») ([Const.«Radian», Const.«UnitOfAngularMeasure»]),
ap (Const.«instance») ([Const.«Radian», Const.«SystemeInternationalUnit»]),
ap (Const.«instance») ([Const.«Steradian», Const.«UnitOfAngularMeasure»]),
ap (Const.«instance») ([Const.«Steradian», Const.«SystemeInternationalUnit»]),
ap (Const.«subclass») ([Const.«FrequencyMeasure», Const.«TimeDependentQuantity»]),
ap (Const.«subclass») ([Const.«UnitOfFrequency», Const.«CompositeUnitOfMeasure»]),
mkForall (fun («?NUMBER» : Obj) => mkForall (fun («?QUANT» : Obj) => mkForall (fun («?UNIT» : Obj) => mkImp (mkAnd [ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?NUMBER», «?UNIT»]), «?QUANT»]), ap (Const.«instance») ([«?UNIT», Const.«UnitOfFrequency»])]) (ap (Const.«instance») ([«?QUANT», Const.«FrequencyMeasure»]))))),
ap (Const.«instance») ([Const.«Hertz», Const.«UnitOfFrequency»]),
ap (Const.«instance») ([Const.«Hertz», Const.«SystemeInternationalUnit»]),
ap (Const.«instance») ([Const.«Newton», Const.«CompositeUnitOfMeasure»]),
ap (Const.«instance») ([Const.«Newton», Const.«SystemeInternationalUnit»]),
ap (Const.«instance») ([Const.«Pascal», Const.«CompositeUnitOfMeasure»]),
ap (Const.«instance») ([Const.«Pascal», Const.«SystemeInternationalUnit»]),
ap (Const.«instance») ([Const.«Joule», Const.«CompositeUnitOfMeasure»]),
ap (Const.«instance») ([Const.«Joule», Const.«SystemeInternationalUnit»]),
ap (Const.«instance») ([Const.«Watt», Const.«CompositeUnitOfMeasure»]),
ap (Const.«instance») ([Const.«Watt», Const.«SystemeInternationalUnit»]),
ap (Const.«instance») ([Const.«Horsepower», Const.«CompositeUnitOfMeasure»]),
mkForall (fun («?N» : Obj) => mkImp (ap (Const.«instance») ([«?N», Const.«RealNumber»])) (ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?N», Const.«Horsepower»]), ap (Const.«MeasureFn») ([ap (Const.«MultiplicationFn») ([«?N», numLit "746"]), Const.«Watt»])]))),
ap (Const.«instance») ([Const.«Coulomb», Const.«CompositeUnitOfMeasure»]),
ap (Const.«instance») ([Const.«Coulomb», Const.«SystemeInternationalUnit»]),
mkForall (fun («?NUMBER» : Obj) => mkForall (fun («?QUANTITY» : Obj) => mkImp (ap (Const.«equal») ([«?QUANTITY», ap (Const.«MeasureFn») ([«?NUMBER», Const.«Coulomb»])])) (ap (Const.«instance») ([«?QUANTITY», Const.«TimeDependentQuantity»])))),
ap (Const.«instance») ([Const.«Volt», Const.«CompositeUnitOfMeasure»]),
ap (Const.«instance») ([Const.«Volt», Const.«SystemeInternationalUnit»]),
ap (Const.«instance») ([Const.«Farad», Const.«CompositeUnitOfMeasure»]),
ap (Const.«instance») ([Const.«Farad», Const.«SystemeInternationalUnit»]),
ap (Const.«instance») ([Const.«Ohm», Const.«CompositeUnitOfMeasure»]),
ap (Const.«instance») ([Const.«Ohm», Const.«SystemeInternationalUnit»]),
ap (Const.«instance») ([Const.«Siemens», Const.«CompositeUnitOfMeasure»]),
ap (Const.«instance») ([Const.«Siemens», Const.«SystemeInternationalUnit»]),
ap (Const.«instance») ([Const.«Weber», Const.«CompositeUnitOfMeasure»]),
ap (Const.«instance») ([Const.«Weber», Const.«SystemeInternationalUnit»]),
ap (Const.«instance») ([Const.«Tesla», Const.«CompositeUnitOfMeasure»]),
ap (Const.«instance») ([Const.«Tesla», Const.«SystemeInternationalUnit»]),
ap (Const.«instance») ([Const.«Henry», Const.«CompositeUnitOfMeasure»]),
ap (Const.«instance») ([Const.«Henry», Const.«SystemeInternationalUnit»]),
ap (Const.«instance») ([Const.«CelsiusDegree», Const.«UnitOfTemperature»]),
ap (Const.«instance») ([Const.«CelsiusDegree», Const.«SystemeInternationalUnit»]),
mkForall (fun («?NUMBER» : Obj) => ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?NUMBER», Const.«CelsiusDegree»]), ap (Const.«MeasureFn») ([ap (Const.«SubtractionFn») ([«?NUMBER», numLit "273.15"]), Const.«KelvinDegree»])])),
mkForall (fun («?NUMBER» : Obj) => ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?NUMBER», Const.«CelsiusDegree»]), ap (Const.«MeasureFn») ([ap (Const.«DivisionFn») ([ap (Const.«SubtractionFn») ([«?NUMBER», numLit "32.0"]), numLit "1.8"]), Const.«FahrenheitDegree»])])),
ap (Const.«instance») ([Const.«Lumen», Const.«CompositeUnitOfMeasure»]),
ap (Const.«instance») ([Const.«Lumen», Const.«SystemeInternationalUnit»]),
ap (Const.«instance») ([Const.«Lux», Const.«CompositeUnitOfMeasure»]),
ap (Const.«instance») ([Const.«Lux», Const.«SystemeInternationalUnit»]),
ap (Const.«instance») ([Const.«Becquerel», Const.«CompositeUnitOfMeasure»]),
ap (Const.«instance») ([Const.«Becquerel», Const.«SystemeInternationalUnit»]),
mkForall (fun («?NUMBER» : Obj) => mkForall (fun («?QUANTITY» : Obj) => mkImp (ap (Const.«equal») ([«?QUANTITY», ap (Const.«MeasureFn») ([«?NUMBER», Const.«Becquerel»])])) (ap (Const.«instance») ([«?QUANTITY», Const.«TimeDependentQuantity»])))),
ap (Const.«instance») ([Const.«Gray», Const.«CompositeUnitOfMeasure»]),
ap (Const.«instance») ([Const.«Gray», Const.«SystemeInternationalUnit»]),
ap (Const.«instance») ([Const.«Sievert», Const.«CompositeUnitOfMeasure»]),
ap (Const.«instance») ([Const.«Sievert», Const.«SystemeInternationalUnit»]),
ap (Const.«instance») ([Const.«DayDuration», Const.«UnitOfDuration»]),
ap (Const.«instance») ([Const.«DayDuration», Const.«TimeDuration»]),
mkForall (fun («?NUMBER» : Obj) => ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?NUMBER», Const.«DayDuration»]), ap (Const.«MeasureFn») ([ap (Const.«MultiplicationFn») ([«?NUMBER», numLit "24"]), Const.«HourDuration»])])),
ap (Const.«instance») ([Const.«HourDuration», Const.«UnitOfDuration»]),
ap (Const.«instance») ([Const.«HourDuration», Const.«TimeDuration»]),
mkForall (fun («?NUMBER» : Obj) => ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?NUMBER», Const.«HourDuration»]), ap (Const.«MeasureFn») ([ap (Const.«MultiplicationFn») ([«?NUMBER», numLit "60"]), Const.«MinuteDuration»])])),
ap (Const.«instance») ([Const.«MinuteDuration», Const.«UnitOfDuration»]),
ap (Const.«instance») ([Const.«MinuteDuration», Const.«TimeDuration»]),
mkForall (fun («?NUMBER» : Obj) => ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?NUMBER», Const.«MinuteDuration»]), ap (Const.«MeasureFn») ([ap (Const.«MultiplicationFn») ([«?NUMBER», numLit "60"]), Const.«SecondDuration»])])),
ap (Const.«instance») ([Const.«WeekDuration», Const.«UnitOfDuration»]),
ap (Const.«instance») ([Const.«WeekDuration», Const.«TimeDuration»]),
ap (Const.«equal») ([ap (Const.«MeasureFn») ([numLit "1", Const.«WeekDuration»]), ap (Const.«MeasureFn») ([numLit "7", Const.«DayDuration»])]),
ap (Const.«instance») ([Const.«MonthDuration», Const.«UnitOfDuration»]),
ap (Const.«instance») ([Const.«MonthDuration», Const.«TimeDuration»]),
mkForall (fun («?NUMBER» : Obj) => mkImp (ap (Const.«equal») ([ap (Const.«MeasureFn») ([numLit "1", Const.«MonthDuration»]), ap (Const.«MeasureFn») ([«?NUMBER», Const.«DayDuration»])])) (ap (Const.«greaterThanOrEqualTo») ([«?NUMBER», numLit "28"]))),
mkForall (fun («?NUMBER» : Obj) => mkImp (ap (Const.«equal») ([ap (Const.«MeasureFn») ([numLit "1", Const.«MonthDuration»]), ap (Const.«MeasureFn») ([«?NUMBER», Const.«DayDuration»])])) (ap (Const.«lessThanOrEqualTo») ([«?NUMBER», numLit "31"]))),
ap (Const.«instance») ([Const.«YearDuration», Const.«UnitOfDuration»]),
ap (Const.«instance») ([Const.«YearDuration», Const.«TimeDuration»]),
ap (Const.«equal») ([ap (Const.«MeasureFn») ([numLit "1", Const.«YearDuration»]), ap (Const.«MeasureFn») ([numLit "365", Const.«DayDuration»])]),
ap (Const.«instance») ([Const.«Amu», Const.«UnitOfMass»]),
mkForall (fun («?NUMBER» : Obj) => ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?NUMBER», Const.«Amu»]), ap (Const.«MeasureFn») ([ap (Const.«MultiplicationFn») ([«?NUMBER», ap (Const.«DivisionFn») ([ap (Const.«DivisionFn») ([ap (Const.«DivisionFn») ([ap (Const.«DivisionFn») ([numLit "1.6605402", numLit "1000000.0"]), numLit "1000000.0"]), numLit "1000000.0"]), numLit "1000000.0"])]), Const.«Gram»])])),
ap (Const.«instance») ([Const.«ElectronVolt», Const.«CompositeUnitOfMeasure»]),
mkForall (fun («?NUMBER» : Obj) => ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?NUMBER», Const.«ElectronVolt»]), ap (Const.«MeasureFn») ([ap (Const.«MultiplicationFn») ([«?NUMBER», ap (Const.«DivisionFn») ([ap (Const.«DivisionFn») ([ap (Const.«DivisionFn») ([numLit "1.60217733", numLit "1000000.0"]), numLit "1000000.0"]), numLit "10000000.0"])]), Const.«Joule»])])),
ap (Const.«instance») ([Const.«Angstrom», Const.«UnitOfLength»]),
mkForall (fun («?NUMBER» : Obj) => ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?NUMBER», Const.«Angstrom»]), ap (Const.«MeasureFn») ([ap (Const.«MultiplicationFn») ([«?NUMBER», ap (Const.«DivisionFn») ([ap (Const.«DivisionFn») ([numLit "1.0", numLit "100000.0"]), numLit "100000.0"])]), Const.«Meter»])])),
ap (Const.«instance») ([Const.«FootLength», Const.«UnitOfLength»]),
mkForall (fun («?NUMBER» : Obj) => ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?NUMBER», Const.«FootLength»]), ap (Const.«MeasureFn») ([ap (Const.«MultiplicationFn») ([«?NUMBER», numLit "0.3048"]), Const.«Meter»])])),
ap (Const.«instance») ([Const.«Inch», Const.«UnitOfLength»]),
mkForall (fun («?NUMBER» : Obj) => ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?NUMBER», Const.«Inch»]), ap (Const.«MeasureFn») ([ap (Const.«MultiplicationFn») ([«?NUMBER», numLit "0.0254"]), Const.«Meter»])])),
ap (Const.«instance») ([Const.«Mile», Const.«UnitOfLength»]),
mkForall (fun («?NUMBER» : Obj) => ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?NUMBER», Const.«Mile»]), ap (Const.«MeasureFn») ([ap (Const.«MultiplicationFn») ([«?NUMBER», numLit "1609.344"]), Const.«Meter»])])),
ap (Const.«instance») ([Const.«UnitedStatesGallon», Const.«UnitOfVolume»]),
ap (Const.«relatedInternalConcept») ([Const.«UnitedStatesGallon», Const.«UnitedKingdomGallon»]),
mkForall (fun («?NUMBER» : Obj) => ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?NUMBER», Const.«UnitedStatesGallon»]), ap (Const.«MeasureFn») ([ap (Const.«MultiplicationFn») ([«?NUMBER», numLit "3.785411784"]), Const.«Liter»])])),
ap (Const.«instance») ([Const.«Quart», Const.«UnitOfVolume»]),
mkForall (fun («?NUMBER» : Obj) => ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?NUMBER», Const.«Quart»]), ap (Const.«MeasureFn») ([ap (Const.«DivisionFn») ([«?NUMBER», numLit "4"]), Const.«UnitedStatesGallon»])])),
ap (Const.«instance») ([Const.«Pint», Const.«UnitOfVolume»]),
mkForall (fun («?NUMBER» : Obj) => ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?NUMBER», Const.«Pint»]), ap (Const.«MeasureFn») ([ap (Const.«DivisionFn») ([«?NUMBER», numLit "2"]), Const.«Quart»])])),
ap (Const.«instance») ([Const.«Cup», Const.«UnitOfVolume»]),
mkForall (fun («?NUMBER» : Obj) => ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?NUMBER», Const.«Cup»]), ap (Const.«MeasureFn») ([ap (Const.«DivisionFn») ([«?NUMBER», numLit "2"]), Const.«Pint»])])),
ap (Const.«instance») ([Const.«Ounce», Const.«UnitOfVolume»]),
mkForall (fun («?NUMBER» : Obj) => ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?NUMBER», Const.«Ounce»]), ap (Const.«MeasureFn») ([ap (Const.«DivisionFn») ([«?NUMBER», numLit "8"]), Const.«Cup»])])),
ap (Const.«instance») ([Const.«UnitedKingdomGallon», Const.«UnitOfVolume»]),
mkForall (fun («?NUMBER» : Obj) => ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?NUMBER», Const.«UnitedKingdomGallon»]), ap (Const.«MeasureFn») ([ap (Const.«MultiplicationFn») ([«?NUMBER», numLit "4.54609"]), Const.«Liter»])])),
ap (Const.«instance») ([Const.«AtomGram», Const.«UnitOfMass»]),
ap (Const.«instance») ([Const.«Kilogram», Const.«SystemeInternationalUnit»]),
ap (Const.«instance») ([Const.«Kilogram», Const.«UnitOfMass»]),
mkForall (fun («?NUMBER» : Obj) => ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?NUMBER», Const.«Kilogram»]), ap (Const.«MeasureFn») ([ap (Const.«MultiplicationFn») ([«?NUMBER», numLit "1000"]), Const.«Gram»])])),
ap (Const.«instance») ([Const.«weight», Const.«BinaryPredicate»]),
ap (Const.«subrelation») ([Const.«weight», Const.«measure»]),
ap (Const.«instance») ([Const.«PoundMass», Const.«UnitOfMass»]),
mkForall (fun («?NUMBER» : Obj) => ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?NUMBER», Const.«PoundMass»]), ap (Const.«MeasureFn») ([ap (Const.«MultiplicationFn») ([«?NUMBER», numLit "453.59237"]), Const.«Gram»])])),
ap (Const.«instance») ([Const.«Slug», Const.«UnitOfMass»]),
mkForall (fun («?NUMBER» : Obj) => ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?NUMBER», Const.«Slug»]), ap (Const.«MeasureFn») ([ap (Const.«MultiplicationFn») ([«?NUMBER», numLit "14593.90"]), Const.«Gram»])])),
ap (Const.«instance») ([Const.«RankineDegree», Const.«UnitOfTemperature»]),
mkForall (fun («?NUMBER» : Obj) => ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?NUMBER», Const.«RankineDegree»]), ap (Const.«MeasureFn») ([ap (Const.«MultiplicationFn») ([«?NUMBER», numLit "1.8"]), Const.«KelvinDegree»])])),
ap (Const.«instance») ([Const.«FahrenheitDegree», Const.«UnitOfTemperature»]),
ap (Const.«instance») ([Const.«PoundForce», Const.«CompositeUnitOfMeasure»]),
mkForall (fun («?NUMBER» : Obj) => ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?NUMBER», Const.«PoundForce»]), ap (Const.«MeasureFn») ([ap (Const.«MultiplicationFn») ([«?NUMBER», numLit "4.448222"]), Const.«Newton»])])),
ap (Const.«instance») ([Const.«Calorie», Const.«CompositeUnitOfMeasure»]),
mkForall (fun («?NUMBER» : Obj) => ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?NUMBER», Const.«Calorie»]), ap (Const.«MeasureFn») ([ap (Const.«MultiplicationFn») ([«?NUMBER», numLit "4.1868"]), Const.«Joule»])])),
ap (Const.«instance») ([Const.«BritishThermalUnit», Const.«CompositeUnitOfMeasure»]),
mkForall (fun («?NUMBER» : Obj) => ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?NUMBER», Const.«BritishThermalUnit»]), ap (Const.«MeasureFn») ([ap (Const.«MultiplicationFn») ([«?NUMBER», numLit "1055.05585262"]), Const.«Joule»])])),
ap (Const.«instance») ([Const.«AngularDegree», Const.«UnitOfAngularMeasure»]),
mkForall (fun («?N» : Obj) => mkForall (fun («?QUANT» : Obj) => mkImp (ap (Const.«equal») ([«?QUANT», ap (Const.«MeasureFn») ([«?N», Const.«AngularDegree»])])) (ap (Const.«instance») ([«?QUANT», Const.«PlaneAngleMeasure»])))),
mkForall (fun («?NUMBER» : Obj) => ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?NUMBER», Const.«AngularDegree»]), ap (Const.«MeasureFn») ([ap (Const.«MultiplicationFn») ([«?NUMBER», ap (Const.«DivisionFn») ([Const.«Pi», numLit "180.0"])]), Const.«Radian»])])),
mkForall (fun («?ANGLE» : Obj) => mkForall (fun («?NUMBER» : Obj) => mkImp (ap (Const.«measure») ([«?ANGLE», ap (Const.«MeasureFn») ([«?NUMBER», Const.«AngularDegree»])])) (mkAnd [ap (Const.«greaterThanOrEqualTo») ([«?NUMBER», numLit "0.0"]), ap (Const.«lessThanOrEqualTo») ([«?NUMBER», numLit "360.0"])]))),
ap (Const.«instance») ([Const.«UnitedStatesDollar», Const.«UnitOfCurrency»]),
ap (Const.«instance») ([Const.«UnitedStatesCent», Const.«UnitOfCurrency»]),
mkForall (fun («?NUMBER» : Obj) => ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?NUMBER», Const.«UnitedStatesCent»]), ap (Const.«MeasureFn») ([ap (Const.«MultiplicationFn») ([«?NUMBER», numLit "0.01"]), Const.«UnitedStatesDollar»])])),
ap (Const.«instance») ([Const.«EuroDollar», Const.«UnitOfCurrency»]),
ap (Const.«instance») ([Const.«EuroCent», Const.«UnitOfCurrency»]),
mkForall (fun («?NUMBER» : Obj) => ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?NUMBER», Const.«EuroCent»]), ap (Const.«MeasureFn») ([ap (Const.«MultiplicationFn») ([«?NUMBER», numLit "0.01"]), Const.«EuroDollar»])])),
ap (Const.«subclass») ([Const.«InformationMeasure», Const.«ConstantQuantity»]),
ap (Const.«instance») ([Const.«Bit», Const.«UnitOfInformation»]),
ap (Const.«instance») ([Const.«Byte», Const.«UnitOfInformation»]),
mkForall (fun («?NUMBER» : Obj) => ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?NUMBER», Const.«Byte»]), ap (Const.«MeasureFn») ([ap (Const.«MultiplicationFn») ([«?NUMBER», numLit "8"]), Const.«Bit»])])),
ap (Const.«instance») ([Const.«KiloByte», Const.«UnitOfInformation»]),
mkForall (fun («?NUMBER» : Obj) => ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?NUMBER», Const.«KiloByte»]), ap (Const.«MeasureFn») ([ap (Const.«MultiplicationFn») ([«?NUMBER», numLit "1024"]), Const.«Byte»])])),
ap (Const.«instance») ([Const.«MegaByte», Const.«UnitOfInformation»]),
mkForall (fun («?NUMBER» : Obj) => ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?NUMBER», Const.«MegaByte»]), ap (Const.«MeasureFn») ([ap (Const.«MultiplicationFn») ([«?NUMBER», numLit "1024"]), Const.«KiloByte»])])),
ap (Const.«subclass») ([Const.«SoundPressureLevelUnit», Const.«UnitOfMeasure»]),
ap (Const.«instance») ([Const.«Decibel», Const.«SoundPressureLevelUnit»]),
ap (Const.«instance») ([Const.«DecibelA», Const.«SoundPressureLevelUnit»]),
ap (Const.«instance») ([Const.«measure», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«measure», Const.«AsymmetricRelation»]),
mkForall (fun («?P» : Obj) => mkForall (fun («?Q» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?P», Const.«Process»]), ap (Const.«measure») ([«?P», «?Q»])]) (ap (Const.«instance») ([«?Q», Const.«TimeDependentQuantity»])))),
ap (Const.«instance») ([Const.«age», Const.«SingleValuedRelation»]),
ap (Const.«subrelation») ([Const.«age», Const.«measure»]),
ap (Const.«instance») ([Const.«age», Const.«BinaryPredicate»]),
mkForall (fun («?DURATION» : Obj) => mkForall (fun («?OBJ» : Obj) => mkForall (fun («?TIME» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?TIME», Const.«TimePoint»]), ap (Const.«holdsDuring») ([«?TIME», ap (Const.«age») ([«?OBJ», «?DURATION»])])]) (ap (Const.«duration») ([ap (Const.«TimeIntervalFn») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?OBJ»])]), «?TIME»]), «?DURATION»]))))),
ap (Const.«subrelation») ([Const.«linearExtent», Const.«measure»]),
ap (Const.«instance») ([Const.«linearExtent», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«width», Const.«SingleValuedRelation»]),
ap (Const.«instance») ([Const.«width», Const.«BinaryPredicate»]),
ap (Const.«subrelation») ([Const.«width», Const.«linearExtent»]),
ap (Const.«subrelation») ([Const.«height», Const.«linearExtent»]),
ap (Const.«instance») ([Const.«height», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«length», Const.«SingleValuedRelation»]),
ap (Const.«subrelation») ([Const.«length», Const.«linearExtent»]),
ap (Const.«instance») ([Const.«length», Const.«BinaryPredicate»]),
mkForall (fun («?M» : Obj) => mkForall (fun («?O» : Obj) => mkForall (fun («?U» : Obj) => mkImp (ap (Const.«length») ([«?O», ap (Const.«MeasureFn») ([«?M», «?U»])])) (mkNot (mkExists (fun («?M2» : Obj) => mkAnd [ap (Const.«linearExtent») ([«?O», ap (Const.«MeasureFn») ([«?M2», «?U»])]), ap (Const.«greaterThan») ([«?M2», «?M»])])))))),
ap (Const.«instance») ([Const.«AmountsFn», Const.«TernaryFunction»]),
ap (Const.«instance») ([Const.«amount», Const.«TernaryPredicate»]),
mkForall (fun («?CO» : Obj) => mkForall (fun («?N» : Obj) => mkForall (fun («?N2» : Obj) => mkForall (fun («?S» : Obj) => mkForall (fun («?SI» : Obj) => mkForall (fun («?U» : Obj) => mkImp (mkAnd [ap (Const.«amount») ([«?S», «?CO», ap (Const.«MeasureFn») ([«?N», «?U»])]), ap (Const.«instance») ([«?SI», «?S»]), ap (Const.«measure») ([«?SI», ap (Const.«MeasureFn») ([«?N2», «?U»])]), ap (Const.«part») ([«?SI», «?CO»])]) (mkExists (fun («?L» : Obj) => mkAnd [ap (Const.«inList») ([ap (Const.«MeasureFn») ([«?N2», «?U»]), «?L»]), ap (Const.«equal») ([«?L», ap (Const.«AmountsFn») ([«?S», «?CO», «?U»])]), ap (Const.«equal») ([«?N», ap (Const.«ListSumFn») ([«?L»])])])))))))),
ap (Const.«instance») ([Const.«shape», Const.«BinaryPredicate»]),
ap (Const.«subrelation») ([Const.«shape», Const.«property»]),
mkForall (fun («?OBJ» : Obj) => mkForall (fun («?SHAPE» : Obj) => mkImp (mkAnd [ap (Const.«property») ([«?OBJ», «?SHAPE»]), ap (Const.«instance») ([«?OBJ», Const.«Physical»]), ap (Const.«instance») ([«?SHAPE», Const.«ShapeAttribute»])]) (ap (Const.«shape») ([«?OBJ», «?SHAPE»])))),
ap (Const.«instance») ([Const.«Oval», Const.«ClosedTwoDimensionalFigure»]),
ap (Const.«subAttribute») ([Const.«Circle», Const.«Oval»]),
mkForall (fun («?C» : Obj) => mkImp (ap (Const.«equal») ([«?C», Const.«Circle»])) (mkExists (fun («?R» : Obj) => ap (Const.«radius») ([«?C», «?R»])))),
mkForall (fun («?C» : Obj) => mkImp (ap (Const.«equal») ([«?C», Const.«Circle»])) (mkExists (fun («?P» : Obj) => ap (Const.«equal») ([ap (Const.«CenterOfCircleFn») ([«?C»]), «?P»])))),
ap (Const.«instance») ([Const.«CenterOfCircleFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«CenterOfCircleFn», Const.«TotalValuedRelation»]),
mkForall (fun («?C» : Obj) => mkForall (fun («?P» : Obj) => mkImp (ap (Const.«equal») ([«?P», ap (Const.«CenterOfCircleFn») ([«?C»])])) (ap (Const.«equal») ([«?C», Const.«Circle»])))),
ap (Const.«instance») ([Const.«radius», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«radius», Const.«SingleValuedRelation»]),
ap (Const.«instance») ([Const.«radius», Const.«TotalValuedRelation»]),
mkForall (fun («?CIRCLE» : Obj) => mkForall (fun («?RADIUS» : Obj) => mkImp (ap (Const.«radius») ([«?CIRCLE», «?RADIUS»])) (mkExists (fun («?POINT» : Obj) => mkForall (fun («?PART» : Obj) => mkImp (ap (Const.«pointOfFigure») ([«?PART», «?CIRCLE»])) (ap (Const.«geometricDistance») ([«?PART», «?POINT», «?RADIUS»]))))))),
mkForall (fun («?CIRCLE» : Obj) => mkForall (fun («?RADIUS» : Obj) => mkImp (ap (Const.«radius») ([«?CIRCLE», «?RADIUS»])) (ap (Const.«equal») ([«?CIRCLE», Const.«Circle»])))),
ap (Const.«instance») ([Const.«diameter», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«diameter», Const.«SingleValuedRelation»]),
ap (Const.«instance») ([Const.«diameter», Const.«TotalValuedRelation»]),
mkForall (fun («?CIRCLE» : Obj) => mkForall (fun («?LENGTH» : Obj) => mkImp (ap (Const.«diameter») ([«?CIRCLE», «?LENGTH»])) (mkExists (fun («?NHALF» : Obj) => mkExists (fun («?UHALF» : Obj) => mkAnd [ap (Const.«radius») ([«?CIRCLE», ap (Const.«MeasureFn») ([«?NHALF», «?UHALF»])]), ap (Const.«equal») ([ap (Const.«MeasureFn») ([ap (Const.«MultiplicationFn») ([«?NHALF», numLit "2"]), «?UHALF»]), «?LENGTH»])]))))),
mkForall (fun («?CIRCLE» : Obj) => mkForall (fun («?LENGTH» : Obj) => mkImp (ap (Const.«diameter») ([«?CIRCLE», «?LENGTH»])) (ap (Const.«equal») ([«?CIRCLE», Const.«Circle»])))),
ap (Const.«instance») ([Const.«distance», Const.«SingleValuedRelation»]),
ap (Const.«instance») ([Const.«distance», Const.«SpatialRelation»]),
ap (Const.«instance») ([Const.«distance», Const.«TernaryPredicate»]),
ap (Const.«instance») ([Const.«distance», Const.«TotalValuedRelation»]),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkForall (fun («?QUANT» : Obj) => mkImp (ap (Const.«distance») ([«?OBJ1», «?OBJ2», «?QUANT»])) (ap (Const.«distance») ([«?OBJ2», «?OBJ1», «?QUANT»]))))),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkForall (fun («?Q» : Obj) => mkImp (ap (Const.«altitude») ([«?OBJ1», «?OBJ2», «?Q»])) (ap (Const.«distance») ([«?OBJ1», «?OBJ2», «?Q»]))))),
ap (Const.«instance») ([Const.«altitude», Const.«SingleValuedRelation»]),
ap (Const.«instance») ([Const.«altitude», Const.«TernaryPredicate»]),
ap (Const.«instance») ([Const.«altitude», Const.«PartialValuedRelation»]),
mkForall (fun («?HEIGHT» : Obj) => mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkImp (ap (Const.«altitude») ([«?OBJ1», «?OBJ2», «?HEIGHT»])) (ap (Const.«orientation») ([«?OBJ1», «?OBJ2», Const.«Above»]))))),
mkForall (fun («?HEIGHT» : Obj) => mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkImp (ap (Const.«altitude») ([«?OBJ1», «?OBJ2», «?HEIGHT»])) (mkExists (fun («?TOP» : Obj) => mkAnd [ap (Const.«top») ([«?TOP», «?OBJ1»]), ap (Const.«distance») ([«?TOP», «?OBJ2», «?HEIGHT»])]))))),
ap (Const.«subrelation») ([Const.«depth», Const.«distance»]),
ap (Const.«instance») ([Const.«depth», Const.«SingleValuedRelation»]),
ap (Const.«instance») ([Const.«depth», Const.«TernaryPredicate»]),
mkForall (fun («?DEPTH» : Obj) => mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkImp (ap (Const.«depth») ([«?OBJ1», «?OBJ2», «?DEPTH»])) (ap (Const.«orientation») ([«?OBJ1», «?OBJ2», Const.«Below»]))))),
mkForall (fun («?DEPTH» : Obj) => mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkImp (ap (Const.«depth») ([«?OBJ1», «?OBJ2», «?DEPTH»])) (mkExists (fun («?BOTTOM» : Obj) => mkAnd [ap (Const.«bottom») ([«?BOTTOM», «?OBJ1»]), ap (Const.«distance») ([«?BOTTOM», «?OBJ2», «?DEPTH»])]))))),
ap (Const.«instance») ([Const.«larger», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«larger», Const.«SpatialRelation»]),
ap (Const.«instance») ([Const.«larger», Const.«TransitiveRelation»]),
ap (Const.«instance») ([Const.«larger», Const.«IrreflexiveRelation»]),
ap (Const.«instance») ([Const.«larger», Const.«TotalValuedRelation»]),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkIff (ap (Const.«larger») ([«?OBJ1», «?OBJ2»])) (mkForall (fun («?QUANT1» : Obj) => mkForall (fun («?QUANT2» : Obj) => mkForall (fun («?UNIT» : Obj) => mkImp (mkAnd [ap (Const.«measure») ([«?OBJ1», ap (Const.«MeasureFn») ([«?QUANT1», «?UNIT»])]), ap (Const.«measure») ([«?OBJ2», ap (Const.«MeasureFn») ([«?QUANT2», «?UNIT»])]), ap (Const.«instance») ([«?UNIT», Const.«UnitOfLength»])]) (ap (Const.«greaterThan») ([«?QUANT1», «?QUANT2»])))))))),
ap (Const.«instance») ([Const.«smaller», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«smaller», Const.«SpatialRelation»]),
ap (Const.«instance») ([Const.«smaller», Const.«TotalValuedRelation»]),
ap (Const.«instance») ([Const.«smaller», Const.«TransitiveRelation»]),
ap (Const.«instance») ([Const.«smaller», Const.«IrreflexiveRelation»]),
ap (Const.«inverse») ([Const.«smaller», Const.«larger»]),
ap (Const.«instance») ([Const.«monetaryValue», Const.«SingleValuedRelation»]),
ap (Const.«instance») ([Const.«monetaryValue», Const.«AsymmetricRelation»]),
ap (Const.«instance») ([Const.«monetaryValue», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«WealthFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«WealthFn», Const.«TotalValuedRelation»]),
mkForall (fun («?AMOUNT» : Obj) => mkForall (fun («?PERSON» : Obj) => mkImp (ap (Const.«equal») ([ap (Const.«WealthFn») ([«?PERSON»]), «?AMOUNT»])) (ap (Const.«monetaryValue») ([ap (Const.«PropertyFn») ([«?PERSON»]), «?AMOUNT»])))),
mkForall (fun («?AMOUNT» : Obj) => mkForall (fun («?PERSON» : Obj) => mkImp (ap (Const.«monetaryValue») ([ap (Const.«PropertyFn») ([«?PERSON»]), «?AMOUNT»])) (ap (Const.«equal») ([ap (Const.«WealthFn») ([«?PERSON»]), «?AMOUNT»])))),
ap (Const.«instance») ([Const.«barometricPressure», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«barometricPressure», Const.«AsymmetricRelation»]),
ap (Const.«subrelation») ([Const.«barometricPressure», Const.«measure»]),
ap (Const.«subclass») ([Const.«UnitOfAtmosphericPressure», Const.«CompositeUnitOfMeasure»]),
ap (Const.«instance») ([Const.«InchMercury», Const.«UnitOfAtmosphericPressure»]),
ap (Const.«instance») ([Const.«MmMercury», Const.«UnitOfAtmosphericPressure»]),
ap (Const.«instance») ([Const.«PositiveInfinity», Const.«TimePoint»]),
mkForall (fun («?POINT» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?POINT», Const.«TimePoint»]), mkNot (ap (Const.«equal») ([«?POINT», Const.«PositiveInfinity»]))]) (ap (Const.«before») ([«?POINT», Const.«PositiveInfinity»]))),
mkForall (fun («?POINT» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?POINT», Const.«TimePoint»]), mkNot (ap (Const.«equal») ([«?POINT», Const.«PositiveInfinity»]))]) (mkExists (fun («?OTHERPOINT» : Obj) => ap (Const.«temporallyBetween») ([«?POINT», «?OTHERPOINT», Const.«PositiveInfinity»])))),
ap (Const.«instance») ([Const.«NegativeInfinity», Const.«TimePoint»]),
mkForall (fun («?POINT» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?POINT», Const.«TimePoint»]), mkNot (ap (Const.«equal») ([«?POINT», Const.«NegativeInfinity»]))]) (ap (Const.«before») ([Const.«NegativeInfinity», «?POINT»]))),
mkForall (fun («?POINT» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?POINT», Const.«TimePoint»]), mkNot (ap (Const.«equal») ([«?POINT», Const.«NegativeInfinity»]))]) (mkExists (fun («?OTHERPOINT» : Obj) => ap (Const.«temporallyBetween») ([Const.«NegativeInfinity», «?OTHERPOINT», «?POINT»])))),
ap (Const.«instance») ([Const.«duration», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«duration», Const.«TotalValuedRelation»]),
ap (Const.«instance») ([Const.«frequency», Const.«BinaryPredicate»]),
mkForall (fun («?PROC» : Obj) => mkForall (fun («?TIME1» : Obj) => mkImp (ap (Const.«frequency») ([«?PROC», «?TIME1»])) (mkForall (fun («?TIME2» : Obj) => mkImp (ap (Const.«duration») ([«?TIME2», «?TIME1»])) (mkExists (fun («?POSITION» : Obj) => mkAnd [ap (Const.«temporalPart») ([«?POSITION», «?TIME2»]), ap (Const.«holdsDuring») ([«?POSITION», mkExists (fun («?INST» : Obj) => ap (Const.«instance») ([«?INST», «?PROC»]))])])))))),
ap (Const.«instance») ([Const.«temporalPart», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«temporalPart», Const.«TemporalRelation»]),
ap (Const.«instance») ([Const.«temporalPart», Const.«PartialOrderingRelation»]),
mkForall (fun («?POINT» : Obj) => mkImp (ap (Const.«instance») ([«?POINT», Const.«TimePoint»])) (mkExists (fun («?INTERVAL» : Obj) => mkAnd [ap (Const.«instance») ([«?INTERVAL», Const.«TimeInterval»]), ap (Const.«temporalPart») ([«?POINT», «?INTERVAL»])]))),
mkForall (fun («?INTERVAL» : Obj) => mkImp (ap (Const.«instance») ([«?INTERVAL», Const.«TimeInterval»])) (mkExists (fun («?POINT» : Obj) => mkAnd [ap (Const.«instance») ([«?POINT», Const.«TimePoint»]), ap (Const.«temporalPart») ([«?POINT», «?INTERVAL»])]))),
mkForall (fun («?SITUATION» : Obj) => mkForall (fun («?TIME1» : Obj) => mkForall (fun («?TIME2» : Obj) => mkImp (mkAnd [ap (Const.«holdsDuring») ([«?TIME1», «?SITUATION»]), ap (Const.«temporalPart») ([«?TIME2», «?TIME1»])]) (ap (Const.«holdsDuring») ([«?TIME2», «?SITUATION»]))))),
mkForall (fun («?INST1» : Obj) => mkForall (fun («?INST2» : Obj) => mkForall (fun («?INTERVAL» : Obj) => mkForall (fun («?REL» : Obj) => mkImp (mkAnd [ap (Const.«holdsDuring») ([«?INTERVAL», ap («?REL») ([«?INST1», «?INST2»])]), ap (Const.«instance») ([«?INST1», Const.«Physical»]), ap (Const.«instance») ([«?INST2», Const.«Physical»])]) (mkAnd [ap (Const.«time») ([«?INST1», «?INTERVAL»]), ap (Const.«time») ([«?INST2», «?INTERVAL»])]))))),
mkForall (fun («?POS» : Obj) => mkForall (fun («?THING» : Obj) => mkImp (ap (Const.«temporalPart») ([«?POS», ap (Const.«WhenFn») ([«?THING»])])) (ap (Const.«time») ([«?THING», «?POS»])))),
mkForall (fun («?POS» : Obj) => mkForall (fun («?THING» : Obj) => mkImp (ap (Const.«time») ([«?THING», «?POS»])) (ap (Const.«temporalPart») ([«?POS», ap (Const.«WhenFn») ([«?THING»])])))),
ap (Const.«instance») ([Const.«BeginFn», Const.«TemporalRelation»]),
ap (Const.«instance») ([Const.«BeginFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«BeginFn», Const.«TotalValuedRelation»]),
mkForall (fun («?OBJ» : Obj) => mkForall (fun («?PROCESS» : Obj) => mkImp (ap (Const.«origin») ([«?PROCESS», «?OBJ»])) (ap (Const.«eventLocated») ([ap (Const.«WhereFn») ([«?PROCESS», ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?PROCESS»])])]), ap (Const.«WhereFn») ([«?OBJ», ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?OBJ»])])])])))),
mkForall (fun («?INTERVAL» : Obj) => mkForall (fun («?POINT» : Obj) => mkImp (ap (Const.«equal») ([ap (Const.«BeginFn») ([«?INTERVAL»]), «?POINT»])) (mkForall (fun («?OTHERPOINT» : Obj) => mkImp (mkAnd [ap (Const.«temporalPart») ([«?OTHERPOINT», «?INTERVAL»]), mkNot (ap (Const.«equal») ([«?OTHERPOINT», «?POINT»]))]) (ap (Const.«before») ([«?POINT», «?OTHERPOINT»])))))),
ap (Const.«instance») ([Const.«EndFn», Const.«TemporalRelation»]),
ap (Const.«instance») ([Const.«EndFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«EndFn», Const.«TotalValuedRelation»]),
mkForall (fun («?INTERVAL» : Obj) => mkForall (fun («?POINT» : Obj) => mkImp (ap (Const.«equal») ([ap (Const.«EndFn») ([«?INTERVAL»]), «?POINT»])) (mkForall (fun («?OTHERPOINT» : Obj) => mkImp (mkAnd [ap (Const.«temporalPart») ([«?OTHERPOINT», «?INTERVAL»]), mkNot (ap (Const.«equal») ([«?OTHERPOINT», «?POINT»]))]) (ap (Const.«before») ([«?OTHERPOINT», «?POINT»])))))),
mkForall (fun («?OBJ» : Obj) => mkForall (fun («?PROC» : Obj) => mkForall (fun («?QUANT1» : Obj) => mkForall (fun («?QUANT2» : Obj) => mkImp (mkAnd [ap (Const.«resource») ([«?PROC», «?OBJ»]), ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?PROC»])]), ap (Const.«measure») ([«?OBJ», «?QUANT1»])]), ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?PROC»])]), ap (Const.«measure») ([«?OBJ», «?QUANT2»])])]) (ap (Const.«greaterThan») ([«?QUANT1», «?QUANT2»])))))),
ap (Const.«subrelation») ([Const.«starts», Const.«temporalPart»]),
ap (Const.«instance») ([Const.«starts», Const.«TemporalRelation»]),
ap (Const.«instance») ([Const.«starts», Const.«TransitiveRelation»]),
ap (Const.«instance») ([Const.«starts», Const.«IrreflexiveRelation»]),
ap (Const.«instance») ([Const.«starts», Const.«TotalValuedRelation»]),
mkForall (fun («?INTERVAL1» : Obj) => mkForall (fun («?INTERVAL2» : Obj) => mkImp (ap (Const.«starts») ([«?INTERVAL1», «?INTERVAL2»])) (mkAnd [ap (Const.«equal») ([ap (Const.«BeginFn») ([«?INTERVAL1»]), ap (Const.«BeginFn») ([«?INTERVAL2»])]), ap (Const.«before») ([ap (Const.«EndFn») ([«?INTERVAL1»]), ap (Const.«EndFn») ([«?INTERVAL2»])])]))),
mkForall (fun («?INTERVAL1» : Obj) => mkForall (fun («?INTERVAL2» : Obj) => mkImp (mkAnd [ap (Const.«equal») ([ap (Const.«BeginFn») ([«?INTERVAL1»]), ap (Const.«BeginFn») ([«?INTERVAL2»])]), ap (Const.«before») ([ap (Const.«EndFn») ([«?INTERVAL1»]), ap (Const.«EndFn») ([«?INTERVAL2»])])]) (ap (Const.«starts») ([«?INTERVAL1», «?INTERVAL2»])))),
ap (Const.«subrelation») ([Const.«finishes», Const.«temporalPart»]),
ap (Const.«instance») ([Const.«finishes», Const.«TemporalRelation»]),
ap (Const.«instance») ([Const.«finishes», Const.«TransitiveRelation»]),
ap (Const.«instance») ([Const.«finishes», Const.«IrreflexiveRelation»]),
ap (Const.«instance») ([Const.«finishes», Const.«TotalValuedRelation»]),
mkForall (fun («?INTERVAL1» : Obj) => mkForall (fun («?INTERVAL2» : Obj) => mkImp (ap (Const.«finishes») ([«?INTERVAL1», «?INTERVAL2»])) (mkAnd [ap (Const.«before») ([ap (Const.«BeginFn») ([«?INTERVAL2»]), ap (Const.«BeginFn») ([«?INTERVAL1»])]), ap (Const.«equal») ([ap (Const.«EndFn») ([«?INTERVAL2»]), ap (Const.«EndFn») ([«?INTERVAL1»])])]))),
mkForall (fun («?INTERVAL1» : Obj) => mkForall (fun («?INTERVAL2» : Obj) => mkImp (mkAnd [ap (Const.«before») ([ap (Const.«BeginFn») ([«?INTERVAL2»]), ap (Const.«BeginFn») ([«?INTERVAL1»])]), ap (Const.«equal») ([ap (Const.«EndFn») ([«?INTERVAL2»]), ap (Const.«EndFn») ([«?INTERVAL1»])])]) (ap (Const.«finishes») ([«?INTERVAL1», «?INTERVAL2»])))),
ap (Const.«instance») ([Const.«finishesDuring», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«finishesDuring», Const.«IrreflexiveRelation»]),
ap (Const.«instance») ([Const.«finishesDuring», Const.«TemporalRelation»]),
mkForall (fun («?INTERVAL1» : Obj) => mkForall (fun («?INTERVAL2» : Obj) => mkImp (ap (Const.«finishesDuring») ([«?INTERVAL1», «?INTERVAL2»])) (ap (Const.«temporallyBetween») ([ap (Const.«BeginFn») ([«?INTERVAL2»]), ap (Const.«EndFn») ([«?INTERVAL1»]), ap (Const.«EndFn») ([«?INTERVAL2»])])))),
ap (Const.«instance») ([Const.«startsDuring», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«startsDuring», Const.«IrreflexiveRelation»]),
ap (Const.«instance») ([Const.«startsDuring», Const.«TemporalRelation»]),
mkForall (fun («?INTERVAL1» : Obj) => mkForall (fun («?INTERVAL2» : Obj) => mkImp (ap (Const.«startsDuring») ([«?INTERVAL1», «?INTERVAL2»])) (ap (Const.«temporallyBetween») ([ap (Const.«BeginFn») ([«?INTERVAL2»]), ap (Const.«BeginFn») ([«?INTERVAL1»]), ap (Const.«EndFn») ([«?INTERVAL2»])])))),
ap (Const.«instance») ([Const.«before», Const.«TemporalRelation»]),
ap (Const.«instance») ([Const.«before», Const.«IrreflexiveRelation»]),
ap (Const.«instance») ([Const.«before», Const.«TransitiveRelation»]),
ap (Const.«subrelation») ([Const.«before», Const.«beforeOrEqual»]),
ap (Const.«relatedInternalConcept») ([Const.«before», Const.«earlier»]),
mkForall (fun («?OBJ» : Obj) => mkImp (ap (Const.«instance») ([«?OBJ», Const.«Object»])) (mkExists (fun («?TIME1» : Obj) => mkExists (fun («?TIME2» : Obj) => mkAnd [ap (Const.«instance») ([«?TIME1», Const.«TimePoint»]), ap (Const.«instance») ([«?TIME2», Const.«TimePoint»]), ap (Const.«before») ([«?TIME1», «?TIME2»]), mkForall (fun («?TIME» : Obj) => mkImp (mkAnd [ap (Const.«beforeOrEqual») ([«?TIME1», «?TIME»]), ap (Const.«beforeOrEqual») ([«?TIME», «?TIME2»])]) (ap (Const.«time») ([«?OBJ», «?TIME»])))])))),
mkForall (fun («?OBJ» : Obj) => mkForall (fun («?PROC» : Obj) => mkImp (ap (Const.«result») ([«?PROC», «?OBJ»])) (mkForall (fun («?TIME» : Obj) => mkImp (ap (Const.«before») ([«?TIME», ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?PROC»])])])) (mkNot (ap (Const.«time») ([«?OBJ», «?TIME»]))))))),
mkForall (fun («?INTERVAL» : Obj) => mkImp (ap (Const.«instance») ([«?INTERVAL», Const.«TimeInterval»])) (ap (Const.«before») ([ap (Const.«BeginFn») ([«?INTERVAL»]), ap (Const.«EndFn») ([«?INTERVAL»])]))),
ap (Const.«instance») ([Const.«beforeOrEqual», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«beforeOrEqual», Const.«TemporalRelation»]),
ap (Const.«instance») ([Const.«beforeOrEqual», Const.«PartialOrderingRelation»]),
mkForall (fun («?POINT1» : Obj) => mkForall (fun («?POINT2» : Obj) => mkImp (ap (Const.«beforeOrEqual») ([«?POINT1», «?POINT2»])) (mkOr [ap (Const.«before») ([«?POINT1», «?POINT2»]), ap (Const.«equal») ([«?POINT1», «?POINT2»])]))),
mkForall (fun («?POINT1» : Obj) => mkForall (fun («?POINT2» : Obj) => mkImp (mkOr [ap (Const.«before») ([«?POINT1», «?POINT2»]), ap (Const.«equal») ([«?POINT1», «?POINT2»])]) (ap (Const.«beforeOrEqual») ([«?POINT1», «?POINT2»])))),
ap (Const.«instance») ([Const.«temporallyBetween», Const.«TemporalRelation»]),
ap (Const.«instance») ([Const.«temporallyBetween», Const.«TernaryPredicate»]),
ap (Const.«instance») ([Const.«temporallyBetween», Const.«PartialValuedRelation»]),
ap (Const.«subrelation») ([Const.«temporallyBetween», Const.«temporallyBetweenOrEqual»]),
mkForall (fun («?POINT1» : Obj) => mkForall (fun («?POINT2» : Obj) => mkForall (fun («?POINT3» : Obj) => mkImp (ap (Const.«temporallyBetween») ([«?POINT1», «?POINT2», «?POINT3»])) (mkAnd [ap (Const.«before») ([«?POINT1», «?POINT2»]), ap (Const.«before») ([«?POINT2», «?POINT3»])])))),
mkForall (fun («?POINT1» : Obj) => mkForall (fun («?POINT2» : Obj) => mkForall (fun («?POINT3» : Obj) => mkImp (mkAnd [ap (Const.«before») ([«?POINT1», «?POINT2»]), ap (Const.«before») ([«?POINT2», «?POINT3»])]) (ap (Const.«temporallyBetween») ([«?POINT1», «?POINT2», «?POINT3»]))))),
ap (Const.«instance») ([Const.«temporallyBetweenOrEqual», Const.«TemporalRelation»]),
ap (Const.«instance») ([Const.«temporallyBetweenOrEqual», Const.«TernaryPredicate»]),
ap (Const.«instance») ([Const.«temporallyBetweenOrEqual», Const.«PartialValuedRelation»]),
mkForall (fun («?POINT1» : Obj) => mkForall (fun («?POINT2» : Obj) => mkForall (fun («?POINT3» : Obj) => mkImp (ap (Const.«temporallyBetweenOrEqual») ([«?POINT1», «?POINT2», «?POINT3»])) (mkAnd [ap (Const.«beforeOrEqual») ([«?POINT1», «?POINT2»]), ap (Const.«beforeOrEqual») ([«?POINT2», «?POINT3»])])))),
mkForall (fun («?POINT1» : Obj) => mkForall (fun («?POINT2» : Obj) => mkForall (fun («?POINT3» : Obj) => mkImp (mkAnd [ap (Const.«beforeOrEqual») ([«?POINT1», «?POINT2»]), ap (Const.«beforeOrEqual») ([«?POINT2», «?POINT3»])]) (ap (Const.«temporallyBetweenOrEqual») ([«?POINT1», «?POINT2», «?POINT3»]))))),
mkForall (fun («?PHYS» : Obj) => mkForall (fun («?TIME» : Obj) => mkImp (mkAnd [ap (Const.«time») ([«?PHYS», «?TIME»]), ap (Const.«instance») ([«?TIME», Const.«TimePoint»])]) (ap (Const.«temporallyBetweenOrEqual») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?PHYS»])]), «?TIME», ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?PHYS»])])])))),
mkForall (fun («?PHYS» : Obj) => mkForall (fun («?TIME» : Obj) => mkImp (ap (Const.«temporallyBetweenOrEqual») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?PHYS»])]), «?TIME», ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?PHYS»])])])) (mkAnd [ap (Const.«time») ([«?PHYS», «?TIME»]), ap (Const.«instance») ([«?TIME», Const.«TimePoint»])]))),
ap (Const.«instance») ([Const.«overlapsTemporally», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«overlapsTemporally», Const.«TemporalRelation»]),
ap (Const.«instance») ([Const.«overlapsTemporally», Const.«ReflexiveRelation»]),
ap (Const.«instance») ([Const.«overlapsTemporally», Const.«SymmetricRelation»]),
mkForall (fun («?INTERVAL1» : Obj) => mkForall (fun («?INTERVAL2» : Obj) => mkImp (ap (Const.«overlapsTemporally») ([«?INTERVAL1», «?INTERVAL2»])) (mkExists (fun («?INTERVAL3» : Obj) => mkAnd [ap (Const.«instance») ([«?INTERVAL3», Const.«TimeInterval»]), ap (Const.«temporalPart») ([«?INTERVAL3», «?INTERVAL1»]), ap (Const.«temporalPart») ([«?INTERVAL3», «?INTERVAL2»])])))),
mkForall (fun («?INTERVAL1» : Obj) => mkForall (fun («?INTERVAL2» : Obj) => mkForall (fun («?INTERVAL3» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?INTERVAL3», Const.«TimeInterval»]), ap (Const.«temporalPart») ([«?INTERVAL3», «?INTERVAL1»]), ap (Const.«temporalPart») ([«?INTERVAL3», «?INTERVAL2»])]) (ap (Const.«overlapsTemporally») ([«?INTERVAL1», «?INTERVAL2»]))))),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkForall (fun («?REL» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?REL», Const.«BinaryPredicate»]), ap (Const.«instance») ([«?REL», Const.«SpatialRelation»]), ap (Const.«instance») ([«?OBJ1», Const.«Physical»]), ap (Const.«instance») ([«?OBJ2», Const.«Physical»]), ap («?REL») ([«?OBJ1», «?OBJ2»])]) (ap (Const.«overlapsTemporally») ([ap (Const.«WhenFn») ([«?OBJ1»]), ap (Const.«WhenFn») ([«?OBJ2»])]))))),
mkForall (fun («?BIG» : Obj) => mkForall (fun («?SMALL» : Obj) => mkImp (ap (Const.«during») ([«?SMALL», «?BIG»])) (ap (Const.«temporalPart») ([«?SMALL», «?BIG»])))),
mkForall (fun («?E» : Obj) => mkForall (fun («?S» : Obj) => mkForall (fun («?TI» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?TI», Const.«TimeInterval»]), ap (Const.«equal») ([«?S», ap (Const.«BeginFn») ([«?TI»])]), ap (Const.«equal») ([«?E», ap (Const.«EndFn») ([«?TI»])])]) (ap (Const.«before») ([«?S», «?E»]))))),
mkForall (fun («?TI1» : Obj) => mkForall (fun («?TI2» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?TI1», Const.«TimeInterval»]), ap (Const.«instance») ([«?TI2», Const.«TimeInterval»]), ap (Const.«beforeOrEqual») ([ap (Const.«BeginFn») ([«?TI2»]), ap (Const.«BeginFn») ([«?TI1»])]), ap (Const.«before») ([ap (Const.«BeginFn») ([«?TI1»]), ap (Const.«EndFn») ([«?TI2»])])]) (ap (Const.«overlapsTemporally») ([«?TI2», «?TI1»])))),
mkForall (fun («?P1» : Obj) => mkForall (fun («?P2» : Obj) => mkForall (fun («?TI1» : Obj) => mkForall (fun («?TI2» : Obj) => mkImp (mkAnd [ap (Const.«earlier») ([«?TI1», «?TI2»]), ap (Const.«instance») ([«?P1», Const.«TimePoint»]), ap (Const.«instance») ([«?P2», Const.«TimePoint»]), ap (Const.«temporalPart») ([«?P1», «?TI1»]), ap (Const.«temporalPart») ([«?P2», «?TI2»])]) (ap (Const.«before») ([«?P1», «?P2»])))))),
mkForall (fun («?INTERVAL1» : Obj) => mkForall (fun («?INTERVAL2» : Obj) => mkImp (ap (Const.«overlapsTemporally») ([«?INTERVAL1», «?INTERVAL2»])) (mkExists (fun («?INTERVAL3» : Obj) => mkAnd [ap (Const.«instance») ([«?INTERVAL3», Const.«TimePosition»]), ap (Const.«temporalPart») ([«?INTERVAL3», «?INTERVAL1»]), ap (Const.«temporalPart») ([«?INTERVAL3», «?INTERVAL2»])])))),
mkForall (fun («?INTERVAL1» : Obj) => mkForall (fun («?INTERVAL2» : Obj) => mkForall (fun («?INTERVAL3» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?INTERVAL3», Const.«TimePosition»]), ap (Const.«temporalPart») ([«?INTERVAL3», «?INTERVAL1»]), ap (Const.«temporalPart») ([«?INTERVAL3», «?INTERVAL2»])]) (ap (Const.«overlapsTemporally») ([«?INTERVAL1», «?INTERVAL2»]))))),
ap (Const.«instance») ([Const.«during», Const.«TransitiveRelation»]),
ap (Const.«instance») ([Const.«during», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«during», Const.«IrreflexiveRelation»]),
mkForall (fun («?INTERVAL1» : Obj) => mkForall (fun («?INTERVAL2» : Obj) => mkImp (ap (Const.«during») ([«?INTERVAL1», «?INTERVAL2»])) (mkAnd [ap (Const.«before») ([ap (Const.«EndFn») ([«?INTERVAL1»]), ap (Const.«EndFn») ([«?INTERVAL2»])]), ap (Const.«before») ([ap (Const.«BeginFn») ([«?INTERVAL2»]), ap (Const.«BeginFn») ([«?INTERVAL1»])])]))),
ap (Const.«instance») ([Const.«meetsTemporally», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«meetsTemporally», Const.«TemporalRelation»]),
ap (Const.«instance») ([Const.«meetsTemporally», Const.«AsymmetricRelation»]),
ap (Const.«instance») ([Const.«meetsTemporally», Const.«IntransitiveRelation»]),
ap (Const.«instance») ([Const.«meetsTemporally», Const.«TotalValuedRelation»]),
mkForall (fun («?INTERVAL1» : Obj) => mkForall (fun («?INTERVAL2» : Obj) => mkImp (ap (Const.«meetsTemporally») ([«?INTERVAL1», «?INTERVAL2»])) (ap (Const.«equal») ([ap (Const.«EndFn») ([«?INTERVAL1»]), ap (Const.«BeginFn») ([«?INTERVAL2»])])))),
mkForall (fun («?INTERVAL1» : Obj) => mkForall (fun («?INTERVAL2» : Obj) => mkImp (ap (Const.«equal») ([ap (Const.«EndFn») ([«?INTERVAL1»]), ap (Const.«BeginFn») ([«?INTERVAL2»])])) (ap (Const.«meetsTemporally») ([«?INTERVAL1», «?INTERVAL2»])))),
mkForall (fun («?T1» : Obj) => mkForall (fun («?T2» : Obj) => mkImp (ap (Const.«meetsTemporally») ([«?T1», «?T2»])) (mkNot (mkExists (fun («?T3» : Obj) => mkAnd [ap (Const.«instance») ([«?T3», Const.«TimeInterval»]), ap (Const.«temporalPart») ([«?T3», «?T1»]), ap (Const.«temporalPart») ([«?T3», «?T2»])]))))),
mkForall (fun («?INTERVAL1» : Obj) => mkForall (fun («?INTERVAL2» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?INTERVAL1», Const.«TimeInterval»]), ap (Const.«instance») ([«?INTERVAL2», Const.«TimeInterval»]), ap (Const.«equal») ([ap (Const.«BeginFn») ([«?INTERVAL1»]), ap (Const.«BeginFn») ([«?INTERVAL2»])]), ap (Const.«equal») ([ap (Const.«EndFn») ([«?INTERVAL1»]), ap (Const.«EndFn») ([«?INTERVAL2»])])]) (ap (Const.«equal») ([«?INTERVAL1», «?INTERVAL2»])))),
ap (Const.«instance») ([Const.«earlier», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«earlier», Const.«TemporalRelation»]),
ap (Const.«instance») ([Const.«earlier», Const.«TransitiveRelation»]),
ap (Const.«instance») ([Const.«earlier», Const.«IrreflexiveRelation»]),
ap (Const.«instance») ([Const.«earlier», Const.«TotalValuedRelation»]),
mkForall (fun («?INTERVAL1» : Obj) => mkForall (fun («?INTERVAL2» : Obj) => mkImp (ap (Const.«earlier») ([«?INTERVAL1», «?INTERVAL2»])) (ap (Const.«before») ([ap (Const.«EndFn») ([«?INTERVAL1»]), ap (Const.«BeginFn») ([«?INTERVAL2»])])))),
mkForall (fun («?INTERVAL1» : Obj) => mkForall (fun («?INTERVAL2» : Obj) => mkImp (ap (Const.«before») ([ap (Const.«EndFn») ([«?INTERVAL1»]), ap (Const.«BeginFn») ([«?INTERVAL2»])])) (ap (Const.«earlier») ([«?INTERVAL1», «?INTERVAL2»])))),
ap (Const.«instance») ([Const.«cooccur», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«cooccur», Const.«TemporalRelation»]),
ap (Const.«instance») ([Const.«cooccur», Const.«EquivalenceRelation»]),
mkForall (fun («?PHYS1» : Obj) => mkForall (fun («?PHYS2» : Obj) => mkImp (ap (Const.«cooccur») ([«?PHYS1», «?PHYS2»])) (ap (Const.«equal») ([ap (Const.«WhenFn») ([«?PHYS1»]), ap (Const.«WhenFn») ([«?PHYS2»])])))),
mkForall (fun («?PHYS1» : Obj) => mkForall (fun («?PHYS2» : Obj) => mkImp (ap (Const.«equal») ([ap (Const.«WhenFn») ([«?PHYS1»]), ap (Const.«WhenFn») ([«?PHYS2»])])) (ap (Const.«cooccur») ([«?PHYS1», «?PHYS2»])))),
ap (Const.«instance») ([Const.«TimeIntervalFn», Const.«BinaryFunction»]),
ap (Const.«instance») ([Const.«TimeIntervalFn», Const.«TemporalRelation»]),
ap (Const.«instance») ([Const.«TimeIntervalFn», Const.«PartialValuedRelation»]),
mkForall (fun («?INTERVAL» : Obj) => mkForall (fun («?POINT1» : Obj) => mkForall (fun («?POINT2» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?POINT1», Const.«TimePoint»]), ap (Const.«instance») ([«?POINT2», Const.«TimePoint»]), ap (Const.«instance») ([«?INTERVAL», Const.«TimeInterval»]), ap (Const.«equal») ([ap (Const.«TimeIntervalFn») ([«?POINT1», «?POINT2»]), «?INTERVAL»])]) (mkAnd [ap (Const.«equal») ([ap (Const.«BeginFn») ([«?INTERVAL»]), «?POINT1»]), ap (Const.«equal») ([ap (Const.«EndFn») ([«?INTERVAL»]), «?POINT2»])])))),
mkForall (fun («?INTERVAL» : Obj) => mkForall (fun («?POINT1» : Obj) => mkForall (fun («?POINT2» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?POINT1», Const.«TimePoint»]), ap (Const.«instance») ([«?POINT2», Const.«TimePoint»]), ap (Const.«instance») ([«?INTERVAL», Const.«TimeInterval»]), ap (Const.«equal») ([ap (Const.«TimeIntervalFn») ([«?POINT1», «?POINT2»]), «?INTERVAL»])]) (mkForall (fun («?POINT» : Obj) => mkIff (ap (Const.«temporallyBetweenOrEqual») ([«?POINT1», «?POINT», «?POINT2»])) (ap (Const.«temporalPart») ([«?POINT», «?INTERVAL»]))))))),
ap (Const.«instance») ([Const.«RecurrentTimeIntervalFn», Const.«TemporalRelation»]),
ap (Const.«instance») ([Const.«RecurrentTimeIntervalFn», Const.«BinaryFunction»]),
ap (Const.«instance») ([Const.«RecurrentTimeIntervalFn», Const.«PartialValuedRelation»]),
mkForall (fun («?INTERVAL» : Obj) => mkForall (fun («?TIMECLASS1» : Obj) => mkForall (fun («?TIMECLASS2» : Obj) => mkImp (ap (Const.«instance») ([«?INTERVAL», ap (Const.«RecurrentTimeIntervalFn») ([«?TIMECLASS1», «?TIMECLASS2»])])) (mkExists (fun («?TIME1» : Obj) => mkExists (fun («?TIME2» : Obj) => mkAnd [ap (Const.«instance») ([«?TIME1», «?TIMECLASS1»]), ap (Const.«instance») ([«?TIME2», «?TIMECLASS2»]), ap (Const.«starts») ([«?TIME1», «?INTERVAL»]), ap (Const.«finishes») ([«?TIME2», «?INTERVAL»])])))))),
ap (Const.«instance») ([Const.«WhenFn», Const.«TemporalRelation»]),
ap (Const.«instance») ([Const.«WhenFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«WhenFn», Const.«TotalValuedRelation»]),
ap (Const.«instance») ([Const.«PastFn», Const.«TemporalRelation»]),
ap (Const.«instance») ([Const.«PastFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«PastFn», Const.«TotalValuedRelation»]),
mkForall (fun («?INTERVAL» : Obj) => mkImp (ap (Const.«instance») ([«?INTERVAL», Const.«TimeInterval»])) (ap (Const.«meetsTemporally») ([ap (Const.«PastFn») ([«?INTERVAL»]), «?INTERVAL»]))),
mkForall (fun («?INTERVAL» : Obj) => mkImp (ap (Const.«instance») ([«?INTERVAL», Const.«TimeInterval»])) (ap (Const.«equal») ([ap (Const.«PastFn») ([«?INTERVAL»]), ap (Const.«TimeIntervalFn») ([Const.«NegativeInfinity», ap (Const.«BeginFn») ([«?INTERVAL»])])]))),
ap (Const.«instance») ([Const.«ImmediatePastFn», Const.«TemporalRelation»]),
ap (Const.«instance») ([Const.«ImmediatePastFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«ImmediatePastFn», Const.«TotalValuedRelation»]),
mkForall (fun («?INTERVAL» : Obj) => mkImp (ap (Const.«instance») ([«?INTERVAL», Const.«TimeInterval»])) (ap (Const.«finishes») ([ap (Const.«ImmediatePastFn») ([«?INTERVAL»]), ap (Const.«PastFn») ([«?INTERVAL»])]))),
ap (Const.«instance») ([Const.«FutureFn», Const.«TemporalRelation»]),
ap (Const.«instance») ([Const.«FutureFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«FutureFn», Const.«TotalValuedRelation»]),
mkForall (fun («?INTERVAL» : Obj) => mkImp (ap (Const.«instance») ([«?INTERVAL», Const.«TimeInterval»])) (ap (Const.«meetsTemporally») ([«?INTERVAL», ap (Const.«FutureFn») ([«?INTERVAL»])]))),
mkForall (fun («?INTERVAL» : Obj) => mkImp (ap (Const.«instance») ([«?INTERVAL», Const.«TimeInterval»])) (ap (Const.«equal») ([ap (Const.«FutureFn») ([«?INTERVAL»]), ap (Const.«TimeIntervalFn») ([ap (Const.«EndFn») ([«?INTERVAL»]), Const.«PositiveInfinity»])]))),
ap (Const.«instance») ([Const.«ImmediateFutureFn», Const.«TemporalRelation»]),
ap (Const.«instance») ([Const.«ImmediateFutureFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«ImmediateFutureFn», Const.«TotalValuedRelation»]),
mkForall (fun («?INTERVAL» : Obj) => mkImp (ap (Const.«instance») ([«?INTERVAL», Const.«TimeInterval»])) (ap (Const.«starts») ([ap (Const.«ImmediateFutureFn») ([«?INTERVAL»]), ap (Const.«FutureFn») ([«?INTERVAL»])]))),
ap (Const.«instance») ([Const.«date», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«date», Const.«SingleValuedRelation»]),
ap (Const.«subrelation») ([Const.«date», Const.«time»]),
ap (Const.«instance») ([Const.«YearFn», Const.«TemporalRelation»]),
ap (Const.«instance») ([Const.«YearFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«YearFn», Const.«TotalValuedRelation»]),
ap (Const.«instance») ([Const.«MonthFn», Const.«TemporalRelation»]),
ap (Const.«instance») ([Const.«MonthFn», Const.«BinaryFunction»]),
ap (Const.«instance») ([Const.«MonthFn», Const.«PartialValuedRelation»]),
ap (Const.«instance») ([Const.«DayFn», Const.«TemporalRelation»]),
ap (Const.«instance») ([Const.«DayFn», Const.«BinaryFunction»]),
ap (Const.«instance») ([Const.«DayFn», Const.«PartialValuedRelation»]),
mkForall (fun («?DAY» : Obj) => mkForall (fun («?MONTH» : Obj) => mkForall (fun («?NUMBER» : Obj) => mkImp (ap (Const.«instance») ([«?DAY», ap (Const.«DayFn») ([«?NUMBER», «?MONTH»])])) (ap (Const.«lessThanOrEqualTo») ([«?NUMBER», numLit "31"]))))),
mkForall (fun («?DAY1» : Obj) => mkForall (fun («?DAY2» : Obj) => mkForall (fun («?MONTH» : Obj) => mkForall (fun («?NUMBER1» : Obj) => mkForall (fun («?NUMBER2» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?DAY1», ap (Const.«DayFn») ([«?NUMBER1», «?MONTH»])]), ap (Const.«instance») ([«?DAY2», ap (Const.«DayFn») ([«?NUMBER2», «?MONTH»])]), ap (Const.«equal») ([ap (Const.«SubtractionFn») ([«?NUMBER2», «?NUMBER1»]), numLit "1"])]) (ap (Const.«meetsTemporally») ([«?DAY1», «?DAY2»]))))))),
ap (Const.«instance») ([Const.«HourFn», Const.«TemporalRelation»]),
ap (Const.«instance») ([Const.«HourFn», Const.«BinaryFunction»]),
ap (Const.«instance») ([Const.«HourFn», Const.«PartialValuedRelation»]),
mkForall (fun («?DAY» : Obj) => mkForall (fun («?HOUR» : Obj) => mkForall (fun («?NUMBER» : Obj) => mkImp (ap (Const.«instance») ([«?HOUR», ap (Const.«HourFn») ([«?NUMBER», «?DAY»])])) (ap (Const.«lessThan») ([«?NUMBER», numLit "24"]))))),
mkForall (fun («?DAY» : Obj) => mkForall (fun («?HOUR1» : Obj) => mkForall (fun («?HOUR2» : Obj) => mkForall (fun («?NUMBER1» : Obj) => mkForall (fun («?NUMBER2» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?HOUR1», ap (Const.«HourFn») ([«?NUMBER1», «?DAY»])]), ap (Const.«instance») ([«?HOUR2», ap (Const.«HourFn») ([«?NUMBER2», «?DAY»])]), ap (Const.«equal») ([ap (Const.«SubtractionFn») ([«?NUMBER2», «?NUMBER1»]), numLit "1"])]) (ap (Const.«meetsTemporally») ([«?HOUR1», «?HOUR2»]))))))),
ap (Const.«instance») ([Const.«MinuteFn», Const.«TemporalRelation»]),
ap (Const.«instance») ([Const.«MinuteFn», Const.«BinaryFunction»]),
ap (Const.«instance») ([Const.«MinuteFn», Const.«PartialValuedRelation»]),
mkForall (fun («?HOUR» : Obj) => mkForall (fun («?MINUTE» : Obj) => mkForall (fun («?NUMBER» : Obj) => mkImp (ap (Const.«instance») ([«?MINUTE», ap (Const.«MinuteFn») ([«?NUMBER», «?HOUR»])])) (ap (Const.«lessThan») ([«?NUMBER», numLit "60"]))))),
mkForall (fun («?HOUR» : Obj) => mkForall (fun («?MINUTE1» : Obj) => mkForall (fun («?MINUTE2» : Obj) => mkForall (fun («?NUMBER1» : Obj) => mkForall (fun («?NUMBER2» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?MINUTE1», ap (Const.«MinuteFn») ([«?NUMBER1», «?HOUR»])]), ap (Const.«instance») ([«?MINUTE2», ap (Const.«MinuteFn») ([«?NUMBER2», «?HOUR»])]), ap (Const.«equal») ([ap (Const.«SubtractionFn») ([«?NUMBER2», «?NUMBER1»]), numLit "1"])]) (ap (Const.«meetsTemporally») ([«?MINUTE1», «?MINUTE2»]))))))),
ap (Const.«instance») ([Const.«SecondFn», Const.«TemporalRelation»]),
ap (Const.«instance») ([Const.«SecondFn», Const.«BinaryFunction»]),
ap (Const.«instance») ([Const.«SecondFn», Const.«PartialValuedRelation»]),
mkForall (fun («?MINUTE» : Obj) => mkForall (fun («?NUMBER» : Obj) => mkForall (fun («?SECOND» : Obj) => mkImp (ap (Const.«instance») ([«?SECOND», ap (Const.«SecondFn») ([«?NUMBER», «?MINUTE»])])) (ap (Const.«lessThan») ([«?NUMBER», numLit "60"]))))),
mkForall (fun («?MINUTE» : Obj) => mkForall (fun («?NUMBER1» : Obj) => mkForall (fun («?NUMBER2» : Obj) => mkForall (fun («?SECOND1» : Obj) => mkForall (fun («?SECOND2» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?SECOND1», ap (Const.«SecondFn») ([«?NUMBER1», «?MINUTE»])]), ap (Const.«instance») ([«?SECOND2», ap (Const.«SecondFn») ([«?NUMBER2», «?MINUTE»])]), ap (Const.«equal») ([ap (Const.«SubtractionFn») ([«?NUMBER2», «?NUMBER1»]), numLit "1"])]) (ap (Const.«meetsTemporally») ([«?SECOND1», «?SECOND2»]))))))),
mkForall (fun («?N1» : Obj) => mkForall (fun («?N2» : Obj) => mkForall (fun («?T1» : Obj) => mkForall (fun («?T2» : Obj) => mkForall (fun («?Y1» : Obj) => mkForall (fun («?Y2» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?Y1», ap (Const.«YearFn») ([«?N1»])]), ap (Const.«instance») ([«?Y2», ap (Const.«YearFn») ([«?N2»])]), ap (Const.«equal») ([«?T1», ap (Const.«BeginFn») ([«?Y1»])]), ap (Const.«equal») ([«?T2», ap (Const.«BeginFn») ([«?Y2»])]), ap (Const.«greaterThan») ([«?N2», «?N1»])]) (ap (Const.«before») ([«?T1», «?T2»])))))))),
mkForall (fun («?N1» : Obj) => mkForall (fun («?N2» : Obj) => mkForall (fun («?Y1» : Obj) => mkForall (fun («?Y2» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?Y1», ap (Const.«YearFn») ([«?N1»])]), ap (Const.«instance») ([«?Y2», ap (Const.«YearFn») ([«?N2»])]), ap (Const.«greaterThan») ([«?N2», «?N1»])]) (ap (Const.«earlier») ([«?Y1», «?Y2»])))))),
mkForall (fun («?M1» : Obj) => mkForall (fun («?M2» : Obj) => mkForall (fun («?N1» : Obj) => mkForall (fun («?N2» : Obj) => mkForall (fun («?T1» : Obj) => mkForall (fun («?T2» : Obj) => mkForall (fun («?Y» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?M1», ap (Const.«MonthFn») ([«?N1», ap (Const.«YearFn») ([«?Y»])])]), ap (Const.«instance») ([«?M2», ap (Const.«MonthFn») ([«?N2», ap (Const.«YearFn») ([«?Y»])])]), ap (Const.«equal») ([«?T1», ap (Const.«BeginFn») ([«?M1»])]), ap (Const.«equal») ([«?T2», ap (Const.«BeginFn») ([«?M2»])]), ap (Const.«successorClass») ([«?N1», «?N2»])]) (ap (Const.«before») ([«?T1», «?T2»]))))))))),
mkForall (fun («?M1» : Obj) => mkForall (fun («?M2» : Obj) => mkForall (fun («?N1» : Obj) => mkForall (fun («?N2» : Obj) => mkForall (fun («?Y» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?M1», ap (Const.«MonthFn») ([«?N1», ap (Const.«YearFn») ([«?Y»])])]), ap (Const.«instance») ([«?M2», ap (Const.«MonthFn») ([«?N2», ap (Const.«YearFn») ([«?Y»])])]), ap (Const.«successorClass») ([«?N1», «?N2»])]) (ap (Const.«earlier») ([«?M1», «?M2»]))))))),
mkForall (fun («?D1» : Obj) => mkForall (fun («?D2» : Obj) => mkForall (fun («?M» : Obj) => mkForall (fun («?N1» : Obj) => mkForall (fun («?N2» : Obj) => mkForall (fun («?T1» : Obj) => mkForall (fun («?T2» : Obj) => mkForall (fun («?Y» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?D1», ap (Const.«DayFn») ([«?N1», ap (Const.«MonthFn») ([«?M», ap (Const.«YearFn») ([«?Y»])])])]), ap (Const.«instance») ([«?D2», ap (Const.«DayFn») ([«?N2», ap (Const.«MonthFn») ([«?M», ap (Const.«YearFn») ([«?Y»])])])]), ap (Const.«equal») ([«?T1», ap (Const.«BeginFn») ([«?D1»])]), ap (Const.«equal») ([«?T2», ap (Const.«BeginFn») ([«?D2»])]), ap (Const.«greaterThan») ([«?N2», «?N1»])]) (ap (Const.«before») ([«?T1», «?T2»])))))))))),
mkForall (fun («?D1» : Obj) => mkForall (fun («?D2» : Obj) => mkForall (fun («?M» : Obj) => mkForall (fun («?N1» : Obj) => mkForall (fun («?N2» : Obj) => mkForall (fun («?Y» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?D1», ap (Const.«DayFn») ([«?N1», ap (Const.«MonthFn») ([«?M», ap (Const.«YearFn») ([«?Y»])])])]), ap (Const.«instance») ([«?D2», ap (Const.«DayFn») ([«?N2», ap (Const.«MonthFn») ([«?M», ap (Const.«YearFn») ([«?Y»])])])]), ap (Const.«greaterThan») ([«?N2», «?N1»])]) (ap (Const.«earlier») ([«?D1», «?D2»])))))))),
ap (Const.«subclass») ([Const.«Year», Const.«TimeInterval»]),
ap (Const.«relatedInternalConcept») ([Const.«Year», Const.«YearFn»]),
ap (Const.«relatedInternalConcept») ([Const.«Year», Const.«YearDuration»]),
mkForall (fun («?YEAR» : Obj) => mkImp (ap (Const.«instance») ([«?YEAR», Const.«Year»])) (ap (Const.«duration») ([«?YEAR», ap (Const.«MeasureFn») ([numLit "1", Const.«YearDuration»])]))),
mkForall (fun («?N1» : Obj) => mkForall (fun («?N2» : Obj) => mkForall (fun («?Y1» : Obj) => mkForall (fun («?Y2» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?Y1», ap (Const.«YearFn») ([«?N1»])]), ap (Const.«instance») ([«?Y2», ap (Const.«YearFn») ([«?N2»])]), ap (Const.«equal») ([ap (Const.«SubtractionFn») ([«?N2», «?N1»]), numLit "1"])]) (ap (Const.«meetsTemporally») ([«?Y1», «?Y2»])))))),
ap (Const.«instance») ([Const.«DecadeDuration», Const.«UnitOfDuration»]),
ap (Const.«instance») ([Const.«DecadeDuration», Const.«TimeDuration»]),
mkForall (fun («?NUMBER» : Obj) => mkImp (ap (Const.«equal») ([«?NUMBER», ap (Const.«MultiplicationFn») ([numLit "1", «?NUMBER»])])) (ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?NUMBER», Const.«DecadeDuration»]), ap (Const.«MeasureFn») ([ap (Const.«MultiplicationFn») ([«?NUMBER», numLit "10"]), Const.«YearDuration»])]))),
ap (Const.«subclass») ([Const.«Decade», Const.«TimeInterval»]),
ap (Const.«relatedInternalConcept») ([Const.«Decade», Const.«DecadeDuration»]),
mkForall (fun («?D» : Obj) => mkImp (ap (Const.«instance») ([«?D», Const.«Decade»])) (ap (Const.«duration») ([«?D», ap (Const.«MeasureFn») ([numLit "1", Const.«DecadeDuration»])]))),
mkForall (fun («?D» : Obj) => mkImp (ap (Const.«instance») ([«?D», Const.«Decade»])) (ap (Const.«duration») ([«?D», ap (Const.«MeasureFn») ([numLit "10", Const.«YearDuration»])]))),
ap (Const.«subclass») ([Const.«Midnight», Const.«TimePoint»]),
mkForall (fun («?M» : Obj) => mkImp (ap (Const.«instance») ([«?M», Const.«Midnight»])) (mkExists (fun («?D» : Obj) => mkAnd [ap (Const.«instance») ([«?D», Const.«Day»]), ap (Const.«equal») ([«?M», ap (Const.«EndFn») ([«?D»])])]))),
ap (Const.«subclass») ([Const.«Afternoon», Const.«DayTime»]),
ap (Const.«disjoint») ([Const.«Morning», Const.«Afternoon»]),
ap (Const.«disjoint») ([Const.«Afternoon», Const.«Evening»]),
ap (Const.«disjoint») ([Const.«Morning», Const.«Evening»]),
mkForall (fun («?AFTERNOON» : Obj) => mkImp (ap (Const.«instance») ([«?AFTERNOON», Const.«Afternoon»])) (mkExists (fun («?HOUR» : Obj) => mkExists (fun («?DAY» : Obj) => mkAnd [ap (Const.«instance») ([«?HOUR», ap (Const.«HourFn») ([numLit "12", «?DAY»])]), ap (Const.«starts») ([«?HOUR», «?AFTERNOON»])])))),
ap (Const.«subclass») ([Const.«Morning», Const.«DayTime»]),
mkForall (fun («?MORNING» : Obj) => mkImp (ap (Const.«instance») ([«?MORNING», Const.«Morning»])) (mkExists (fun («?HOUR» : Obj) => mkExists (fun («?DAY» : Obj) => mkAnd [ap (Const.«instance») ([«?HOUR», ap (Const.«HourFn») ([numLit "12", «?DAY»])]), ap (Const.«finishes») ([«?HOUR», «?MORNING»])])))),
ap (Const.«instance») ([Const.«MorningFn», Const.«TemporalRelation»]),
ap (Const.«instance») ([Const.«MorningFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«MorningFn», Const.«PartialValuedRelation»]),
mkForall (fun («?D» : Obj) => mkForall (fun («?E» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?E», Const.«Morning»]), ap (Const.«instance») ([«?D», Const.«Day»]), ap (Const.«equal») ([«?E», ap (Const.«MorningFn») ([«?D»])])]) (ap (Const.«during») ([«?E», «?D»])))),
ap (Const.«instance») ([Const.«AfternoonFn», Const.«TemporalRelation»]),
ap (Const.«instance») ([Const.«AfternoonFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«AfternoonFn», Const.«PartialValuedRelation»]),
mkForall (fun («?D» : Obj) => mkForall (fun («?E» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?E», Const.«Afternoon»]), ap (Const.«instance») ([«?D», Const.«Day»]), ap (Const.«equal») ([«?E», ap (Const.«AfternoonFn») ([«?D»])])]) (ap (Const.«during») ([«?E», «?D»])))),
mkForall (fun («?A» : Obj) => mkImp (ap (Const.«instance») ([«?A», Const.«Afternoon»])) (mkExists (fun («?N» : Obj) => mkAnd [ap (Const.«instance») ([«?N», Const.«Noon»]), ap (Const.«equal») ([ap (Const.«BeginFn») ([«?A»]), «?N»])]))),
ap (Const.«subclass») ([Const.«Noon», Const.«TimePoint»]),
ap (Const.«subclass») ([Const.«DayTime», Const.«TimeInterval»]),
ap (Const.«disjoint») ([Const.«DayTime», Const.«NightTime»]),
ap (Const.«subclass») ([Const.«Sunrise», Const.«TimeInterval»]),
ap (Const.«subclass») ([Const.«Sunset», Const.«TimeInterval»]),
mkForall (fun («?DAY» : Obj) => mkImp (ap (Const.«instance») ([«?DAY», Const.«DayTime»])) (mkExists (fun («?NIGHT1» : Obj) => mkExists (fun («?NIGHT2» : Obj) => mkAnd [ap (Const.«instance») ([«?NIGHT1», Const.«NightTime»]), ap (Const.«instance») ([«?NIGHT2», Const.«NightTime»]), ap (Const.«meetsTemporally») ([«?DAY», «?NIGHT1»]), ap (Const.«meetsTemporally») ([«?NIGHT2», «?DAY»])])))),
mkForall (fun («?DAY» : Obj) => mkImp (ap (Const.«instance») ([«?DAY», Const.«DayTime»])) (mkExists (fun («?RISE» : Obj) => mkExists (fun («?SET» : Obj) => mkAnd [ap (Const.«instance») ([«?RISE», Const.«Sunrise»]), ap (Const.«instance») ([«?SET», Const.«Sunset»]), ap (Const.«starts») ([«?RISE», «?DAY»]), ap (Const.«finishes») ([«?SET», «?DAY»])])))),
ap (Const.«subclass») ([Const.«NightTime», Const.«TimeInterval»]),
mkForall (fun («?NIGHT» : Obj) => mkImp (ap (Const.«instance») ([«?NIGHT», Const.«NightTime»])) (mkExists (fun («?DAY1» : Obj) => mkExists (fun («?DAY2» : Obj) => mkAnd [ap (Const.«instance») ([«?DAY1», Const.«DayTime»]), ap (Const.«instance») ([«?DAY2», Const.«DayTime»]), ap (Const.«meetsTemporally») ([«?NIGHT», «?DAY1»]), ap (Const.«meetsTemporally») ([«?DAY2», «?NIGHT»])])))),
mkForall (fun («?NIGHT» : Obj) => mkImp (ap (Const.«instance») ([«?NIGHT», Const.«NightTime»])) (mkExists (fun («?RISE» : Obj) => mkExists (fun («?SET» : Obj) => mkAnd [ap (Const.«instance») ([«?RISE», Const.«Sunrise»]), ap (Const.«instance») ([«?SET», Const.«Sunset»]), ap (Const.«starts») ([«?SET», «?NIGHT»]), ap (Const.«finishes») ([«?RISE», «?NIGHT»])])))),
ap (Const.«subclass») ([Const.«Evening», Const.«NightTime»]),
mkForall (fun («?EVE» : Obj) => mkImp (ap (Const.«instance») ([«?EVE», Const.«Evening»])) (mkExists (fun («?MID» : Obj) => mkAnd [ap (Const.«instance») ([«?MID», Const.«Midnight»]), ap (Const.«equal») ([ap (Const.«EndFn») ([«?EVE»]), «?MID»])]))),
mkForall (fun («?AFT» : Obj) => mkForall (fun («?D» : Obj) => mkForall (fun («?EVE» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?EVE», Const.«Evening»]), ap (Const.«instance») ([«?AFT», Const.«Afternoon»]), ap (Const.«instance») ([«?D», Const.«Day»]), ap (Const.«during») ([«?EVE», «?D»]), ap (Const.«during») ([«?AFT», «?D»])]) (ap (Const.«meetsTemporally») ([«?AFT», «?EVE»]))))),
ap (Const.«instance») ([Const.«EveningFn», Const.«TemporalRelation»]),
ap (Const.«instance») ([Const.«EveningFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«EveningFn», Const.«PartialValuedRelation»]),
mkForall (fun («?D» : Obj) => mkForall (fun («?E» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?E», Const.«Evening»]), ap (Const.«instance») ([«?D», Const.«Day»]), ap (Const.«equal») ([«?E», ap (Const.«EveningFn») ([«?D»])])]) (ap (Const.«during») ([«?E», «?D»])))),
ap (Const.«instance») ([Const.«WeekFn», Const.«TemporalRelation»]),
ap (Const.«instance») ([Const.«WeekFn», Const.«BinaryFunction»]),
ap (Const.«instance») ([Const.«WeekFn», Const.«PartialValuedRelation»]),
mkForall (fun («?N» : Obj) => mkForall (fun («?W» : Obj) => mkForall (fun («?Y» : Obj) => mkForall (fun («?YI» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?W», ap (Const.«WeekFn») ([«?N», «?Y»])]), ap (Const.«instance») ([«?YI», «?Y»])]) (ap (Const.«during») ([«?W», «?YI»])))))),
ap (Const.«instance») ([Const.«QuarterFn», Const.«TemporalRelation»]),
ap (Const.«instance») ([Const.«QuarterFn», Const.«BinaryFunction»]),
ap (Const.«instance») ([Const.«QuarterFn», Const.«PartialValuedRelation»]),
mkForall (fun («?N» : Obj) => mkForall (fun («?Q» : Obj) => mkForall (fun («?Y» : Obj) => mkForall (fun («?YI» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?Q», Const.«QuarterYear»]), ap (Const.«instance») ([«?Q», ap (Const.«QuarterFn») ([«?N», ap (Const.«YearFn») ([«?Y»])])]), ap (Const.«instance») ([«?YI», ap (Const.«YearFn») ([«?Y»])])]) (ap (Const.«during») ([«?Q», «?YI»])))))),
ap (Const.«subclass») ([Const.«QuarterYear», Const.«TimeInterval»]),
mkForall (fun («?Q» : Obj) => mkImp (ap (Const.«instance») ([«?Q», Const.«QuarterYear»])) (ap (Const.«duration») ([«?Q», ap (Const.«MeasureFn») ([numLit "3", Const.«MonthDuration»])]))),
ap (Const.«subclass») ([Const.«LeapYear», Const.«Year»]),
mkForall (fun («?LEAP» : Obj) => mkForall (fun («?NUMBER» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?LEAP», Const.«LeapYear»]), ap (Const.«instance») ([«?LEAP», ap (Const.«YearFn») ([«?NUMBER»])])]) (mkOr [mkAnd [ap (Const.«equal») ([ap (Const.«RemainderFn») ([«?NUMBER», numLit "4"]), numLit "0"]), mkNot (ap (Const.«equal») ([ap (Const.«RemainderFn») ([«?NUMBER», numLit "100"]), numLit "0"]))], ap (Const.«equal») ([ap (Const.«RemainderFn») ([«?NUMBER», numLit "400"]), numLit "0"])]))),
ap (Const.«instance») ([Const.«successorClass», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«successorClass», Const.«TransitiveRelation»]),
ap (Const.«relatedInternalConcept») ([Const.«successorClass», Const.«successorAttribute»]),
ap (Const.«successorClass») ([Const.«January», Const.«February»]),
ap (Const.«successorClass») ([Const.«February», Const.«March»]),
ap (Const.«successorClass») ([Const.«March», Const.«April»]),
ap (Const.«successorClass») ([Const.«April», Const.«May»]),
ap (Const.«successorClass») ([Const.«May», Const.«June»]),
ap (Const.«successorClass») ([Const.«June», Const.«July»]),
ap (Const.«successorClass») ([Const.«July», Const.«August»]),
ap (Const.«successorClass») ([Const.«August», Const.«September»]),
ap (Const.«successorClass») ([Const.«September», Const.«October»]),
ap (Const.«successorClass») ([Const.«October», Const.«November»]),
ap (Const.«successorClass») ([Const.«November», Const.«December»]),
ap (Const.«successorClass») ([Const.«Sunday», Const.«Monday»]),
ap (Const.«successorClass») ([Const.«Monday», Const.«Tuesday»]),
ap (Const.«successorClass») ([Const.«Tuesday», Const.«Wednesday»]),
ap (Const.«successorClass») ([Const.«Wednesday», Const.«Thursday»]),
ap (Const.«successorClass») ([Const.«Thursday», Const.«Friday»]),
ap (Const.«successorClass») ([Const.«Friday», Const.«Saturday»]),
ap (Const.«subclass») ([Const.«Month», Const.«TimeInterval»]),
ap (Const.«relatedInternalConcept») ([Const.«Month», Const.«MonthFn»]),
ap (Const.«subclass») ([Const.«January», Const.«Month»]),
mkForall (fun («?MONTH» : Obj) => mkImp (ap (Const.«instance») ([«?MONTH», Const.«January»])) (ap (Const.«duration») ([«?MONTH», ap (Const.«MeasureFn») ([numLit "31", Const.«DayDuration»])]))),
mkForall (fun («?MONTH1» : Obj) => mkForall (fun («?MONTH2» : Obj) => mkForall (fun («?YEAR» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?MONTH1», ap (Const.«MonthFn») ([Const.«January», «?YEAR»])]), ap (Const.«instance») ([«?MONTH2», ap (Const.«MonthFn») ([Const.«February», «?YEAR»])])]) (ap (Const.«meetsTemporally») ([«?MONTH1», «?MONTH2»]))))),
ap (Const.«subclass») ([Const.«February», Const.«Month»]),
mkForall (fun («?MONTH» : Obj) => mkForall (fun («?Y» : Obj) => mkForall (fun («?YEAR» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?MONTH», ap (Const.«MonthFn») ([Const.«February», «?YEAR»])]), ap (Const.«instance») ([«?Y», «?YEAR»]), mkNot (ap (Const.«instance») ([«?Y», Const.«LeapYear»]))]) (ap (Const.«duration») ([«?MONTH», ap (Const.«MeasureFn») ([numLit "28", Const.«DayDuration»])]))))),
mkForall (fun («?MONTH» : Obj) => mkForall (fun («?Y» : Obj) => mkForall (fun («?YEAR» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?MONTH», ap (Const.«MonthFn») ([Const.«February», «?YEAR»])]), ap (Const.«instance») ([«?Y», «?YEAR»]), ap (Const.«instance») ([«?Y», Const.«LeapYear»])]) (ap (Const.«duration») ([«?MONTH», ap (Const.«MeasureFn») ([numLit "29", Const.«DayDuration»])]))))),
mkForall (fun («?MONTH1» : Obj) => mkForall (fun («?MONTH2» : Obj) => mkForall (fun («?YEAR» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?MONTH1», ap (Const.«MonthFn») ([Const.«February», «?YEAR»])]), ap (Const.«instance») ([«?MONTH2», ap (Const.«MonthFn») ([Const.«March», «?YEAR»])])]) (ap (Const.«meetsTemporally») ([«?MONTH1», «?MONTH2»]))))),
ap (Const.«subclass») ([Const.«March», Const.«Month»]),
mkForall (fun («?MONTH» : Obj) => mkImp (ap (Const.«instance») ([«?MONTH», Const.«March»])) (ap (Const.«duration») ([«?MONTH», ap (Const.«MeasureFn») ([numLit "31", Const.«DayDuration»])]))),
mkForall (fun («?MONTH1» : Obj) => mkForall (fun («?MONTH2» : Obj) => mkForall (fun («?YEAR» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?MONTH1», ap (Const.«MonthFn») ([Const.«March», «?YEAR»])]), ap (Const.«instance») ([«?MONTH2», ap (Const.«MonthFn») ([Const.«April», «?YEAR»])])]) (ap (Const.«meetsTemporally») ([«?MONTH1», «?MONTH2»]))))),
ap (Const.«subclass») ([Const.«April», Const.«Month»]),
mkForall (fun («?MONTH» : Obj) => mkImp (ap (Const.«instance») ([«?MONTH», Const.«April»])) (ap (Const.«duration») ([«?MONTH», ap (Const.«MeasureFn») ([numLit "30", Const.«DayDuration»])]))),
mkForall (fun («?MONTH1» : Obj) => mkForall (fun («?MONTH2» : Obj) => mkForall (fun («?YEAR» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?MONTH1», ap (Const.«MonthFn») ([Const.«April», «?YEAR»])]), ap (Const.«instance») ([«?MONTH2», ap (Const.«MonthFn») ([Const.«May», «?YEAR»])])]) (ap (Const.«meetsTemporally») ([«?MONTH1», «?MONTH2»]))))),
ap (Const.«subclass») ([Const.«May», Const.«Month»]),
mkForall (fun («?MONTH» : Obj) => mkImp (ap (Const.«instance») ([«?MONTH», Const.«May»])) (ap (Const.«duration») ([«?MONTH», ap (Const.«MeasureFn») ([numLit "31", Const.«DayDuration»])]))),
mkForall (fun («?MONTH1» : Obj) => mkForall (fun («?MONTH2» : Obj) => mkForall (fun («?YEAR» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?MONTH1», ap (Const.«MonthFn») ([Const.«May», «?YEAR»])]), ap (Const.«instance») ([«?MONTH2», ap (Const.«MonthFn») ([Const.«June», «?YEAR»])])]) (ap (Const.«meetsTemporally») ([«?MONTH1», «?MONTH2»]))))),
ap (Const.«subclass») ([Const.«June», Const.«Month»]),
mkForall (fun («?MONTH» : Obj) => mkImp (ap (Const.«instance») ([«?MONTH», Const.«June»])) (ap (Const.«duration») ([«?MONTH», ap (Const.«MeasureFn») ([numLit "30", Const.«DayDuration»])]))),
mkForall (fun («?MONTH1» : Obj) => mkForall (fun («?MONTH2» : Obj) => mkForall (fun («?YEAR» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?MONTH1», ap (Const.«MonthFn») ([Const.«June», «?YEAR»])]), ap (Const.«instance») ([«?MONTH2», ap (Const.«MonthFn») ([Const.«July», «?YEAR»])])]) (ap (Const.«meetsTemporally») ([«?MONTH1», «?MONTH2»]))))),
ap (Const.«subclass») ([Const.«July», Const.«Month»]),
mkForall (fun («?MONTH» : Obj) => mkImp (ap (Const.«instance») ([«?MONTH», Const.«July»])) (ap (Const.«duration») ([«?MONTH», ap (Const.«MeasureFn») ([numLit "31", Const.«DayDuration»])]))),
mkForall (fun («?MONTH1» : Obj) => mkForall (fun («?MONTH2» : Obj) => mkForall (fun («?YEAR» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?MONTH1», ap (Const.«MonthFn») ([Const.«July», «?YEAR»])]), ap (Const.«instance») ([«?MONTH2», ap (Const.«MonthFn») ([Const.«August», «?YEAR»])])]) (ap (Const.«meetsTemporally») ([«?MONTH1», «?MONTH2»]))))),
ap (Const.«subclass») ([Const.«August», Const.«Month»]),
mkForall (fun («?MONTH» : Obj) => mkImp (ap (Const.«instance») ([«?MONTH», Const.«August»])) (ap (Const.«duration») ([«?MONTH», ap (Const.«MeasureFn») ([numLit "31", Const.«DayDuration»])]))),
mkForall (fun («?MONTH1» : Obj) => mkForall (fun («?MONTH2» : Obj) => mkForall (fun («?YEAR» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?MONTH1», ap (Const.«MonthFn») ([Const.«August», «?YEAR»])]), ap (Const.«instance») ([«?MONTH2», ap (Const.«MonthFn») ([Const.«September», «?YEAR»])])]) (ap (Const.«meetsTemporally») ([«?MONTH1», «?MONTH2»]))))),
ap (Const.«subclass») ([Const.«September», Const.«Month»]),
mkForall (fun («?MONTH» : Obj) => mkImp (ap (Const.«instance») ([«?MONTH», Const.«September»])) (ap (Const.«duration») ([«?MONTH», ap (Const.«MeasureFn») ([numLit "30", Const.«DayDuration»])]))),
mkForall (fun («?MONTH1» : Obj) => mkForall (fun («?MONTH2» : Obj) => mkForall (fun («?YEAR» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?MONTH1», ap (Const.«MonthFn») ([Const.«September», «?YEAR»])]), ap (Const.«instance») ([«?MONTH2», ap (Const.«MonthFn») ([Const.«October», «?YEAR»])])]) (ap (Const.«meetsTemporally») ([«?MONTH1», «?MONTH2»]))))),
ap (Const.«subclass») ([Const.«October», Const.«Month»]),
mkForall (fun («?MONTH» : Obj) => mkImp (ap (Const.«instance») ([«?MONTH», Const.«October»])) (ap (Const.«duration») ([«?MONTH», ap (Const.«MeasureFn») ([numLit "31", Const.«DayDuration»])]))),
mkForall (fun («?MONTH1» : Obj) => mkForall (fun («?MONTH2» : Obj) => mkForall (fun («?YEAR» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?MONTH1», ap (Const.«MonthFn») ([Const.«October», «?YEAR»])]), ap (Const.«instance») ([«?MONTH2», ap (Const.«MonthFn») ([Const.«November», «?YEAR»])])]) (ap (Const.«meetsTemporally») ([«?MONTH1», «?MONTH2»]))))),
ap (Const.«subclass») ([Const.«November», Const.«Month»]),
mkForall (fun («?MONTH» : Obj) => mkImp (ap (Const.«instance») ([«?MONTH», Const.«November»])) (ap (Const.«duration») ([«?MONTH», ap (Const.«MeasureFn») ([numLit "30", Const.«DayDuration»])]))),
mkForall (fun («?MONTH1» : Obj) => mkForall (fun («?MONTH2» : Obj) => mkForall (fun («?YEAR» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?MONTH1», ap (Const.«MonthFn») ([Const.«November», «?YEAR»])]), ap (Const.«instance») ([«?MONTH2», ap (Const.«MonthFn») ([Const.«December», «?YEAR»])])]) (ap (Const.«meetsTemporally») ([«?MONTH1», «?MONTH2»]))))),
ap (Const.«subclass») ([Const.«December», Const.«Month»]),
mkForall (fun («?MONTH» : Obj) => mkImp (ap (Const.«instance») ([«?MONTH», Const.«December»])) (ap (Const.«duration») ([«?MONTH», ap (Const.«MeasureFn») ([numLit "31", Const.«DayDuration»])]))),
mkForall (fun («?MONTH1» : Obj) => mkForall (fun («?MONTH2» : Obj) => mkForall (fun («?Y1» : Obj) => mkForall (fun («?Y2» : Obj) => mkForall (fun («?YEAR1» : Obj) => mkForall (fun («?YEAR2» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?MONTH1», ap (Const.«MonthFn») ([Const.«December», «?YEAR1»])]), ap (Const.«instance») ([«?MONTH2», ap (Const.«MonthFn») ([Const.«January», «?YEAR2»])]), ap (Const.«instance») ([«?Y1», «?YEAR1»]), ap (Const.«instance») ([«?Y2», «?YEAR2»]), ap (Const.«meetsTemporally») ([«?Y1», «?Y2»])]) (ap (Const.«meetsTemporally») ([«?MONTH1», «?MONTH2»])))))))),
ap (Const.«subclass») ([Const.«Day», Const.«TimeInterval»]),
ap (Const.«relatedInternalConcept») ([Const.«Day», Const.«DayFn»]),
ap (Const.«relatedInternalConcept») ([Const.«Day», Const.«DayDuration»]),
mkForall (fun («?DAY» : Obj) => mkImp (ap (Const.«instance») ([«?DAY», Const.«Day»])) (ap (Const.«duration») ([«?DAY», ap (Const.«MeasureFn») ([numLit "1", Const.«DayDuration»])]))),
ap (Const.«subclass») ([Const.«Monday», Const.«Day»]),
mkForall (fun («?DAY1» : Obj) => mkForall (fun («?DAY2» : Obj) => mkForall (fun («?WEEK» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?DAY1», Const.«Sunday»]), ap (Const.«instance») ([«?DAY2», Const.«Monday»]), ap (Const.«instance») ([«?WEEK», Const.«Week»]), ap (Const.«temporalPart») ([«?DAY1», «?WEEK»]), ap (Const.«temporalPart») ([«?DAY2», «?WEEK»])]) (ap (Const.«meetsTemporally») ([«?DAY1», «?DAY2»]))))),
ap (Const.«subclass») ([Const.«Tuesday», Const.«Day»]),
mkForall (fun («?DAY1» : Obj) => mkForall (fun («?DAY2» : Obj) => mkForall (fun («?WEEK» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?DAY1», Const.«Monday»]), ap (Const.«instance») ([«?DAY2», Const.«Tuesday»]), ap (Const.«instance») ([«?WEEK», Const.«Week»]), ap (Const.«temporalPart») ([«?DAY1», «?WEEK»]), ap (Const.«temporalPart») ([«?DAY2», «?WEEK»])]) (ap (Const.«meetsTemporally») ([«?DAY1», «?DAY2»]))))),
ap (Const.«subclass») ([Const.«Wednesday», Const.«Day»]),
mkForall (fun («?DAY1» : Obj) => mkForall (fun («?DAY2» : Obj) => mkForall (fun («?WEEK» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?DAY1», Const.«Tuesday»]), ap (Const.«instance») ([«?DAY2», Const.«Wednesday»]), ap (Const.«instance») ([«?WEEK», Const.«Week»]), ap (Const.«temporalPart») ([«?DAY1», «?WEEK»]), ap (Const.«temporalPart») ([«?DAY2», «?WEEK»])]) (ap (Const.«meetsTemporally») ([«?DAY1», «?DAY2»]))))),
ap (Const.«subclass») ([Const.«Thursday», Const.«Day»]),
mkForall (fun («?DAY1» : Obj) => mkForall (fun («?DAY2» : Obj) => mkForall (fun («?WEEK» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?DAY1», Const.«Wednesday»]), ap (Const.«instance») ([«?DAY2», Const.«Thursday»]), ap (Const.«instance») ([«?WEEK», Const.«Week»]), ap (Const.«temporalPart») ([«?DAY1», «?WEEK»]), ap (Const.«temporalPart») ([«?DAY2», «?WEEK»])]) (ap (Const.«meetsTemporally») ([«?DAY1», «?DAY2»]))))),
ap (Const.«subclass») ([Const.«Friday», Const.«Day»]),
mkForall (fun («?DAY1» : Obj) => mkForall (fun («?DAY2» : Obj) => mkForall (fun («?WEEK» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?DAY1», Const.«Thursday»]), ap (Const.«instance») ([«?DAY2», Const.«Friday»]), ap (Const.«instance») ([«?WEEK», Const.«Week»]), ap (Const.«temporalPart») ([«?DAY1», «?WEEK»]), ap (Const.«temporalPart») ([«?DAY2», «?WEEK»])]) (ap (Const.«meetsTemporally») ([«?DAY1», «?DAY2»]))))),
ap (Const.«subclass») ([Const.«Saturday», Const.«Day»]),
mkForall (fun («?DAY1» : Obj) => mkForall (fun («?DAY2» : Obj) => mkForall (fun («?WEEK» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?DAY1», Const.«Friday»]), ap (Const.«instance») ([«?DAY2», Const.«Saturday»]), ap (Const.«instance») ([«?WEEK», Const.«Week»]), ap (Const.«temporalPart») ([«?DAY1», «?WEEK»]), ap (Const.«temporalPart») ([«?DAY2», «?WEEK»])]) (ap (Const.«meetsTemporally») ([«?DAY1», «?DAY2»]))))),
ap (Const.«subclass») ([Const.«Sunday», Const.«Day»]),
mkForall (fun («?DAY1» : Obj) => mkForall (fun («?DAY2» : Obj) => mkForall (fun («?WEEK» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?DAY1», Const.«Saturday»]), ap (Const.«instance») ([«?DAY2», Const.«Sunday»]), ap (Const.«instance») ([«?WEEK», Const.«Week»]), ap (Const.«temporalPart») ([«?DAY1», «?WEEK»]), ap (Const.«temporalPart») ([«?DAY2», «?WEEK»])]) (mkNot (ap (Const.«meetsTemporally») ([«?DAY1», «?DAY2»])))))),
mkForall (fun («?DAY1» : Obj) => mkForall (fun («?DAY2» : Obj) => mkForall (fun («?WEEK1» : Obj) => mkForall (fun («?WEEK2» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?DAY1», Const.«Saturday»]), ap (Const.«instance») ([«?DAY2», Const.«Sunday»]), ap (Const.«instance») ([«?WEEK1», Const.«Week»]), ap (Const.«instance») ([«?WEEK2», Const.«Week»]), ap (Const.«temporalPart») ([«?DAY1», «?WEEK1»]), ap (Const.«temporalPart») ([«?DAY2», «?WEEK2»]), ap (Const.«meetsTemporally») ([«?WEEK1», «?WEEK2»])]) (ap (Const.«meetsTemporally») ([«?DAY1», «?DAY2»])))))),
ap (Const.«subclass») ([Const.«Week», Const.«TimeInterval»]),
mkForall (fun («?WEEK» : Obj) => mkImp (ap (Const.«instance») ([«?WEEK», Const.«Week»])) (ap (Const.«duration») ([«?WEEK», ap (Const.«MeasureFn») ([numLit "1", Const.«WeekDuration»])]))),
mkForall (fun («?S» : Obj) => mkForall (fun («?W» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?S», Const.«Sunday»]), ap (Const.«instance») ([«?W», Const.«Week»]), ap (Const.«during») ([«?S», «?W»])]) (ap (Const.«starts») ([«?S», «?W»])))),
mkForall (fun («?S» : Obj) => mkForall (fun («?W» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?S», Const.«Saturday»]), ap (Const.«instance») ([«?W», Const.«Week»]), ap (Const.«during») ([«?S», «?W»])]) (ap (Const.«finishes») ([«?S», «?W»])))),
ap (Const.«subclass») ([Const.«Hour», Const.«TimeInterval»]),
ap (Const.«relatedInternalConcept») ([Const.«Hour», Const.«HourFn»]),
ap (Const.«relatedInternalConcept») ([Const.«Hour», Const.«HourDuration»]),
mkForall (fun («?HOUR» : Obj) => mkImp (ap (Const.«instance») ([«?HOUR», Const.«Hour»])) (ap (Const.«duration») ([«?HOUR», ap (Const.«MeasureFn») ([numLit "1", Const.«HourDuration»])]))),
ap (Const.«subclass») ([Const.«Minute», Const.«TimeInterval»]),
ap (Const.«relatedInternalConcept») ([Const.«Minute», Const.«MinuteFn»]),
ap (Const.«relatedInternalConcept») ([Const.«Minute», Const.«MinuteDuration»]),
mkForall (fun («?MINUTE» : Obj) => mkImp (ap (Const.«instance») ([«?MINUTE», Const.«Minute»])) (ap (Const.«duration») ([«?MINUTE», ap (Const.«MeasureFn») ([numLit "1", Const.«MinuteDuration»])]))),
ap (Const.«subclass») ([Const.«Second», Const.«TimeInterval»]),
ap (Const.«relatedInternalConcept») ([Const.«Second», Const.«SecondDuration»]),
ap (Const.«relatedInternalConcept») ([Const.«Second», Const.«SecondFn»]),
mkForall (fun («?SECOND» : Obj) => mkImp (ap (Const.«instance») ([«?SECOND», Const.«Second»])) (ap (Const.«duration») ([«?SECOND», ap (Const.«MeasureFn») ([numLit "1", Const.«SecondDuration»])]))),
ap (Const.«instance») ([Const.«TemporalCompositionFn», Const.«TemporalRelation»]),
ap (Const.«instance») ([Const.«TemporalCompositionFn», Const.«BinaryFunction»]),
ap (Const.«instance») ([Const.«TemporalCompositionFn», Const.«TotalValuedRelation»]),
mkForall (fun («?CLASS» : Obj) => mkForall (fun («?INTERVAL» : Obj) => mkForall (fun («?INTERVALTYPE» : Obj) => mkImp (ap (Const.«equal») ([ap (Const.«TemporalCompositionFn») ([«?INTERVAL», «?INTERVALTYPE»]), «?CLASS»])) (mkForall (fun («?TIME1» : Obj) => mkForall (fun («?TIME2» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?TIME1», «?INTERVALTYPE»]), ap (Const.«instance») ([«?TIME2», «?CLASS»])]) (mkExists (fun («?DURATION» : Obj) => mkAnd [ap (Const.«duration») ([«?TIME1», «?DURATION»]), ap (Const.«duration») ([«?TIME2», «?DURATION»])])))))))),
mkForall (fun («?CLASS» : Obj) => mkForall (fun («?INTERVAL» : Obj) => mkForall (fun («?INTERVALTYPE» : Obj) => mkImp (ap (Const.«equal») ([ap (Const.«TemporalCompositionFn») ([«?INTERVAL», «?INTERVALTYPE»]), «?CLASS»])) (mkForall (fun («?TIME1» : Obj) => mkForall (fun («?TIME2» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?TIME1», «?CLASS»]), ap (Const.«instance») ([«?TIME2», «?CLASS»]), mkNot (ap (Const.«equal») ([«?TIME1», «?TIME2»]))]) (mkOr [ap (Const.«meetsTemporally») ([«?TIME1», «?TIME2»]), ap (Const.«meetsTemporally») ([«?TIME2», «?TIME1»]), ap (Const.«earlier») ([«?TIME1», «?TIME2»]), ap (Const.«earlier») ([«?TIME2», «?TIME1»])]))))))),
mkForall (fun («?CLASS» : Obj) => mkForall (fun («?INTERVAL» : Obj) => mkForall (fun («?INTERVALTYPE» : Obj) => mkImp (ap (Const.«equal») ([ap (Const.«TemporalCompositionFn») ([«?INTERVAL», «?INTERVALTYPE»]), «?CLASS»])) (mkExists (fun («?TIME» : Obj) => mkAnd [ap (Const.«instance») ([«?TIME», «?CLASS»]), ap (Const.«starts») ([«?TIME», «?INTERVAL»])]))))),
mkForall (fun («?CLASS» : Obj) => mkForall (fun («?INTERVAL» : Obj) => mkForall (fun («?INTERVALTYPE» : Obj) => mkImp (ap (Const.«equal») ([ap (Const.«TemporalCompositionFn») ([«?INTERVAL», «?INTERVALTYPE»]), «?CLASS»])) (mkExists (fun («?TIME» : Obj) => mkAnd [ap (Const.«instance») ([«?TIME», «?CLASS»]), ap (Const.«finishes») ([«?TIME», «?INTERVAL»])]))))),
mkForall (fun («?CLASS» : Obj) => mkForall (fun («?INTERVAL» : Obj) => mkForall (fun («?INTERVALTYPE» : Obj) => mkImp (ap (Const.«equal») ([ap (Const.«TemporalCompositionFn») ([«?INTERVAL», «?INTERVALTYPE»]), «?CLASS»])) (mkForall (fun («?TIME1» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?TIME1», «?CLASS»]), mkNot (ap (Const.«finishes») ([«?TIME1», «?INTERVAL»]))]) (mkExists (fun («?TIME2» : Obj) => mkAnd [ap (Const.«instance») ([«?TIME2», «?CLASS»]), ap (Const.«meetsTemporally») ([«?TIME1», «?TIME2»])]))))))),
mkForall (fun («?CLASS» : Obj) => mkForall (fun («?INTERVAL» : Obj) => mkForall (fun («?INTERVALTYPE» : Obj) => mkImp (ap (Const.«equal») ([ap (Const.«TemporalCompositionFn») ([«?INTERVAL», «?INTERVALTYPE»]), «?CLASS»])) (mkForall (fun («?TIME1» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?TIME1», «?CLASS»]), mkNot (ap (Const.«starts») ([«?TIME1», «?INTERVAL»]))]) (mkExists (fun («?TIME2» : Obj) => mkAnd [ap (Const.«instance») ([«?TIME2», «?CLASS»]), ap (Const.«meetsTemporally») ([«?TIME2», «?TIME1»])]))))))),
mkForall (fun («?CLASS» : Obj) => mkForall (fun («?INTERVAL» : Obj) => mkForall (fun («?INTERVALTYPE» : Obj) => mkImp (ap (Const.«equal») ([ap (Const.«TemporalCompositionFn») ([«?INTERVAL», «?INTERVALTYPE»]), «?CLASS»])) (mkForall (fun («?TIME» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?TIME», Const.«TimePoint»]), ap (Const.«temporalPart») ([«?TIME», «?INTERVAL»])]) (mkExists (fun («?INSTANCE» : Obj) => mkAnd [ap (Const.«instance») ([«?INSTANCE», «?CLASS»]), ap (Const.«temporalPart») ([«?TIME», «?INSTANCE»])]))))))),
mkForall (fun («?YEAR» : Obj) => mkImp (ap (Const.«instance») ([«?YEAR», Const.«Year»])) (ap (Const.«equal») ([ap (Const.«CardinalityFn») ([ap (Const.«TemporalCompositionFn») ([«?YEAR», Const.«Month»])]), numLit "12"]))),
mkForall (fun («?MONTH» : Obj) => mkForall (fun («?NUMBER» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?MONTH», Const.«Month»]), ap (Const.«duration») ([«?MONTH», ap (Const.«MeasureFn») ([«?NUMBER», Const.«DayDuration»])])]) (ap (Const.«equal») ([ap (Const.«CardinalityFn») ([ap (Const.«TemporalCompositionFn») ([«?MONTH», Const.«Day»])]), «?NUMBER»])))),
mkForall (fun («?WEEK» : Obj) => mkImp (ap (Const.«instance») ([«?WEEK», Const.«Week»])) (ap (Const.«equal») ([ap (Const.«CardinalityFn») ([ap (Const.«TemporalCompositionFn») ([«?WEEK», Const.«Day»])]), numLit "7"]))),
mkForall (fun («?DAY» : Obj) => mkImp (ap (Const.«instance») ([«?DAY», Const.«Day»])) (ap (Const.«equal») ([ap (Const.«CardinalityFn») ([ap (Const.«TemporalCompositionFn») ([«?DAY», Const.«Hour»])]), numLit "24"]))),
mkForall (fun («?HOUR» : Obj) => mkImp (ap (Const.«instance») ([«?HOUR», Const.«Hour»])) (ap (Const.«equal») ([ap (Const.«CardinalityFn») ([ap (Const.«TemporalCompositionFn») ([«?HOUR», Const.«Minute»])]), numLit "60"]))),
mkForall (fun («?MINUTE» : Obj) => mkImp (ap (Const.«instance») ([«?MINUTE», Const.«Minute»])) (ap (Const.«equal») ([ap (Const.«CardinalityFn») ([ap (Const.«TemporalCompositionFn») ([«?MINUTE», Const.«Second»])]), numLit "60"]))),
ap (Const.«instance») ([Const.«connected», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«connected», Const.«SpatialRelation»]),
ap (Const.«instance») ([Const.«connected», Const.«ReflexiveRelation»]),
ap (Const.«instance») ([Const.«connected», Const.«SymmetricRelation»]),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkImp (ap (Const.«connected») ([«?OBJ1», «?OBJ2»])) (mkOr [ap (Const.«meetsSpatially») ([«?OBJ1», «?OBJ2»]), ap (Const.«overlapsSpatially») ([«?OBJ1», «?OBJ2»])]))),
mkForall (fun («?OBJ» : Obj) => mkForall (fun («?PART1» : Obj) => mkForall (fun («?PART2» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?OBJ», Const.«SelfConnectedObject»]), ap (Const.«equal») ([«?OBJ», ap (Const.«MereologicalSumFn») ([«?PART1», «?PART2»])])]) (ap (Const.«connected») ([«?PART1», «?PART2»]))))),
mkForall (fun («?OBJ» : Obj) => mkForall (fun («?PART1» : Obj) => mkForall (fun («?PART2» : Obj) => mkImp (mkAnd [ap (Const.«equal») ([«?OBJ», ap (Const.«MereologicalSumFn») ([«?PART1», «?PART2»])]), ap (Const.«connected») ([«?PART1», «?PART2»])]) (ap (Const.«instance») ([«?OBJ», Const.«SelfConnectedObject»]))))),
ap (Const.«instance») ([Const.«connects», Const.«SpatialRelation»]),
ap (Const.«instance») ([Const.«connects», Const.«TernaryPredicate»]),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkForall (fun («?OBJ3» : Obj) => mkImp (ap (Const.«connects») ([«?OBJ1», «?OBJ2», «?OBJ3»])) (ap (Const.«between») ([«?OBJ2», «?OBJ1», «?OBJ3»]))))),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkForall (fun («?OBJ3» : Obj) => mkImp (ap (Const.«between») ([«?OBJ2», «?OBJ1», «?OBJ3»])) (ap (Const.«connects») ([«?OBJ1», «?OBJ2», «?OBJ3»]))))),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkForall (fun («?OBJ3» : Obj) => mkImp (ap (Const.«connects») ([«?OBJ1», «?OBJ2», «?OBJ3»])) (mkAnd [ap (Const.«connected») ([«?OBJ1», «?OBJ2»]), ap (Const.«connected») ([«?OBJ1», «?OBJ3»]), mkNot (ap (Const.«connected») ([«?OBJ2», «?OBJ3»]))])))),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkForall (fun («?OBJ3» : Obj) => mkImp (mkAnd [ap (Const.«connected») ([«?OBJ1», «?OBJ2»]), ap (Const.«connected») ([«?OBJ1», «?OBJ3»]), mkNot (ap (Const.«connected») ([«?OBJ2», «?OBJ3»]))]) (ap (Const.«connects») ([«?OBJ1», «?OBJ2», «?OBJ3»]))))),
mkForall (fun («?ARC» : Obj) => mkForall (fun («?NODE1» : Obj) => mkForall (fun («?NODE2» : Obj) => mkImp (ap (Const.«connects») ([«?ARC», «?NODE1», «?NODE2»])) (ap (Const.«connects») ([«?ARC», «?NODE2», «?NODE1»]))))),
ap (Const.«relatedInternalConcept») ([Const.«meetsSpatially», Const.«connected»]),
ap (Const.«instance») ([Const.«meetsSpatially», Const.«IrreflexiveRelation»]),
ap (Const.«instance») ([Const.«meetsSpatially», Const.«SymmetricRelation»]),
ap (Const.«instance») ([Const.«meetsSpatially», Const.«BinaryPredicate»]),
ap (Const.«disjointRelation») ([Const.«meetsSpatially», Const.«overlapsSpatially»]),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkImp (ap (Const.«overlapsSpatially») ([«?OBJ1», «?OBJ2»])) (mkExists (fun («?OBJ3» : Obj) => mkAnd [ap (Const.«part») ([«?OBJ3», «?OBJ1»]), ap (Const.«part») ([«?OBJ3», «?OBJ2»])])))),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkForall (fun («?OBJ3» : Obj) => mkImp (mkAnd [ap (Const.«part») ([«?OBJ3», «?OBJ1»]), ap (Const.«part») ([«?OBJ3», «?OBJ2»])]) (ap (Const.«overlapsSpatially») ([«?OBJ1», «?OBJ2»]))))),
mkForall (fun («?COLL» : Obj) => mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkImp (mkAnd [ap (Const.«member») ([«?OBJ1», «?COLL»]), ap (Const.«member») ([«?OBJ2», «?COLL»]), mkNot (ap (Const.«equal») ([«?OBJ1», «?OBJ2»]))]) (mkNot (ap (Const.«overlapsSpatially») ([«?OBJ1», «?OBJ2»])))))),
mkForall (fun («?OBJ» : Obj) => mkForall (fun («?PROCESS» : Obj) => mkForall (fun («?REL» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?REL», Const.«CaseRole»]), ap (Const.«instance») ([«?OBJ», Const.«Object»]), ap («?REL») ([«?PROCESS», «?OBJ»])]) (mkExists (fun («?TIME» : Obj) => ap (Const.«overlapsSpatially») ([ap (Const.«WhereFn») ([«?PROCESS», «?TIME»]), «?OBJ»])))))),
ap (Const.«instance») ([Const.«overlapsPartially», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«overlapsPartially», Const.«SymmetricRelation»]),
ap (Const.«instance») ([Const.«overlapsPartially», Const.«PartialValuedRelation»]),
ap (Const.«instance») ([Const.«overlapsPartially», Const.«IrreflexiveRelation»]),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkImp (ap (Const.«overlapsPartially») ([«?OBJ1», «?OBJ2»])) (mkAnd [mkNot (ap (Const.«part») ([«?OBJ1», «?OBJ2»])), mkNot (ap (Const.«part») ([«?OBJ2», «?OBJ1»])), mkExists (fun («?OBJ3» : Obj) => mkAnd [ap (Const.«part») ([«?OBJ3», «?OBJ1»]), ap (Const.«part») ([«?OBJ3», «?OBJ2»])])]))),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkForall (fun («?OBJ3» : Obj) => mkImp (mkAnd [mkNot (ap (Const.«part») ([«?OBJ1», «?OBJ2»])), mkNot (ap (Const.«part») ([«?OBJ2», «?OBJ1»])), mkAnd [ap (Const.«part») ([«?OBJ3», «?OBJ1»]), ap (Const.«part») ([«?OBJ3», «?OBJ2»])]]) (ap (Const.«overlapsPartially») ([«?OBJ1», «?OBJ2»]))))),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkImp (ap (Const.«overlapsPartially») ([«?OBJ1», «?OBJ2»])) (ap (Const.«overlapsSpatially») ([«?OBJ1», «?OBJ2»])))),
mkForall (fun («?PART» : Obj) => mkForall (fun («?WHOLE» : Obj) => mkImp (ap (Const.«superficialPart») ([«?PART», «?WHOLE»])) (ap (Const.«part») ([«?PART», «?WHOLE»])))),
ap (Const.«instance») ([Const.«superficialPart», Const.«IrreflexiveRelation»]),
ap (Const.«instance») ([Const.«superficialPart», Const.«TransitiveRelation»]),
ap (Const.«instance») ([Const.«superficialPart», Const.«PartialValuedRelation»]),
ap (Const.«instance») ([Const.«superficialPart», Const.«BinaryPredicate»]),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkImp (ap (Const.«superficialPart») ([«?OBJ1», «?OBJ2»])) (mkAnd [mkNot (ap (Const.«interiorPart») ([«?OBJ1», «?OBJ2»])), mkNot (mkExists (fun («?OBJ3» : Obj) => ap (Const.«interiorPart») ([«?OBJ3», «?OBJ1»])))]))),
ap (Const.«instance») ([Const.«surface», Const.«AsymmetricRelation»]),
ap (Const.«instance») ([Const.«surface», Const.«BinaryPredicate»]),
ap (Const.«subrelation») ([Const.«surface», Const.«superficialPart»]),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkImp (ap (Const.«surface») ([«?OBJ1», «?OBJ2»])) (mkForall (fun («?OBJ3» : Obj) => mkImp (ap (Const.«superficialPart») ([«?OBJ3», «?OBJ2»])) (ap (Const.«part») ([«?OBJ3», «?OBJ1»])))))),
ap (Const.«subrelation») ([Const.«interiorPart», Const.«part»]),
ap (Const.«instance») ([Const.«interiorPart», Const.«AsymmetricRelation»]),
ap (Const.«instance») ([Const.«interiorPart», Const.«TransitiveRelation»]),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkImp (ap (Const.«interiorPart») ([«?OBJ1», «?OBJ2»])) (mkForall (fun («?PART» : Obj) => mkImp (ap (Const.«superficialPart») ([«?PART», «?OBJ2»])) (mkNot (ap (Const.«overlapsSpatially») ([«?OBJ1», «?PART»]))))))),
ap (Const.«subrelation») ([Const.«bottom», Const.«superficialPart»]),
ap (Const.«instance») ([Const.«bottom», Const.«BinaryPredicate»]),
mkForall (fun («?BOTTOM» : Obj) => mkForall (fun («?OBJECT» : Obj) => mkForall (fun («?PART» : Obj) => mkImp (mkAnd [ap (Const.«bottom») ([«?BOTTOM», «?OBJECT»]), ap (Const.«part») ([«?PART», «?OBJECT»]), mkNot (ap (Const.«connected») ([«?PART», «?BOTTOM»]))]) (ap (Const.«orientation») ([«?PART», «?BOTTOM», Const.«Above»]))))),
ap (Const.«subrelation») ([Const.«top», Const.«superficialPart»]),
ap (Const.«instance») ([Const.«top», Const.«BinaryPredicate»]),
mkForall (fun («?OBJECT» : Obj) => mkForall (fun («?PART» : Obj) => mkForall (fun («?TOP» : Obj) => mkImp (mkAnd [ap (Const.«top») ([«?TOP», «?OBJECT»]), ap (Const.«part») ([«?PART», «?OBJECT»]), mkNot (ap (Const.«connected») ([«?PART», «?TOP»]))]) (ap (Const.«orientation») ([«?PART», «?TOP», Const.«Below»]))))),
ap (Const.«subrelation») ([Const.«side», Const.«superficialPart»]),
ap (Const.«instance») ([Const.«side», Const.«BinaryPredicate»]),
mkForall (fun («?OBJECT» : Obj) => mkForall (fun («?PART» : Obj) => mkForall (fun («?SIDE» : Obj) => mkImp (mkAnd [ap (Const.«side») ([«?SIDE», «?OBJECT»]), ap (Const.«part») ([«?PART», «?OBJECT»]), mkNot (ap (Const.«connected») ([«?PART», «?SIDE»]))]) (mkExists (fun («?DIRECT» : Obj) => ap (Const.«orientation») ([«?SIDE», «?PART», «?DIRECT»])))))),
mkForall (fun («?O» : Obj) => mkForall (fun («?S» : Obj) => mkForall (fun («?TOP» : Obj) => mkImp (mkAnd [ap (Const.«top») ([«?TOP», «?O»]), ap (Const.«side») ([«?S», «?O»])]) (mkNot (ap (Const.«equal») ([«?TOP», «?S»])))))),
mkForall (fun («?OBJECT» : Obj) => mkForall (fun («?WIDTH» : Obj) => mkImp (ap (Const.«width») ([«?OBJECT», «?WIDTH»])) (mkExists (fun («?SIDE1» : Obj) => mkExists (fun («?SIDE2» : Obj) => mkAnd [ap (Const.«side») ([«?SIDE1», «?OBJECT»]), ap (Const.«side») ([«?SIDE2», «?OBJECT»]), ap (Const.«distance») ([«?SIDE1», «?SIDE2», «?WIDTH»])]))))),
mkForall (fun («?OBJECT» : Obj) => mkForall (fun («?SIDE1» : Obj) => mkForall (fun («?SIDE2» : Obj) => mkForall (fun («?WIDTH» : Obj) => mkImp (mkAnd [ap (Const.«side») ([«?SIDE1», «?OBJECT»]), ap (Const.«side») ([«?SIDE2», «?OBJECT»]), ap (Const.«distance») ([«?SIDE1», «?SIDE2», «?WIDTH»])]) (ap (Const.«width») ([«?OBJECT», «?WIDTH»])))))),
mkForall (fun («?BOTTOM» : Obj) => mkForall (fun («?HEIGHT» : Obj) => mkForall (fun («?OBJECT» : Obj) => mkForall (fun («?TOP» : Obj) => mkImp (mkAnd [ap (Const.«height») ([«?OBJECT», «?HEIGHT»]), ap (Const.«top») ([«?TOP», «?OBJECT»]), ap (Const.«bottom») ([«?BOTTOM», «?OBJECT»])]) (ap (Const.«distance») ([«?TOP», «?BOTTOM», «?HEIGHT»])))))),
ap (Const.«instance») ([Const.«MereologicalSumFn», Const.«SpatialRelation»]),
ap (Const.«instance») ([Const.«MereologicalSumFn», Const.«BinaryFunction»]),
ap (Const.«instance») ([Const.«MereologicalSumFn», Const.«TotalValuedRelation»]),
ap (Const.«relatedInternalConcept») ([Const.«MereologicalSumFn», Const.«MereologicalProductFn»]),
ap (Const.«relatedInternalConcept») ([Const.«MereologicalSumFn», Const.«MereologicalDifferenceFn»]),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkForall (fun («?OBJ3» : Obj) => mkImp (ap (Const.«equal») ([«?OBJ3», ap (Const.«MereologicalSumFn») ([«?OBJ1», «?OBJ2»])])) (mkForall (fun («?PART» : Obj) => mkIff (ap (Const.«part») ([«?PART», «?OBJ3»])) (mkOr [ap (Const.«part») ([«?PART», «?OBJ1»]), ap (Const.«part») ([«?PART», «?OBJ2»])])))))),
ap (Const.«instance») ([Const.«MereologicalProductFn», Const.«SpatialRelation»]),
ap (Const.«instance») ([Const.«MereologicalProductFn», Const.«BinaryFunction»]),
ap (Const.«instance») ([Const.«MereologicalProductFn», Const.«TotalValuedRelation»]),
ap (Const.«relatedInternalConcept») ([Const.«MereologicalProductFn», Const.«MereologicalDifferenceFn»]),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkForall (fun («?OBJ3» : Obj) => mkImp (ap (Const.«equal») ([«?OBJ3», ap (Const.«MereologicalProductFn») ([«?OBJ1», «?OBJ2»])])) (mkForall (fun («?PART» : Obj) => mkIff (ap (Const.«part») ([«?PART», «?OBJ3»])) (mkAnd [ap (Const.«part») ([«?PART», «?OBJ1»]), ap (Const.«part») ([«?PART», «?OBJ2»])])))))),
ap (Const.«instance») ([Const.«MereologicalDifferenceFn», Const.«SpatialRelation»]),
ap (Const.«instance») ([Const.«MereologicalDifferenceFn», Const.«BinaryFunction»]),
ap (Const.«instance») ([Const.«MereologicalDifferenceFn», Const.«TotalValuedRelation»]),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkForall (fun («?OBJ3» : Obj) => mkImp (ap (Const.«equal») ([«?OBJ3», ap (Const.«MereologicalDifferenceFn») ([«?OBJ1», «?OBJ2»])])) (mkForall (fun («?PART» : Obj) => mkIff (ap (Const.«properPart») ([«?PART», «?OBJ3»])) (mkAnd [ap (Const.«properPart») ([«?PART», «?OBJ1»]), mkNot (ap (Const.«properPart») ([«?PART», «?OBJ2»]))])))))),
ap (Const.«subclass») ([Const.«HoleRegion», Const.«Region»]),
mkForall (fun («?HOLE» : Obj) => mkImp (ap (Const.«instance») ([«?HOLE», Const.«HoleRegion»])) (mkExists (fun («?OBJ» : Obj) => ap (Const.«hole») ([«?HOLE», «?OBJ»])))),
mkForall (fun («?HOLE» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (ap (Const.«hole») ([«?HOLE», «?OBJ»])) (ap (Const.«instance») ([«?HOLE», Const.«HoleRegion»])))),
mkForall (fun («?HOLE» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (ap (Const.«hole») ([«?HOLE», «?OBJ»])) (mkNot (ap (Const.«instance») ([«?OBJ», Const.«HoleRegion»]))))),
mkForall (fun («?HOLE» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (ap (Const.«hole») ([«?HOLE», «?OBJ»])) (mkNot (ap (Const.«overlapsSpatially») ([«?HOLE», «?OBJ»]))))),
mkForall (fun («?HOLE» : Obj) => mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkImp (mkAnd [ap (Const.«hole») ([«?HOLE», «?OBJ1»]), ap (Const.«hole») ([«?HOLE», «?OBJ2»])]) (mkExists (fun («?OBJ3» : Obj) => mkAnd [ap (Const.«properPart») ([«?OBJ3», ap (Const.«MereologicalProductFn») ([«?OBJ1», «?OBJ2»])]), ap (Const.«hole») ([«?HOLE», «?OBJ3»])]))))),
mkForall (fun («?HOLE1» : Obj) => mkForall (fun («?HOLE2» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (mkAnd [ap (Const.«hole») ([«?HOLE1», «?OBJ»]), ap (Const.«hole») ([«?HOLE2», «?OBJ»])]) (mkForall (fun («?HOLE3» : Obj) => mkImp (ap (Const.«part») ([«?HOLE3», ap (Const.«MereologicalSumFn») ([«?HOLE1», «?HOLE2»])])) (ap (Const.«hole») ([«?HOLE3», «?OBJ»]))))))),
mkForall (fun («?HOLE» : Obj) => mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkImp (mkAnd [ap (Const.«hole») ([«?HOLE», «?OBJ1»]), ap (Const.«part») ([«?OBJ1», «?OBJ2»])]) (mkOr [ap (Const.«overlapsSpatially») ([«?HOLE», «?OBJ2»]), ap (Const.«hole») ([«?HOLE», «?OBJ2»])])))),
mkForall (fun («?HOLE1» : Obj) => mkForall (fun («?HOLE2» : Obj) => mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkImp (mkAnd [ap (Const.«hole») ([«?HOLE1», «?OBJ1»]), ap (Const.«hole») ([«?HOLE2», «?OBJ2»]), ap (Const.«overlapsSpatially») ([«?HOLE1», «?HOLE2»])]) (ap (Const.«overlapsSpatially») ([«?OBJ1», «?OBJ2»])))))),
mkForall (fun («?HOLE1» : Obj) => mkImp (ap (Const.«instance») ([«?HOLE1», Const.«HoleRegion»])) (mkExists (fun («?HOLE2» : Obj) => ap (Const.«properPart») ([«?HOLE2», «?HOLE1»])))),
ap (Const.«instance») ([Const.«HoleHostFn», Const.«UnaryFunction»]),
mkForall (fun («?HOLE» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (ap (Const.«hole») ([«?HOLE», «?OBJ»])) (ap (Const.«connected») ([«?HOLE», «?OBJ»])))),
mkForall (fun («?HOLE1» : Obj) => mkForall (fun («?HOLE2» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?HOLE1», Const.«HoleRegion»]), ap (Const.«properPart») ([«?HOLE2», «?HOLE1»])]) (mkExists (fun («?OBJ» : Obj) => mkAnd [ap (Const.«meetsSpatially») ([«?HOLE1», «?OBJ»]), mkNot (ap (Const.«meetsSpatially») ([«?HOLE2», «?OBJ»]))])))),
ap (Const.«instance») ([Const.«Fillable», Const.«ShapeAttribute»]),
mkForall (fun («?HOLE» : Obj) => mkForall (fun («?OBJ» : Obj) => mkForall (fun («?TIME» : Obj) => mkImp (ap (Const.«holdsDuring») ([«?TIME», ap (Const.«fills») ([«?OBJ», «?HOLE»])])) (ap (Const.«attribute») ([«?HOLE», Const.«Fillable»]))))),
mkForall (fun («?HOLE1» : Obj) => mkImp (ap (Const.«attribute») ([«?HOLE1», Const.«Fillable»])) (mkExists (fun («?HOLE2» : Obj) => mkAnd [ap (Const.«instance») ([«?HOLE2», Const.«HoleRegion»]), ap (Const.«part») ([«?HOLE1», «?HOLE2»])]))),
mkForall (fun («?HOLE1» : Obj) => mkForall (fun («?HOLE2» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?HOLE2», Const.«HoleRegion»]), ap (Const.«part») ([«?HOLE1», «?HOLE2»])]) (ap (Const.«attribute») ([«?HOLE1», Const.«Fillable»])))),
ap (Const.«subrelation») ([Const.«partiallyFills», Const.«located»]),
ap (Const.«instance») ([Const.«partiallyFills», Const.«SpatialRelation»]),
ap (Const.«instance») ([Const.«partiallyFills», Const.«AsymmetricRelation»]),
mkForall (fun («?HOLE1» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (ap (Const.«partiallyFills») ([«?OBJ», «?HOLE1»])) (mkExists (fun («?HOLE2» : Obj) => mkAnd [ap (Const.«part») ([«?HOLE2», «?HOLE1»]), ap (Const.«completelyFills») ([«?OBJ», «?HOLE2»])])))),
mkForall (fun («?HOLE1» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (ap (Const.«properlyFills») ([«?OBJ», «?HOLE1»])) (mkExists (fun («?HOLE2» : Obj) => mkAnd [ap (Const.«part») ([«?HOLE2», «?HOLE1»]), ap (Const.«fills») ([«?OBJ», «?HOLE2»])])))),
ap (Const.«instance») ([Const.«completelyFills», Const.«AsymmetricRelation»]),
ap (Const.«subrelation») ([Const.«completelyFills», Const.«partiallyFills»]),
mkForall (fun («?HOLE» : Obj) => mkForall (fun («?OBJ1» : Obj) => mkImp (ap (Const.«completelyFills») ([«?OBJ1», «?HOLE»])) (mkExists (fun («?OBJ2» : Obj) => mkAnd [ap (Const.«part») ([«?OBJ2», «?OBJ1»]), ap (Const.«fills») ([«?OBJ2», «?HOLE»])])))),
ap (Const.«instance») ([Const.«fills», Const.«AsymmetricRelation»]),
ap (Const.«subrelation») ([Const.«fills», Const.«completelyFills»]),
ap (Const.«subrelation») ([Const.«fills», Const.«properlyFills»]),
ap (Const.«relatedInternalConcept») ([Const.«fills», Const.«Fillable»]),
mkForall (fun («?HOLE» : Obj) => mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkImp (mkAnd [ap (Const.«fills») ([«?OBJ1», «?HOLE»]), ap (Const.«attribute») ([«?OBJ2», Const.«Fillable»])]) (mkNot (ap (Const.«overlapsSpatially») ([«?OBJ1», «?OBJ2»])))))),
mkForall (fun («?HOLE» : Obj) => mkForall (fun («?OBJ1» : Obj) => mkImp (ap (Const.«completelyFills») ([«?OBJ1», «?HOLE»])) (mkForall (fun («?OBJ2» : Obj) => mkImp (ap (Const.«connected») ([«?OBJ2», «?HOLE»])) (ap (Const.«connected») ([«?OBJ2», «?OBJ1»])))))),
mkForall (fun («?HOLE» : Obj) => mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkImp (mkAnd [ap (Const.«properlyFills») ([«?OBJ1», «?HOLE»]), ap (Const.«connected») ([«?OBJ2», «?OBJ1»])]) (ap (Const.«connected») ([«?HOLE», «?OBJ2»]))))),
mkForall (fun («?HOLE1» : Obj) => mkForall (fun («?HOLE2» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (mkAnd [ap (Const.«fills») ([«?OBJ», «?HOLE1»]), ap (Const.«properPart») ([«?HOLE2», «?HOLE1»])]) (ap (Const.«completelyFills») ([«?OBJ», «?HOLE2»]))))),
mkForall (fun («?HOLE» : Obj) => mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkImp (mkAnd [ap (Const.«fills») ([«?OBJ1», «?HOLE»]), ap (Const.«properPart») ([«?OBJ2», «?OBJ1»])]) (ap (Const.«properlyFills») ([«?OBJ2», «?HOLE»]))))),
ap (Const.«instance») ([Const.«HoleSkinFn», Const.«UnaryFunction»]),
mkForall (fun («?HOLE» : Obj) => mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkImp (ap (Const.«equal») ([«?OBJ1», ap (Const.«HoleSkinFn») ([«?HOLE»])])) (mkImp (ap (Const.«overlapsSpatially») ([«?OBJ2», «?OBJ1»])) (mkExists (fun («?OBJ3» : Obj) => mkAnd [ap (Const.«superficialPart») ([«?OBJ3», ap (Const.«HoleHostFn») ([«?HOLE»])]), ap (Const.«meetsSpatially») ([«?HOLE», «?OBJ3»]), ap (Const.«overlapsSpatially») ([«?OBJ2», «?OBJ3»])])))))),
mkForall (fun («?HOLE» : Obj) => mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkForall (fun («?OBJ3» : Obj) => mkImp (ap (Const.«equal») ([«?OBJ1», ap (Const.«HoleSkinFn») ([«?HOLE»])])) (mkImp (mkAnd [ap (Const.«superficialPart») ([«?OBJ3», ap (Const.«HoleHostFn») ([«?HOLE»])]), ap (Const.«meetsSpatially») ([«?HOLE», «?OBJ3»]), ap (Const.«overlapsSpatially») ([«?OBJ2», «?OBJ3»])]) (ap (Const.«overlapsSpatially») ([«?OBJ2», «?OBJ1»]))))))),
mkForall (fun («?PROC» : Obj) => mkForall (fun («?SUBPROC» : Obj) => mkImp (ap (Const.«subProcess») ([«?SUBPROC», «?PROC»])) (ap (Const.«temporalPart») ([ap (Const.«WhenFn») ([«?SUBPROC»]), ap (Const.«WhenFn») ([«?PROC»])])))),
ap (Const.«subclass») ([Const.«BiologicalProcess», Const.«InternalChange»]),
mkForall (fun («?PROC» : Obj) => mkImp (ap (Const.«instance») ([«?PROC», Const.«BiologicalProcess»])) (mkExists (fun («?OBJ» : Obj) => mkAnd [ap (Const.«instance») ([«?OBJ», Const.«Organism»]), ap (Const.«eventLocated») ([«?PROC», «?OBJ»])]))),
mkForall (fun («?ORG» : Obj) => mkForall (fun («?PROC» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?PROC», Const.«BiologicalProcess»]), ap (Const.«experiencer») ([«?PROC», «?ORG»])]) (ap (Const.«instance») ([«?ORG», Const.«Organism»])))),
mkForall (fun («?O» : Obj) => mkImp (ap (Const.«instance») ([«?O», Const.«Organism»])) (mkNot (ap (Const.«capability») ([Const.«BiologicalProcess», Const.«agent», «?O»])))),
mkForall (fun («?O» : Obj) => mkImp (ap (Const.«instance») ([«?O», Const.«Organism»])) (ap (Const.«capability») ([Const.«BiologicalProcess», Const.«experiencer», «?O»]))),
ap (Const.«subclass») ([Const.«PhysiologicProcess», Const.«BiologicalProcess»]),
ap (Const.«subclass») ([Const.«AutonomicProcess», Const.«PhysiologicProcess»]),
ap (Const.«disjoint») ([Const.«AutonomicProcess», Const.«IntentionalProcess»]),
ap (Const.«subclass») ([Const.«OrganOrTissueProcess», Const.«AutonomicProcess»]),
ap (Const.«disjoint») ([Const.«OrganOrTissueProcess», Const.«OrganismProcess»]),
mkForall (fun («?PROC» : Obj) => mkImp (ap (Const.«instance») ([«?PROC», Const.«OrganOrTissueProcess»])) (mkExists (fun («?THING» : Obj) => mkAnd [ap (Const.«eventLocated») ([«?PROC», «?THING»]), mkOr [ap (Const.«instance») ([«?THING», Const.«Organ»]), ap (Const.«instance») ([«?THING», Const.«Tissue»])]]))),
ap (Const.«subclass») ([Const.«OrganismProcess», Const.«PhysiologicProcess»]),
ap (Const.«subclass») ([Const.«Birth», Const.«OrganismProcess»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?BIRTH» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?BIRTH», Const.«Birth»]), ap (Const.«experiencer») ([«?BIRTH», «?AGENT»])]) (mkExists (fun («?DEATH» : Obj) => mkAnd [ap (Const.«instance») ([«?DEATH», Const.«Death»]), ap (Const.«experiencer») ([«?DEATH», «?AGENT»])])))),
ap (Const.«subclass») ([Const.«Death», Const.«OrganismProcess»]),
mkForall (fun («?DEATH» : Obj) => mkForall (fun («?ORG» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?DEATH», Const.«Death»]), ap (Const.«instance») ([«?ORG», Const.«Organism»]), ap (Const.«experiencer») ([«?DEATH», «?ORG»])]) (mkExists (fun («?REM» : Obj) => mkExists (fun («?OBJ» : Obj) => mkAnd [ap (Const.«result») ([«?DEATH», «?REM»]), ap (Const.«instance») ([«?REM», Const.«OrganicObject»]), ap (Const.«holdsDuring») ([ap (Const.«FutureFn») ([ap (Const.«WhenFn») ([«?DEATH»])]), ap (Const.«attribute») ([«?REM», Const.«Dead»])]), mkImp (ap (Const.«holdsDuring») ([ap (Const.«ImmediateFutureFn») ([ap (Const.«WhenFn») ([«?DEATH»])]), ap (Const.«part») ([«?OBJ», «?REM»])])) (ap (Const.«holdsDuring») ([ap (Const.«ImmediatePastFn») ([ap (Const.«WhenFn») ([«?DEATH»])]), ap (Const.«part») ([«?OBJ», «?ORG»])]))]))))),
ap (Const.«subclass») ([Const.«Breathing», Const.«OrganismProcess»]),
ap (Const.«subclass») ([Const.«Breathing», Const.«AutonomicProcess»]),
ap (Const.«subclass») ([Const.«Ingesting», Const.«OrganismProcess»]),
ap (Const.«subclass») ([Const.«Ingesting», Const.«Transfer»]),
mkForall (fun («?ACT» : Obj) => mkForall (fun («?F» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?ACT», Const.«Ingesting»]), ap (Const.«resource») ([«?ACT», «?F»])]) (mkOr [ap (Const.«instance») ([«?F», ap (Const.«FoodForFn») ([Const.«Organism»])]), ap (Const.«instance») ([«?F», Const.«Medicine»])]))),
ap (Const.«subclass») ([Const.«Eating», Const.«Ingesting»]),
mkForall (fun («?ACT» : Obj) => mkForall (fun («?FOOD» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?ACT», Const.«Eating»]), ap (Const.«resource») ([«?ACT», «?FOOD»])]) (ap (Const.«attribute») ([«?FOOD», Const.«Solid»])))),
ap (Const.«subclass») ([Const.«Drinking», Const.«Ingesting»]),
mkForall (fun («?ACT» : Obj) => mkForall (fun («?FOOD» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?ACT», Const.«Drinking»]), ap (Const.«resource») ([«?ACT», «?FOOD»])]) (ap (Const.«attribute») ([«?FOOD», Const.«Liquid»])))),
ap (Const.«subclass») ([Const.«Digesting», Const.«OrganismProcess»]),
ap (Const.«subclass») ([Const.«Digesting», Const.«AutonomicProcess»]),
mkForall (fun («?DIGEST» : Obj) => mkForall (fun («?ORGANISM» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?DIGEST», Const.«Digesting»]), ap (Const.«agent») ([«?DIGEST», «?ORGANISM»])]) (mkExists (fun («?INGEST» : Obj) => mkAnd [ap (Const.«instance») ([«?INGEST», Const.«Ingesting»]), ap (Const.«agent») ([«?INGEST», «?ORGANISM»]), ap (Const.«overlapsTemporally») ([ap (Const.«WhenFn») ([«?INGEST»]), ap (Const.«WhenFn») ([«?DIGEST»])])])))),
mkForall (fun («?DIGEST» : Obj) => mkImp (ap (Const.«instance») ([«?DIGEST», Const.«Digesting»])) (mkExists (fun («?DECOMP» : Obj) => mkAnd [ap (Const.«instance») ([«?DECOMP», Const.«ChemicalDecomposition»]), ap (Const.«subProcess») ([«?DECOMP», «?DIGEST»])]))),
ap (Const.«subclass») ([Const.«Growth», Const.«AutonomicProcess»]),
ap (Const.«subclass») ([Const.«Replication», Const.«OrganismProcess»]),
mkForall (fun («?CHILD» : Obj) => mkForall (fun («?PARENT» : Obj) => mkForall (fun («?REP» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?REP», Const.«Replication»]), ap (Const.«agent») ([«?REP», «?PARENT»]), ap (Const.«result») ([«?REP», «?CHILD»])]) (ap (Const.«parent») ([«?CHILD», «?PARENT»]))))),
mkForall (fun («?REP» : Obj) => mkImp (ap (Const.«instance») ([«?REP», Const.«Replication»])) (mkExists (fun («?BODY» : Obj) => mkAnd [ap (Const.«instance») ([«?BODY», Const.«ReproductiveBody»]), ap (Const.«result») ([«?REP», «?BODY»])]))),
ap (Const.«subclass») ([Const.«SexualReproduction», Const.«Replication»]),
ap (Const.«disjoint») ([Const.«SexualReproduction», Const.«AsexualReproduction»]),
mkForall (fun («?ORGANISM» : Obj) => mkForall (fun («?REP» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?REP», Const.«SexualReproduction»]), ap (Const.«result») ([«?REP», «?ORGANISM»])]) (mkExists (fun («?MOTHER» : Obj) => mkExists (fun («?FATHER» : Obj) => mkAnd [ap (Const.«mother») ([«?ORGANISM», «?MOTHER»]), ap (Const.«father») ([«?ORGANISM», «?FATHER»])]))))),
ap (Const.«subclass») ([Const.«AsexualReproduction», Const.«Replication»]),
mkForall (fun («?ORGANISM» : Obj) => mkForall (fun («?PARENT1» : Obj) => mkForall (fun («?PARENT2» : Obj) => mkForall (fun («?REP» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?REP», Const.«AsexualReproduction»]), ap (Const.«result») ([«?REP», «?ORGANISM»]), ap (Const.«parent») ([«?ORGANISM», «?PARENT1»]), ap (Const.«parent») ([«?ORGANISM», «?PARENT2»])]) (ap (Const.«equal») ([«?PARENT1», «?PARENT2»])))))),
ap (Const.«subclass») ([Const.«PsychologicalProcess», Const.«BiologicalProcess»]),
mkForall (fun («?PROCESS» : Obj) => mkImp (ap (Const.«instance») ([«?PROCESS», Const.«PsychologicalProcess»])) (mkExists (fun («?ANIMAL» : Obj) => mkAnd [ap (Const.«instance») ([«?ANIMAL», Const.«Animal»]), ap (Const.«experiencer») ([«?PROCESS», «?ANIMAL»])]))),
ap (Const.«subclass») ([Const.«PathologicProcess», Const.«BiologicalProcess»]),
ap (Const.«disjoint») ([Const.«PathologicProcess», Const.«PhysiologicProcess»]),
mkForall (fun («?ORG» : Obj) => mkForall (fun («?PATH» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?PATH», Const.«PathologicProcess»]), ap (Const.«experiencer») ([«?PATH», «?ORG»])]) (mkExists (fun («?PART» : Obj) => mkExists (fun («?DISEASE» : Obj) => mkAnd [ap (Const.«part») ([«?PART», «?ORG»]), ap (Const.«instance») ([«?DISEASE», Const.«DiseaseOrSyndrome»]), ap (Const.«attribute») ([«?PART», «?DISEASE»])]))))),
ap (Const.«instance») ([Const.«pathologicSymptom», Const.«BinaryPredicate»]),
mkForall (fun («?D» : Obj) => mkForall (fun («?S» : Obj) => mkImp (ap (Const.«pathologicSymptom») ([«?D», «?S»])) (mkExists (fun («?O» : Obj) => ap (Const.«increasesLikelihood») ([ap (Const.«attribute») ([«?O», «?D»]), mkExists (fun («?I» : Obj) => mkAnd [ap (Const.«instance») ([«?I», «?S»]), ap (Const.«experiencer») ([«?I», «?O»])])]))))),
ap (Const.«subclass») ([Const.«Injuring», Const.«PathologicProcess»]),
ap (Const.«subclass») ([Const.«Injuring», Const.«Damaging»]),
mkForall (fun («?INJ» : Obj) => mkImp (ap (Const.«instance») ([«?INJ», Const.«Injuring»])) (mkExists (fun («?STRUCT» : Obj) => mkAnd [ap (Const.«instance») ([«?STRUCT», Const.«AnatomicalStructure»]), ap (Const.«patient») ([«?INJ», «?STRUCT»])]))),
mkForall (fun («?INJ» : Obj) => mkImp (ap (Const.«instance») ([«?INJ», Const.«Injuring»])) (mkAnd [ap (Const.«instance») ([«?INJ», Const.«Damaging»]), mkExists (fun («?ORGANISM» : Obj) => mkAnd [ap (Const.«instance») ([«?ORGANISM», Const.«Organism»]), ap (Const.«patient») ([«?INJ», «?ORGANISM»])])])),
mkForall (fun («?INJ» : Obj) => mkForall (fun («?ORGANISM» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?INJ», Const.«Damaging»]), ap (Const.«instance») ([«?ORGANISM», Const.«Organism»]), ap (Const.«patient») ([«?INJ», «?ORGANISM»])]) (ap (Const.«instance») ([«?INJ», Const.«Injuring»])))),
ap (Const.«subclass») ([Const.«Poisoning», Const.«Injuring»]),
mkForall (fun («?POISON» : Obj) => mkImp (ap (Const.«instance») ([«?POISON», Const.«Poisoning»])) (mkExists (fun («?THING» : Obj) => mkAnd [ap (Const.«patient») ([«?POISON», «?THING»]), mkOr [ap (Const.«instance») ([«?THING», Const.«Organism»]), ap (Const.«instance») ([«?THING», Const.«AnatomicalStructure»])]]))),
mkForall (fun («?POISON» : Obj) => mkImp (ap (Const.«instance») ([«?POISON», Const.«Poisoning»])) (mkExists (fun («?SUBSTANCE» : Obj) => mkAnd [ap (Const.«instance») ([«?SUBSTANCE», Const.«BiologicallyActiveSubstance»]), ap (Const.«instrument») ([«?POISON», «?SUBSTANCE»])]))),
ap (Const.«subclass») ([Const.«NaturalProcess», Const.«Process»]),
ap (Const.«disjoint») ([Const.«NaturalProcess», Const.«IntentionalProcess»]),
ap (Const.«subclass») ([Const.«IntentionalProcess», Const.«Process»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?PROC» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?PROC», Const.«IntentionalProcess»]), ap (Const.«agent») ([«?PROC», «?AGENT»])]) (mkExists (fun («?PURP» : Obj) => ap (Const.«hasPurposeForAgent») ([«?PROC», «?PURP», «?AGENT»]))))),
mkForall (fun («?PROC» : Obj) => mkImp (ap (Const.«instance») ([«?PROC», Const.«IntentionalProcess»])) (mkExists (fun («?AGENT» : Obj) => mkAnd [ap (Const.«instance») ([«?AGENT», Const.«CognitiveAgent»]), ap (Const.«agent») ([«?PROC», «?AGENT»])]))),
mkForall (fun («?HUMAN» : Obj) => mkForall (fun («?PROC» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?PROC», Const.«IntentionalProcess»]), ap (Const.«agent») ([«?PROC», «?HUMAN»]), ap (Const.«instance») ([«?HUMAN», Const.«Animal»])]) (ap (Const.«holdsDuring») ([ap (Const.«WhenFn») ([«?PROC»]), ap (Const.«attribute») ([«?HUMAN», Const.«Awake»])])))),
ap (Const.«subclass») ([Const.«IntentionalPsychologicalProcess», Const.«IntentionalProcess»]),
ap (Const.«subclass») ([Const.«IntentionalPsychologicalProcess», Const.«PsychologicalProcess»]),
ap (Const.«subclass») ([Const.«RecreationOrExercise», Const.«IntentionalProcess»]),
ap (Const.«subclass») ([Const.«OrganizationalProcess», Const.«IntentionalProcess»]),
mkForall (fun («?ACT» : Obj) => mkForall (fun («?AGENT» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?ACT», Const.«OrganizationalProcess»]), ap (Const.«agent») ([«?ACT», «?AGENT»])]) (mkOr [ap (Const.«instance») ([«?AGENT», Const.«Organization»]), mkExists (fun («?ORG» : Obj) => mkAnd [ap (Const.«instance») ([«?ORG», Const.«Organization»]), ap (Const.«member») ([«?AGENT», «?ORG»])])]))),
ap (Const.«subclass») ([Const.«Election», Const.«OrganizationalProcess»]),
ap (Const.«subclass») ([Const.«ReligiousProcess», Const.«OrganizationalProcess»]),
mkForall (fun («?ACT» : Obj) => mkForall (fun («?AGENT» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?ACT», Const.«ReligiousProcess»]), ap (Const.«agent») ([«?ACT», «?AGENT»])]) (mkOr [ap (Const.«instance») ([«?AGENT», Const.«ReligiousOrganization»]), mkExists (fun («?ORG» : Obj) => mkAnd [ap (Const.«member») ([«?AGENT», «?ORG»]), ap (Const.«instance») ([«?ORG», Const.«ReligiousOrganization»])])]))),
ap (Const.«subclass») ([Const.«JoiningAnOrganization», Const.«OrganizationalProcess»]),
mkForall (fun («?JOIN» : Obj) => mkForall (fun («?ORG» : Obj) => mkForall (fun («?PERSON» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?JOIN», Const.«JoiningAnOrganization»]), ap (Const.«instance») ([«?ORG», Const.«Organization»]), ap (Const.«agent») ([«?JOIN», «?PERSON»]), ap (Const.«patient») ([«?JOIN», «?ORG»])]) (mkAnd [ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?JOIN»])]), mkNot (ap (Const.«member») ([«?PERSON», «?ORG»]))]), ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?JOIN»])]), ap (Const.«member») ([«?PERSON», «?ORG»])])])))),
ap (Const.«instance») ([Const.«expects», Const.«BinaryPredicate»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?FORMULA» : Obj) => mkForall (fun («?T1» : Obj) => mkImp (ap (Const.«holdsDuring») ([«?T1», ap (Const.«expects») ([«?AGENT», «?FORMULA»])])) (mkExists (fun («?T2» : Obj) => mkAnd [ap (Const.«holdsDuring») ([«?T1», ap (Const.«believes») ([«?AGENT», ap (Const.«holdsDuring») ([«?T2», «?FORMULA»])])]), ap (Const.«earlier») ([«?T1», «?T2»])]))))),
ap (Const.«subclass») ([Const.«Hiring», Const.«OrganizationalProcess»]),
mkForall (fun («?JOIN» : Obj) => mkForall (fun («?ORG» : Obj) => mkForall (fun («?PERSON» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?JOIN», Const.«Hiring»]), ap (Const.«instance») ([«?ORG», Const.«Organization»]), ap (Const.«agent») ([«?JOIN», «?ORG»]), ap (Const.«patient») ([«?JOIN», «?PERSON»])]) (mkAnd [ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?JOIN»])]), mkNot (ap (Const.«member») ([«?PERSON», «?ORG»]))]), ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?JOIN»])]), ap (Const.«member») ([«?PERSON», «?ORG»])])])))),
mkForall (fun («?JOIN» : Obj) => mkForall (fun («?ORG» : Obj) => mkForall (fun («?PERSON» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?JOIN», Const.«Hiring»]), ap (Const.«instance») ([«?ORG», Const.«Organization»]), ap (Const.«agent») ([«?JOIN», «?ORG»]), ap (Const.«patient») ([«?JOIN», «?PERSON»])]) (ap (Const.«holdsDuring») ([ap (Const.«ImmediateFutureFn») ([ap (Const.«WhenFn») ([«?JOIN»])]), ap (Const.«employs») ([«?ORG», «?PERSON»])]))))),
mkForall (fun («?JOIN» : Obj) => mkForall (fun («?ORG» : Obj) => mkForall (fun («?PERSON» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?JOIN», Const.«Hiring»]), ap (Const.«instance») ([«?ORG», Const.«Organization»]), ap (Const.«agent») ([«?JOIN», «?ORG»]), ap (Const.«patient») ([«?JOIN», «?PERSON»])]) (ap (Const.«expects») ([«?ORG», mkExists (fun («?FT» : Obj) => mkAnd [ap (Const.«instance») ([«?FT», Const.«FinancialTransaction»]), ap (Const.«agent») ([«?FT», «?ORG»]), ap (Const.«destination») ([«?FT», «?PERSON»]), ap (Const.«earlier») ([ap (Const.«WhenFn») ([«?JOIN»]), ap (Const.«WhenFn») ([«?FT»])])])]))))),
ap (Const.«subclass») ([Const.«LeavingAnOrganization», Const.«OrganizationalProcess»]),
ap (Const.«disjoint») ([Const.«LeavingAnOrganization», Const.«JoiningAnOrganization»]),
mkForall (fun («?LEAVE» : Obj) => mkForall (fun («?ORG» : Obj) => mkForall (fun («?PERSON» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?LEAVE», Const.«LeavingAnOrganization»]), ap (Const.«instance») ([«?ORG», Const.«Organization»]), ap (Const.«agent») ([«?LEAVE», «?PERSON»]), ap (Const.«patient») ([«?LEAVE», «?ORG»])]) (mkAnd [ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?LEAVE»])]), ap (Const.«member») ([«?PERSON», «?ORG»])]), ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?LEAVE»])]), mkNot (ap (Const.«member») ([«?PERSON», «?ORG»]))])])))),
ap (Const.«subclass») ([Const.«Quitting», Const.«LeavingAnOrganization»]),
mkForall (fun («?LEAVE» : Obj) => mkForall (fun («?ORG» : Obj) => mkForall (fun («?PERSON» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?LEAVE», Const.«Quitting»]), ap (Const.«instance») ([«?ORG», Const.«Organization»]), ap (Const.«agent») ([«?LEAVE», «?PERSON»]), ap (Const.«patient») ([«?LEAVE», «?ORG»])]) (ap (Const.«desires») ([«?PERSON», ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?LEAVE»])]), mkNot (ap (Const.«member») ([«?PERSON», «?ORG»]))])]))))),
ap (Const.«subclass») ([Const.«Firing», Const.«OrganizationalProcess»]),
mkForall (fun («?LEAVE» : Obj) => mkForall (fun («?ORG» : Obj) => mkForall (fun («?P» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?LEAVE», Const.«Firing»]), ap (Const.«instance») ([«?ORG», Const.«Organization»]), ap (Const.«agent») ([«?LEAVE», «?ORG»]), ap (Const.«patient») ([«?LEAVE», «?P»])]) (mkAnd [ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?LEAVE»])]), ap (Const.«member») ([«?P», «?ORG»])]), ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?LEAVE»])]), mkNot (ap (Const.«member») ([«?P», «?ORG»]))])])))),
ap (Const.«subclass») ([Const.«Volunteering», Const.«Offering»]),
ap (Const.«subclass») ([Const.«Graduation», Const.«LeavingAnOrganization»]),
mkForall (fun («?GRAD» : Obj) => mkForall (fun («?ORG» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?GRAD», Const.«Graduation»]), ap (Const.«agent») ([«?GRAD», «?ORG»])]) (ap (Const.«instance») ([«?ORG», Const.«EducationalOrganization»])))),
ap (Const.«subclass») ([Const.«Matriculation», Const.«JoiningAnOrganization»]),
mkForall (fun («?MAT» : Obj) => mkForall (fun («?ORG» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?MAT», Const.«Matriculation»]), ap (Const.«agent») ([«?MAT», «?ORG»])]) (ap (Const.«instance») ([«?ORG», Const.«EducationalOrganization»])))),
ap (Const.«subclass») ([Const.«Hiring», Const.«JoiningAnOrganization»]),
mkForall (fun («?HIRE» : Obj) => mkForall (fun («?ORG» : Obj) => mkForall (fun («?PERSON» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?HIRE», Const.«Hiring»]), ap (Const.«instance») ([«?ORG», Const.«Organization»]), ap (Const.«agent») ([«?HIRE», «?ORG»]), ap (Const.«patient») ([«?HIRE», «?PERSON»])]) (mkAnd [ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?HIRE»])]), mkNot (ap (Const.«employs») ([«?ORG», «?PERSON»]))]), ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?HIRE»])]), ap (Const.«employs») ([«?ORG», «?PERSON»])])])))),
ap (Const.«subclass») ([Const.«TerminatingEmployment», Const.«LeavingAnOrganization»]),
mkForall (fun («?FIRE» : Obj) => mkForall (fun («?ORG» : Obj) => mkForall (fun («?PERSON» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?FIRE», Const.«TerminatingEmployment»]), ap (Const.«instance») ([«?ORG», Const.«Organization»]), ap (Const.«agent») ([«?FIRE», «?ORG»]), ap (Const.«patient») ([«?FIRE», «?PERSON»])]) (mkAnd [ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?FIRE»])]), ap (Const.«employs») ([«?ORG», «?PERSON»])]), ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?FIRE»])]), mkNot (ap (Const.«employs») ([«?ORG», «?PERSON»]))])])))),
ap (Const.«subclass») ([Const.«PoliticalProcess», Const.«OrganizationalProcess»]),
mkForall (fun («?PROC» : Obj) => mkImp (ap (Const.«instance») ([«?PROC», Const.«PoliticalProcess»])) (mkExists (fun («?POL» : Obj) => mkAnd [mkOr [ap (Const.«instance») ([«?POL», Const.«Government»]), mkExists (fun («?GOV» : Obj) => mkAnd [ap (Const.«instance») ([«?GOV», Const.«Government»]), ap (Const.«member») ([«?POL», «?GOV»])])], mkOr [ap (Const.«agent») ([«?PROC», «?POL»]), ap (Const.«patient») ([«?PROC», «?POL»])]]))),
ap (Const.«subclass») ([Const.«JudicialProcess», Const.«PoliticalProcess»]),
mkForall (fun («?ORG» : Obj) => mkForall (fun («?PROCESS» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?PROCESS», Const.«JudicialProcess»]), ap (Const.«agent») ([«?PROCESS», «?ORG»]), ap (Const.«instance») ([«?ORG», Const.«Organization»])]) (ap (Const.«instance») ([«?ORG», Const.«JudicialOrganization»])))),
ap (Const.«subclass») ([Const.«LegalDecision», Const.«JudicialProcess»]),
ap (Const.«subclass») ([Const.«LegalDecision», Const.«Declaring»]),
mkForall (fun («?DECISION» : Obj) => mkImp (ap (Const.«instance») ([«?DECISION», Const.«LegalDecision»])) (mkExists (fun («?ACTION» : Obj) => mkAnd [ap (Const.«instance») ([«?ACTION», Const.«LegalAction»]), ap (Const.«refers») ([«?DECISION», «?ACTION»])]))),
mkForall (fun («?DECISION» : Obj) => mkImp (ap (Const.«instance») ([«?DECISION», Const.«LegalDecision»])) (mkExists (fun («?DECIDE» : Obj) => mkExists (fun («?LD» : Obj) => mkAnd [ap (Const.«instance») ([«?DECIDE», Const.«Deciding»]), ap (Const.«result») ([«?DECIDE», «?LD»]), ap (Const.«instance») ([«?DECISION», «?LD»]), ap (Const.«earlier») ([ap (Const.«WhenFn») ([«?DECIDE»]), ap (Const.«WhenFn») ([«?DECISION»])])])))),
ap (Const.«subclass») ([Const.«MilitaryProcess», Const.«PoliticalProcess»]),
ap (Const.«subclass») ([Const.«MilitaryProcess», Const.«OrganizationalProcess»]),
ap (Const.«subclass») ([Const.«RegulatoryProcess», Const.«Guiding»]),
ap (Const.«subclass») ([Const.«Managing», Const.«OrganizationalProcess»]),
ap (Const.«subclass») ([Const.«Managing», Const.«Guiding»]),
ap (Const.«subclass») ([Const.«Planning», Const.«IntentionalPsychologicalProcess»]),
mkForall (fun («?CBO» : Obj) => mkForall (fun («?EVENT» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?EVENT», Const.«Planning»]), ap (Const.«result») ([«?EVENT», «?CBO»]), ap (Const.«instance») ([«?CBO», Const.«ContentBearingObject»])]) (mkExists (fun («?PLAN» : Obj) => mkAnd [ap (Const.«instance») ([«?PLAN», Const.«Plan»]), ap (Const.«containsInformation») ([«?CBO», «?PLAN»])])))),
ap (Const.«subclass») ([Const.«Designing», Const.«IntentionalProcess»]),
ap (Const.«subclass») ([Const.«Designing», Const.«ContentDevelopment»]),
ap (Const.«subclass») ([Const.«Interpreting», Const.«IntentionalPsychologicalProcess»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?CONTENT» : Obj) => mkForall (fun («?INTERPRET» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?INTERPRET», Const.«Interpreting»]), ap (Const.«agent») ([«?INTERPRET», «?AGENT»]), ap (Const.«patient») ([«?INTERPRET», «?CONTENT»]), ap (Const.«instance») ([«?CONTENT», Const.«ContentBearingObject»])]) (mkExists (fun («?PROP» : Obj) => ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?INTERPRET»])]), ap (Const.«believes») ([«?AGENT», ap (Const.«containsInformation») ([«?CONTENT», «?PROP»])])])))))),
ap (Const.«subclass») ([Const.«QuantityChange», Const.«InternalChange»]),
ap (Const.«partition») ([Const.«QuantityChange», Const.«Increasing», Const.«Decreasing»]),
mkForall (fun («?D» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?D», Const.«QuantityChange»]), ap (Const.«patient») ([«?D», «?OBJ»])]) (mkExists (fun («?N1» : Obj) => mkExists (fun («?N2» : Obj) => mkExists (fun («?T1» : Obj) => mkExists (fun («?T2» : Obj) => mkExists (fun («?U» : Obj) => mkAnd [ap (Const.«earlier») ([«?T1», «?T2»]), ap (Const.«holdsDuring») ([«?T1», ap (Const.«measure») ([«?OBJ», ap (Const.«MeasureFn») ([«?N1», «?U»])])]), ap (Const.«holdsDuring») ([«?T2», ap (Const.«measure») ([«?OBJ», ap (Const.«MeasureFn») ([«?N2», «?U»])])]), mkNot (ap (Const.«equal») ([«?N1», «?N2»]))])))))))),
ap (Const.«subclass») ([Const.«Increasing», Const.«QuantityChange»]),
ap (Const.«relatedInternalConcept») ([Const.«Increasing», Const.«Putting»]),
mkForall (fun («?D» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?D», Const.«Increasing»]), ap (Const.«patient») ([«?D», «?OBJ»])]) (mkExists (fun («?N1» : Obj) => mkExists (fun («?N2» : Obj) => mkExists (fun («?T1» : Obj) => mkExists (fun («?T2» : Obj) => mkExists (fun («?U» : Obj) => mkAnd [ap (Const.«earlier») ([«?T1», «?T2»]), ap (Const.«holdsDuring») ([«?T1», ap (Const.«measure») ([«?OBJ», ap (Const.«MeasureFn») ([«?N1», «?U»])])]), ap (Const.«holdsDuring») ([«?T2», ap (Const.«measure») ([«?OBJ», ap (Const.«MeasureFn») ([«?N2», «?U»])])]), ap (Const.«greaterThan») ([«?N1», «?N2»])])))))))),
ap (Const.«subclass») ([Const.«Heating», Const.«Increasing»]),
ap (Const.«disjoint») ([Const.«Heating», Const.«Cooling»]),
mkForall (fun («?HEAT» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?HEAT», Const.«Heating»]), ap (Const.«patient») ([«?HEAT», «?OBJ»])]) (mkExists (fun («?UNIT» : Obj) => mkExists (fun («?QUANT1» : Obj) => mkExists (fun («?QUANT2» : Obj) => mkAnd [ap (Const.«instance») ([«?UNIT», Const.«TemperatureMeasure»]), ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?HEAT»])]), ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?OBJ», «?UNIT»]), «?QUANT1»])]), ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?HEAT»])]), ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?OBJ», «?UNIT»]), «?QUANT2»])]), ap (Const.«greaterThan») ([«?QUANT2», «?QUANT1»])])))))),
ap (Const.«subclass») ([Const.«Decreasing», Const.«QuantityChange»]),
ap (Const.«relatedInternalConcept») ([Const.«Decreasing», Const.«Removing»]),
mkForall (fun («?D» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?D», Const.«Decreasing»]), ap (Const.«patient») ([«?D», «?OBJ»])]) (mkExists (fun («?N1» : Obj) => mkExists (fun («?N2» : Obj) => mkExists (fun («?T1» : Obj) => mkExists (fun («?T2» : Obj) => mkExists (fun («?U» : Obj) => mkAnd [ap (Const.«earlier») ([«?T1», «?T2»]), ap (Const.«holdsDuring») ([«?T1», ap (Const.«measure») ([«?OBJ», ap (Const.«MeasureFn») ([«?N1», «?U»])])]), ap (Const.«holdsDuring») ([«?T2», ap (Const.«measure») ([«?OBJ», ap (Const.«MeasureFn») ([«?N2», «?U»])])]), ap (Const.«lessThan») ([«?N1», «?N2»])])))))))),
ap (Const.«subclass») ([Const.«Cooling», Const.«Decreasing»]),
mkForall (fun («?COOL» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?COOL», Const.«Cooling»]), ap (Const.«patient») ([«?COOL», «?OBJ»])]) (mkExists (fun («?UNIT» : Obj) => mkExists (fun («?QUANT1» : Obj) => mkExists (fun («?QUANT2» : Obj) => mkAnd [ap (Const.«instance») ([«?UNIT», Const.«TemperatureMeasure»]), ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?COOL»])]), ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?OBJ», «?UNIT»]), «?QUANT1»])]), ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?COOL»])]), ap (Const.«equal») ([ap (Const.«MeasureFn») ([«?OBJ», «?UNIT»]), «?QUANT2»])]), ap (Const.«lessThan») ([«?QUANT2», «?QUANT1»])])))))),
ap (Const.«instance») ([Const.«moves», Const.«CaseRole»]),
ap (Const.«instance») ([Const.«moves», Const.«TotalValuedRelation»]),
ap (Const.«subrelation») ([Const.«moves», Const.«involvedInEvent»]),
ap (Const.«instance») ([Const.«changesLocation», Const.«CaseRole»]),
ap (Const.«instance») ([Const.«changesLocation», Const.«TotalValuedRelation»]),
ap (Const.«subrelation») ([Const.«changesLocation», Const.«moves»]),
mkForall (fun («?EVENT» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (ap (Const.«changesLocation») ([«?EVENT», «?OBJ»])) (mkAnd [ap (Const.«instance») ([«?EVENT», Const.«Translocation»]), ap (Const.«instance») ([«?OBJ», Const.«Object»]), mkOr [ap (Const.«patient») ([«?EVENT», «?OBJ»]), ap (Const.«agent») ([«?EVENT», «?OBJ»]), ap (Const.«experiencer») ([«?EVENT», «?OBJ»])]]))),
ap (Const.«subclass») ([Const.«Motion», Const.«Process»]),
mkForall (fun («?MOTION» : Obj) => mkImp (ap (Const.«instance») ([«?MOTION», Const.«Motion»])) (mkExists (fun («?OBJ» : Obj) => mkAnd [ap (Const.«instance») ([«?OBJ», Const.«Object»]), ap (Const.«moves») ([«?MOTION», «?OBJ»])]))),
mkForall (fun («?MOTION» : Obj) => mkForall (fun («?OBJ» : Obj) => mkForall (fun («?PLACE» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?MOTION», Const.«Motion»]), ap (Const.«moves») ([«?MOTION», «?OBJ»]), ap (Const.«origin») ([«?MOTION», «?PLACE»])]) (ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?MOTION»])]), ap (Const.«located») ([«?OBJ», «?PLACE»])]))))),
mkForall (fun («?MOTION» : Obj) => mkForall (fun («?OBJ» : Obj) => mkForall (fun («?PLACE» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?MOTION», Const.«Motion»]), ap (Const.«moves») ([«?MOTION», «?OBJ»]), ap (Const.«destination») ([«?MOTION», «?PLACE»])]) (ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?MOTION»])]), ap (Const.«located») ([«?OBJ», «?PLACE»])]))))),
ap (Const.«subclass») ([Const.«MotionUpward», Const.«Motion»]),
ap (Const.«disjoint») ([Const.«MotionUpward», Const.«MotionDownward»]),
ap (Const.«subclass») ([Const.«MotionDownward», Const.«Motion»]),
ap (Const.«instance») ([Const.«path», Const.«CaseRole»]),
ap (Const.«instance») ([Const.«path», Const.«TotalValuedRelation»]),
ap (Const.«subrelation») ([Const.«path», Const.«eventPartlyLocated»]),
mkForall (fun («?DEST» : Obj) => mkForall (fun («?DISTANCE» : Obj) => mkForall (fun («?MEASURE1» : Obj) => mkForall (fun («?OBJ» : Obj) => mkForall (fun («?PATH1» : Obj) => mkForall (fun («?PROCESS» : Obj) => mkForall (fun («?SOURCE» : Obj) => mkForall (fun («?U» : Obj) => mkImp (mkAnd [ap (Const.«path») ([«?PROCESS», «?PATH1»]), ap (Const.«origin») ([«?PROCESS», «?SOURCE»]), ap (Const.«destination») ([«?PROCESS», «?DEST»]), ap (Const.«length») ([«?PATH1», ap (Const.«MeasureFn») ([«?MEASURE1», «?U»])]), ap (Const.«distance») ([«?SOURCE», «?DEST», ap (Const.«MeasureFn») ([«?DISTANCE», «?U»])]), mkNot (ap (Const.«greaterThan») ([«?MEASURE1», «?DISTANCE»])), ap (Const.«part») ([«?OBJ», «?PATH1»])]) (ap (Const.«between») ([«?SOURCE», «?OBJ», «?DEST»])))))))))),
ap (Const.«subclass») ([Const.«BodyMotion», Const.«Motion»]),
mkForall (fun («?MOTION» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?MOTION», Const.«BodyMotion»]), ap (Const.«moves») ([«?MOTION», «?OBJ»])]) (mkAnd [ap (Const.«instance») ([«?OBJ», Const.«BodyPart»]), ap (Const.«patient») ([«?MOTION», «?OBJ»])]))),
mkForall (fun («?MOTION» : Obj) => mkImp (ap (Const.«instance») ([«?MOTION», Const.«BodyMotion»])) (mkExists (fun («?AGENT» : Obj) => mkAnd [ap (Const.«instance») ([«?AGENT», Const.«Organism»]), ap (Const.«agent») ([«?MOTION», «?AGENT»])]))),
ap (Const.«subclass») ([Const.«Ambulating», Const.«BodyMotion»]),
ap (Const.«subclass») ([Const.«Ambulating», Const.«IntentionalProcess»]),
ap (Const.«subclass») ([Const.«Ambulating», Const.«Translocation»]),
ap (Const.«partition») ([Const.«Ambulating», Const.«Walking», Const.«Running»]),
ap (Const.«subclass») ([Const.«Walking», Const.«Ambulating»]),
ap (Const.«subclass») ([Const.«Running», Const.«Ambulating»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?LENGTH1» : Obj) => mkForall (fun («?LENGTH2» : Obj) => mkForall (fun («?RUN» : Obj) => mkForall (fun («?TIME» : Obj) => mkForall (fun («?WALK» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?WALK», Const.«Walking»]), ap (Const.«instance») ([«?RUN», Const.«Running»]), ap (Const.«agent») ([«?WALK», «?AGENT»]), ap (Const.«agent») ([«?RUN», «?AGENT»]), ap (Const.«holdsDuring») ([ap (Const.«WhenFn») ([«?WALK»]), ap (Const.«measure») ([«?AGENT», ap (Const.«SpeedFn») ([«?LENGTH1», «?TIME»])])]), ap (Const.«holdsDuring») ([ap (Const.«WhenFn») ([«?RUN»]), ap (Const.«measure») ([«?AGENT», ap (Const.«SpeedFn») ([«?LENGTH2», «?TIME»])])])]) (ap (Const.«greaterThan») ([«?LENGTH2», «?LENGTH1»])))))))),
ap (Const.«subclass») ([Const.«Swimming», Const.«BodyMotion»]),
ap (Const.«subclass») ([Const.«Swimming», Const.«IntentionalProcess»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?SWIM» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?SWIM», Const.«Swimming»]), ap (Const.«agent») ([«?SWIM», «?AGENT»])]) (mkExists (fun («?AREA» : Obj) => mkAnd [ap (Const.«instance») ([«?AREA», Const.«WaterArea»]), ap (Const.«located») ([«?AGENT», «?AREA»])])))),
ap (Const.«subclass») ([Const.«Dancing», Const.«BodyMotion»]),
ap (Const.«subclass») ([Const.«GeologicalProcess», Const.«NaturalProcess»]),
ap (Const.«subclass») ([Const.«GeologicalProcess», Const.«Motion»]),
ap (Const.«subclass») ([Const.«GeologicalProcess», Const.«InternalChange»]),
ap (Const.«disjoint») ([Const.«GeologicalProcess», Const.«IntentionalProcess»]),
ap (Const.«subclass») ([Const.«WeatherProcess», Const.«Motion»]),
ap (Const.«disjoint») ([Const.«WeatherProcess», Const.«IntentionalProcess»]),
ap (Const.«subclass») ([Const.«Precipitation», Const.«WeatherProcess»]),
ap (Const.«subclass») ([Const.«Precipitation», Const.«WaterMotion»]),
ap (Const.«subclass») ([Const.«Precipitation», Const.«Falling»]),
mkForall (fun («?PROCESS» : Obj) => mkImp (ap (Const.«instance») ([«?PROCESS», Const.«Precipitation»])) (mkExists (fun («?STUFF» : Obj) => mkAnd [ap (Const.«instance») ([«?STUFF», Const.«Water»]), ap (Const.«patient») ([«?PROCESS», «?STUFF»])]))),
ap (Const.«subclass») ([Const.«LiquidMotion», Const.«Motion»]),
mkForall (fun («?MOTION» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?MOTION», Const.«LiquidMotion»]), ap (Const.«patient») ([«?MOTION», «?OBJ»])]) (ap (Const.«attribute») ([«?OBJ», Const.«Liquid»])))),
ap (Const.«subclass») ([Const.«WaterMotion», Const.«LiquidMotion»]),
mkForall (fun («?MOTION» : Obj) => mkImp (ap (Const.«instance») ([«?MOTION», Const.«WaterMotion»])) (mkExists (fun («?WATER» : Obj) => mkAnd [ap (Const.«patient») ([«?MOTION», «?WATER»]), ap (Const.«instance») ([«?WATER», Const.«Water»])]))),
ap (Const.«subclass») ([Const.«GasMotion», Const.«Motion»]),
mkForall (fun («?MOTION» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?MOTION», Const.«GasMotion»]), ap (Const.«patient») ([«?MOTION», «?OBJ»])]) (ap (Const.«attribute») ([«?OBJ», Const.«Gas»])))),
ap (Const.«subclass») ([Const.«Wind», Const.«GasMotion»]),
ap (Const.«instance») ([Const.«surfaceWindSpeed», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«Windy», Const.«Attribute»]),
mkForall (fun («?L» : Obj) => mkForall (fun («?N» : Obj) => mkForall (fun («?T» : Obj) => mkForall (fun («?W» : Obj) => mkImp (mkAnd [ap (Const.«attribute») ([«?W», Const.«Windy»]), ap (Const.«located») ([«?W», «?L»]), ap (Const.«equal») ([«?T», ap (Const.«WhenFn») ([«?W»])]), ap (Const.«holdsDuring») ([«?T», ap (Const.«surfaceWindSpeed») ([«?L», ap (Const.«MeasureFn») ([«?N», Const.«MilesPerHour»])])])]) (ap (Const.«greaterThan») ([«?N», numLit "20.0"])))))),
ap (Const.«subclass») ([Const.«DirectionChange», Const.«Motion»]),
mkForall (fun («?PROC» : Obj) => mkImp (ap (Const.«instance») ([«?PROC», Const.«DirectionChange»])) (mkExists (fun («?ATTR» : Obj) => mkAnd [ap (Const.«instance») ([«?ATTR», Const.«DirectionalAttribute»]), mkOr [mkAnd [ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?PROC»])]), ap (Const.«manner») ([«?PROC», «?ATTR»])]), ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?PROC»])]), mkNot (ap (Const.«manner») ([«?PROC», «?ATTR»]))])], mkAnd [ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?PROC»])]), ap (Const.«manner») ([«?PROC», «?ATTR»])]), ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?PROC»])]), mkNot (ap (Const.«manner») ([«?PROC», «?ATTR»]))])]]]))),
ap (Const.«subclass») ([Const.«Transfer», Const.«Translocation»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?PATIENT» : Obj) => mkForall (fun («?TRANSFER» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?TRANSFER», Const.«Transfer»]), ap (Const.«agent») ([«?TRANSFER», «?AGENT»]), ap (Const.«patient») ([«?TRANSFER», «?PATIENT»])]) (mkNot (ap (Const.«equal») ([«?AGENT», «?PATIENT»])))))),
mkForall (fun («?D1» : Obj) => mkForall (fun («?D2» : Obj) => mkForall (fun («?O1» : Obj) => mkForall (fun («?P» : Obj) => mkForall (fun («?T1» : Obj) => mkForall (fun («?T2» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?T1», Const.«Translocation»]), ap (Const.«instance») ([«?T2», Const.«Translocation»]), ap (Const.«origin») ([«?T1», «?O1»]), ap (Const.«origin») ([«?T2», «?D1»]), ap (Const.«destination») ([«?T1», «?D1»]), ap (Const.«destination») ([«?T2», «?D2»]), ap (Const.«experiencer») ([«?T1», «?P»]), ap (Const.«experiencer») ([«?T2», «?P»])]) (mkExists (fun («?T» : Obj) => mkAnd [ap (Const.«instance») ([«?T», Const.«Translocation»]), ap (Const.«origin») ([«?T», «?O1»]), ap (Const.«destination») ([«?T», «?D2»]), ap (Const.«subProcess») ([«?T1», «?T»]), ap (Const.«subProcess») ([«?T2», «?T»]), ap (Const.«experiencer») ([«?T», «?P»]), ap (Const.«starts») ([ap (Const.«WhenFn») ([«?T1»]), ap (Const.«WhenFn») ([«?T»])]), ap (Const.«finishes») ([ap (Const.«WhenFn») ([«?T2»]), ap (Const.«WhenFn») ([«?T»])])])))))))),
ap (Const.«instance») ([Const.«objectTransferred», Const.«CaseRole»]),
ap (Const.«subrelation») ([Const.«objectTransferred», Const.«patient»]),
mkForall (fun («?OBJ» : Obj) => mkForall (fun («?P» : Obj) => mkImp (ap (Const.«objectTransferred») ([«?P», «?OBJ»])) (mkExists (fun («?O» : Obj) => mkExists (fun («?D» : Obj) => mkAnd [ap (Const.«origin») ([«?P», «?O»]), ap (Const.«destination») ([«?P», «?D»]), ap (Const.«holdsDuring») ([ap (Const.«ImmediatePastFn») ([«?P»]), ap (Const.«located») ([«?OBJ», «?O»])]), ap (Const.«holdsDuring») ([ap (Const.«ImmediateFutureFn») ([«?P»]), ap (Const.«located») ([«?OBJ», «?D»])])]))))),
mkForall (fun («?O» : Obj) => mkForall (fun («?O2» : Obj) => mkForall (fun («?T» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?T», Const.«Transfer»]), ap (Const.«objectTransferred») ([«?T», «?O»]), ap (Const.«orientation») ([«?O2», «?O», Const.«Inside»])]) (ap (Const.«objectTransferred») ([«?T», «?O2»]))))),
mkForall (fun («?O» : Obj) => mkForall (fun («?O2» : Obj) => mkForall (fun («?T» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?T», Const.«Transfer»]), ap (Const.«objectTransferred») ([«?T», «?O»]), ap (Const.«orientation») ([«?O2», «?O», Const.«On»])]) (ap (Const.«objectTransferred») ([«?T», «?O2»]))))),
ap (Const.«subclass») ([Const.«Carrying», Const.«Transfer»]),
mkForall (fun («?CARRY» : Obj) => mkImp (ap (Const.«instance») ([«?CARRY», Const.«Carrying»])) (mkExists (fun («?ANIMAL» : Obj) => mkAnd [ap (Const.«instance») ([«?ANIMAL», Const.«Animal»]), ap (Const.«instrument») ([«?CARRY», «?ANIMAL»])]))),
ap (Const.«subclass») ([Const.«Removing», Const.«Transfer»]),
mkForall (fun («?OBJ» : Obj) => mkForall (fun («?PLACE» : Obj) => mkForall (fun («?REMOVE» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?REMOVE», Const.«Removing»]), ap (Const.«origin») ([«?REMOVE», «?PLACE»]), ap (Const.«patient») ([«?REMOVE», «?OBJ»])]) (mkAnd [ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?REMOVE»])]), ap (Const.«located») ([«?OBJ», «?PLACE»])]), ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?REMOVE»])]), mkNot (ap (Const.«located») ([«?OBJ», «?PLACE»]))])])))),
ap (Const.«subclass») ([Const.«Uncovering», Const.«Removing»]),
ap (Const.«disjoint») ([Const.«Uncovering», Const.«Covering»]),
ap (Const.«subclass») ([Const.«Putting», Const.«Transfer»]),
mkForall (fun («?OBJ» : Obj) => mkForall (fun («?PLACE» : Obj) => mkForall (fun («?PUT» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?PUT», Const.«Putting»]), ap (Const.«destination») ([«?PUT», «?PLACE»]), ap (Const.«patient») ([«?PUT», «?OBJ»])]) (mkAnd [ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?PUT»])]), mkNot (ap (Const.«located») ([«?OBJ», «?PLACE»]))]), ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?PUT»])]), ap (Const.«located») ([«?OBJ», «?PLACE»])])])))),
ap (Const.«subclass») ([Const.«Covering», Const.«Putting»]),
ap (Const.«subclass») ([Const.«Inserting», Const.«Putting»]),
mkForall (fun («?INSERT» : Obj) => mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?INSERT», Const.«Inserting»]), ap (Const.«patient») ([«?INSERT», «?OBJ1»]), ap (Const.«destination») ([«?INSERT», «?OBJ2»])]) (mkAnd [ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?INSERT»])]), mkNot (ap (Const.«contains») ([«?OBJ2», «?OBJ1»]))]), ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?INSERT»])]), ap (Const.«contains») ([«?OBJ2», «?OBJ1»])])])))),
ap (Const.«subclass») ([Const.«Injecting», Const.«Inserting»]),
mkForall (fun («?INJECT» : Obj) => mkImp (ap (Const.«instance») ([«?INJECT», Const.«Injecting»])) (mkExists (fun («?SUBSTANCE» : Obj) => mkExists (fun («?ANIMAL» : Obj) => mkAnd [ap (Const.«patient») ([«?INJECT», «?SUBSTANCE»]), ap (Const.«instance») ([«?SUBSTANCE», Const.«BiologicallyActiveSubstance»]), ap (Const.«attribute») ([«?SUBSTANCE», Const.«Liquid»]), ap (Const.«destination») ([«?INJECT», «?ANIMAL»]), ap (Const.«instance») ([«?ANIMAL», Const.«Animal»])])))),
ap (Const.«subclass») ([Const.«Substituting», Const.«Transfer»]),
ap (Const.«subclass») ([Const.«Substituting», Const.«DualObjectProcess»]),
mkForall (fun («?SUB» : Obj) => mkImp (ap (Const.«instance») ([«?SUB», Const.«Substituting»])) (mkExists (fun («?PUT» : Obj) => mkExists (fun («?REMOVE» : Obj) => mkExists (fun («?OBJ1» : Obj) => mkExists (fun («?OBJ2» : Obj) => mkExists (fun («?PLACE» : Obj) => mkAnd [ap (Const.«instance») ([«?PUT», Const.«Putting»]), ap (Const.«instance») ([«?REMOVE», Const.«Removing»]), ap (Const.«subProcess») ([«?PUT», «?SUB»]), ap (Const.«subProcess») ([«?REMOVE», «?SUB»]), ap (Const.«patient») ([«?REMOVE», «?OBJ1»]), ap (Const.«origin») ([«?REMOVE», «?PLACE»]), ap (Const.«patient») ([«?PUT», «?OBJ2»]), ap (Const.«destination») ([«?PUT», «?PLACE»]), mkNot (ap (Const.«equal») ([«?OBJ1», «?OBJ2»]))]))))))),
ap (Const.«subclass») ([Const.«Impelling», Const.«Transfer»]),
ap (Const.«subclass») ([Const.«Shooting», Const.«Impelling»]),
ap (Const.«subclass») ([Const.«Touching», Const.«Transfer»]),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkForall (fun («?TOUCH» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?TOUCH», Const.«Touching»]), ap (Const.«agent») ([«?TOUCH», «?OBJ1»]), ap (Const.«patient») ([«?TOUCH», «?OBJ2»])]) (mkAnd [ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?TOUCH»])]), mkNot (ap (Const.«connected») ([«?OBJ1», «?OBJ2»]))]), ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?TOUCH»])]), ap (Const.«connected») ([«?OBJ1», «?OBJ2»])])])))),
ap (Const.«subrelation») ([Const.«grasps», Const.«meetsSpatially»]),
ap (Const.«instance») ([Const.«grasps», Const.«BinaryPredicate»]),
ap (Const.«subclass») ([Const.«Grabbing», Const.«Touching»]),
ap (Const.«subclass») ([Const.«Grabbing», Const.«Attaching»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?GRAB» : Obj) => mkForall (fun («?THING» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?GRAB», Const.«Grabbing»]), ap (Const.«agent») ([«?GRAB», «?AGENT»]), ap (Const.«patient») ([«?GRAB», «?THING»])]) (mkAnd [ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?GRAB»])]), mkNot (ap (Const.«grasps») ([«?AGENT», «?THING»]))]), ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?GRAB»])]), ap (Const.«grasps») ([«?AGENT», «?THING»])])])))),
ap (Const.«subclass») ([Const.«Releasing», Const.«Transfer»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?GRAB» : Obj) => mkForall (fun («?RELEASE» : Obj) => mkForall (fun («?THING» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?RELEASE», Const.«Releasing»]), ap (Const.«agent») ([«?GRAB», «?AGENT»]), ap (Const.«patient») ([«?GRAB», «?THING»])]) (mkAnd [ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?RELEASE»])]), ap (Const.«grasps») ([«?AGENT», «?THING»])]), ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?RELEASE»])]), mkNot (ap (Const.«grasps») ([«?AGENT», «?THING»]))])]))))),
ap (Const.«subclass») ([Const.«Impacting», Const.«Touching»]),
mkForall (fun («?IMPACT» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?IMPACT», Const.«Impacting»]), ap (Const.«patient») ([«?IMPACT», «?OBJ»])]) (mkExists (fun («?IMPEL» : Obj) => mkAnd [ap (Const.«instance») ([«?IMPEL», Const.«Impelling»]), ap (Const.«patient») ([«?IMPEL», «?OBJ»]), ap (Const.«earlier») ([ap (Const.«WhenFn») ([«?IMPEL»]), ap (Const.«WhenFn») ([«?IMPACT»])])])))),
ap (Const.«subclass») ([Const.«Translocation», Const.«Motion»]),
mkForall (fun («?MOVEMENT» : Obj) => mkForall (fun («?PLACE1» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?MOVEMENT», Const.«Translocation»]), ap (Const.«origin») ([«?MOVEMENT», «?PLACE1»])]) (mkExists (fun («?PLACE2» : Obj) => mkExists (fun («?STAGE» : Obj) => mkAnd [ap (Const.«instance») ([«?PLACE2», Const.«Region»]), mkNot (ap (Const.«equal») ([«?PLACE1», «?PLACE2»])), ap (Const.«subProcess») ([«?STAGE», «?MOVEMENT»]), ap (Const.«located») ([«?STAGE», «?PLACE2»])]))))),
mkForall (fun («?T» : Obj) => mkImp (ap (Const.«instance») ([«?T», Const.«Translocation»])) (mkExists (fun («?O» : Obj) => mkExists (fun («?D» : Obj) => mkExists (fun («?P» : Obj) => mkAnd [ap (Const.«instance») ([«?O», Const.«Object»]), ap (Const.«instance») ([«?D», Const.«Object»]), ap (Const.«instance») ([«?P», Const.«Object»]), ap (Const.«path») ([«?T», «?P»]), ap (Const.«origin») ([«?T», «?O»]), ap (Const.«destination») ([«?T», «?D»])]))))),
ap (Const.«subclass») ([Const.«Falling», Const.«Translocation»]),
ap (Const.«subclass») ([Const.«Falling», Const.«MotionDownward»]),
mkForall (fun («?DROP» : Obj) => mkForall (fun («?FINISH» : Obj) => mkForall (fun («?START» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?DROP», Const.«Falling»]), ap (Const.«origin») ([«?DROP», «?START»]), ap (Const.«destination») ([«?DROP», «?FINISH»])]) (ap (Const.«orientation») ([«?FINISH», «?START», Const.«Below»]))))),
ap (Const.«subclass») ([Const.«Transportation», Const.«Translocation»]),
ap (Const.«relatedInternalConcept») ([Const.«Transportation», Const.«TransportationDevice»]),
mkForall (fun («?TRANS» : Obj) => mkImp (ap (Const.«instance») ([«?TRANS», Const.«Transportation»])) (mkExists (fun («?DEVICE» : Obj) => mkAnd [ap (Const.«instance») ([«?DEVICE», Const.«TransportationDevice»]), ap (Const.«instrument») ([«?TRANS», «?DEVICE»])]))),
ap (Const.«subclass») ([Const.«Guiding», Const.«IntentionalProcess»]),
ap (Const.«subclass») ([Const.«Driving», Const.«Guiding»]),
ap (Const.«subclass») ([Const.«Driving», Const.«Transportation»]),
mkForall (fun («?DRIVE» : Obj) => mkImp (ap (Const.«instance») ([«?DRIVE», Const.«Driving»])) (mkExists (fun («?VEHICLE» : Obj) => mkAnd [ap (Const.«instance») ([«?VEHICLE», Const.«Vehicle»]), ap (Const.«patient») ([«?DRIVE», «?VEHICLE»])]))),
ap (Const.«subclass») ([Const.«EducationalProcess», Const.«Guiding»]),
mkForall (fun («?EDUCATION» : Obj) => mkForall (fun («?PERSON» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?EDUCATION», Const.«EducationalProcess»]), ap (Const.«patient») ([«?EDUCATION», «?PERSON»])]) (ap (Const.«hasPurpose») ([«?EDUCATION», mkExists (fun («?LEARN» : Obj) => mkAnd [ap (Const.«instance») ([«?LEARN», Const.«Learning»]), ap (Const.«patient») ([«?LEARN», «?PERSON»])])])))),
ap (Const.«subclass») ([Const.«ChangeOfPossession», Const.«SocialInteraction»]),
ap (Const.«relatedInternalConcept») ([Const.«ChangeOfPossession», Const.«possesses»]),
mkForall (fun («?AGENT1» : Obj) => mkForall (fun («?AGENT2» : Obj) => mkForall (fun («?CHANGE» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?CHANGE», Const.«ChangeOfPossession»]), ap (Const.«patient») ([«?CHANGE», «?OBJ»]), ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?CHANGE»])]), ap (Const.«possesses») ([«?AGENT1», «?OBJ»])]), ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?CHANGE»])]), ap (Const.«possesses») ([«?AGENT2», «?OBJ»])])]) (mkNot (ap (Const.«equal») ([«?AGENT1», «?AGENT2»]))))))),
mkForall (fun («?AGENT1» : Obj) => mkForall (fun («?AGENT2» : Obj) => mkForall (fun («?CHANGE» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?CHANGE», Const.«ChangeOfPossession»]), ap (Const.«origin») ([«?CHANGE», «?AGENT1»]), ap (Const.«destination») ([«?CHANGE», «?AGENT2»]), ap (Const.«instance») ([«?AGENT1», Const.«AutonomousAgent»]), ap (Const.«instance») ([«?AGENT2», Const.«AutonomousAgent»]), ap (Const.«patient») ([«?CHANGE», «?OBJ»])]) (mkAnd [ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?CHANGE»])]), ap (Const.«possesses») ([«?AGENT1», «?OBJ»])]), ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?CHANGE»])]), ap (Const.«possesses») ([«?AGENT2», «?OBJ»])])]))))),
ap (Const.«subclass») ([Const.«Giving», Const.«ChangeOfPossession»]),
mkForall (fun («?AGENT1» : Obj) => mkForall (fun («?AGENT2» : Obj) => mkForall (fun («?GIVE» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?GIVE», Const.«Giving»]), ap (Const.«agent») ([«?GIVE», «?AGENT1»]), ap (Const.«destination») ([«?GIVE», «?AGENT2»]), ap (Const.«instance») ([«?AGENT2», Const.«AutonomousAgent»]), ap (Const.«patient») ([«?GIVE», «?OBJ»])]) (mkExists (fun («?GET» : Obj) => mkAnd [ap (Const.«instance») ([«?GET», Const.«Getting»]), ap (Const.«agent») ([«?GET», «?AGENT2»]), ap (Const.«origin») ([«?GET», «?AGENT1»]), ap (Const.«patient») ([«?GET», «?OBJ»])])))))),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?GIVE» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?GIVE», Const.«Giving»]), ap (Const.«agent») ([«?GIVE», «?AGENT»])]) (ap (Const.«origin») ([«?GIVE», «?AGENT»])))),
ap (Const.«subclass») ([Const.«Funding», Const.«Giving»]),
mkForall (fun («?FUND» : Obj) => mkImp (ap (Const.«instance») ([«?FUND», Const.«Funding»])) (mkExists (fun («?MONEY» : Obj) => mkAnd [ap (Const.«instance») ([«?MONEY», Const.«Currency»]), ap (Const.«patient») ([«?FUND», «?MONEY»])]))),
ap (Const.«subclass») ([Const.«UnilateralGiving», Const.«Giving»]),
mkForall (fun («?GIVE» : Obj) => mkImp (ap (Const.«instance») ([«?GIVE», Const.«UnilateralGiving»])) (mkNot (mkExists (fun («?TRANS» : Obj) => mkAnd [ap (Const.«instance») ([«?TRANS», Const.«Transaction»]), ap (Const.«subProcess») ([«?GIVE», «?TRANS»])])))),
ap (Const.«subclass») ([Const.«Lending», Const.«Giving»]),
mkForall (fun («?AGENT1» : Obj) => mkForall (fun («?AGENT2» : Obj) => mkForall (fun («?BORROW» : Obj) => mkForall (fun («?OBJECT» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?BORROW», Const.«Borrowing»]), ap (Const.«agent») ([«?BORROW», «?AGENT1»]), ap (Const.«origin») ([«?BORROW», «?AGENT2»]), ap (Const.«patient») ([«?BORROW», «?OBJECT»])]) (mkExists (fun («?LEND» : Obj) => mkAnd [ap (Const.«instance») ([«?LEND», Const.«Lending»]), ap (Const.«agent») ([«?LEND», «?AGENT2»]), ap (Const.«destination») ([«?LEND», «?AGENT1»]), ap (Const.«patient») ([«?LEND», «?OBJECT»])])))))),
mkForall (fun («?AGENT1» : Obj) => mkForall (fun («?AGENT2» : Obj) => mkForall (fun («?LEND» : Obj) => mkForall (fun («?OBJECT» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?LEND», Const.«Lending»]), ap (Const.«agent») ([«?LEND», «?AGENT2»]), ap (Const.«destination») ([«?LEND», «?AGENT1»]), ap (Const.«patient») ([«?LEND», «?OBJECT»])]) (mkExists (fun («?BORROW» : Obj) => mkAnd [ap (Const.«instance») ([«?BORROW», Const.«Borrowing»]), ap (Const.«agent») ([«?BORROW», «?AGENT1»]), ap (Const.«origin») ([«?BORROW», «?AGENT2»]), ap (Const.«patient») ([«?BORROW», «?OBJECT»])])))))),
ap (Const.«subclass») ([Const.«GivingBack», Const.«Giving»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?DEST» : Obj) => mkForall (fun («?RETURN» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?RETURN», Const.«GivingBack»]), ap (Const.«agent») ([«?RETURN», «?AGENT»]), ap (Const.«destination») ([«?RETURN», «?DEST»])]) (mkExists (fun («?GIVE» : Obj) => mkAnd [ap (Const.«instance») ([«?GIVE», Const.«Giving»]), ap (Const.«agent») ([«?GIVE», «?DEST»]), ap (Const.«destination») ([«?GIVE», «?AGENT»]), ap (Const.«earlier») ([ap (Const.«WhenFn») ([«?GIVE»]), ap (Const.«WhenFn») ([«?RETURN»])])]))))),
ap (Const.«subclass») ([Const.«Getting», Const.«ChangeOfPossession»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?GET» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?GET», Const.«Getting»]), ap (Const.«agent») ([«?GET», «?AGENT»])]) (ap (Const.«destination») ([«?GET», «?AGENT»])))),
ap (Const.«subclass») ([Const.«UnilateralGetting», Const.«Getting»]),
ap (Const.«relatedInternalConcept») ([Const.«UnilateralGetting», Const.«UnilateralGiving»]),
mkForall (fun («?GET» : Obj) => mkImp (ap (Const.«instance») ([«?GET», Const.«UnilateralGetting»])) (mkNot (mkExists (fun («?TRANS» : Obj) => mkAnd [ap (Const.«instance») ([«?TRANS», Const.«Transaction»]), ap (Const.«subProcess») ([«?GET», «?TRANS»])])))),
ap (Const.«subclass») ([Const.«Borrowing», Const.«Getting»]),
ap (Const.«subclass») ([Const.«Transaction», Const.«ChangeOfPossession»]),
ap (Const.«subclass») ([Const.«Transaction», Const.«DualObjectProcess»]),
mkForall (fun («?TRANS» : Obj) => mkImp (ap (Const.«instance») ([«?TRANS», Const.«Transaction»])) (mkExists (fun («?AGENT1» : Obj) => mkExists (fun («?AGENT2» : Obj) => mkExists (fun («?GIVE1» : Obj) => mkExists (fun («?GIVE2» : Obj) => mkExists (fun («?OBJ1» : Obj) => mkExists (fun («?OBJ2» : Obj) => mkAnd [ap (Const.«instance») ([«?GIVE1», Const.«Giving»]), ap (Const.«instance») ([«?GIVE2», Const.«Giving»]), ap (Const.«subProcess») ([«?GIVE1», «?TRANS»]), ap (Const.«subProcess») ([«?GIVE2», «?TRANS»]), ap (Const.«agent») ([«?GIVE1», «?AGENT1»]), ap (Const.«agent») ([«?GIVE2», «?AGENT2»]), ap (Const.«patient») ([«?GIVE1», «?OBJ1»]), ap (Const.«patient») ([«?GIVE2», «?OBJ2»]), ap (Const.«destination») ([«?GIVE1», «?AGENT2»]), ap (Const.«destination») ([«?GIVE2», «?AGENT1»]), mkNot (ap (Const.«equal») ([«?AGENT1», «?AGENT2»])), mkNot (ap (Const.«equal») ([«?OBJ1», «?OBJ2»]))])))))))),
ap (Const.«subclass») ([Const.«FinancialTransaction», Const.«Transaction»]),
mkForall (fun («?TRANS» : Obj) => mkImp (ap (Const.«instance») ([«?TRANS», Const.«FinancialTransaction»])) (mkExists (fun («?OBJ» : Obj) => mkAnd [ap (Const.«patient») ([«?TRANS», «?OBJ»]), ap (Const.«instance») ([«?OBJ», Const.«FinancialInstrument»])]))),
ap (Const.«instance») ([Const.«transactionAmount», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«transactionAmount», Const.«SingleValuedRelation»]),
ap (Const.«instance») ([Const.«transactionAmount», Const.«TotalValuedRelation»]),
mkForall (fun («?AMOUNT» : Obj) => mkForall (fun («?TRANS» : Obj) => mkImp (ap (Const.«transactionAmount») ([«?TRANS», «?AMOUNT»])) (mkExists (fun («?OBJ» : Obj) => mkAnd [ap (Const.«patient») ([«?TRANS», «?OBJ»]), ap (Const.«monetaryValue») ([«?OBJ», «?AMOUNT»])])))),
ap (Const.«subclass») ([Const.«ServiceProcess», Const.«SocialInteraction»]),
ap (Const.«subclass») ([Const.«CommercialService», Const.«FinancialTransaction»]),
ap (Const.«subclass») ([Const.«CommercialService», Const.«ServiceProcess»]),
mkForall (fun («?BUSINESS» : Obj) => mkImp (ap (Const.«instance») ([«?BUSINESS», Const.«CommercialService»])) (mkExists (fun («?AGENT» : Obj) => mkAnd [ap (Const.«instance») ([«?AGENT», Const.«CommercialAgent»]), ap (Const.«agent») ([«?BUSINESS», «?AGENT»])]))),
ap (Const.«subclass») ([Const.«Betting», Const.«FinancialTransaction»]),
ap (Const.«subclass») ([Const.«Buying», Const.«FinancialTransaction»]),
ap (Const.«relatedInternalConcept») ([Const.«Buying», Const.«Selling»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?BUY» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?BUY», Const.«Buying»]), ap (Const.«agent») ([«?BUY», «?AGENT»])]) (ap (Const.«destination») ([«?BUY», «?AGENT»])))),
ap (Const.«subclass») ([Const.«Selling», Const.«FinancialTransaction»]),
mkForall (fun («?AGENT1» : Obj) => mkForall (fun («?AGENT2» : Obj) => mkForall (fun («?BUY» : Obj) => mkForall (fun («?OBJECT» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?BUY», Const.«Buying»]), ap (Const.«agent») ([«?BUY», «?AGENT1»]), ap (Const.«origin») ([«?BUY», «?AGENT2»]), ap (Const.«patient») ([«?BUY», «?OBJECT»])]) (mkExists (fun («?SELL» : Obj) => mkAnd [ap (Const.«instance») ([«?SELL», Const.«Selling»]), ap (Const.«agent») ([«?SELL», «?AGENT2»]), ap (Const.«destination») ([«?SELL», «?AGENT1»]), ap (Const.«patient») ([«?SELL», «?OBJECT»])])))))),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?SELL» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?SELL», Const.«Selling»]), ap (Const.«agent») ([«?SELL», «?AGENT»])]) (ap (Const.«origin») ([«?SELL», «?AGENT»])))),
ap (Const.«subclass») ([Const.«Learning», Const.«IntentionalPsychologicalProcess»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?LEARN» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?LEARN», Const.«Learning»]), ap (Const.«agent») ([«?LEARN», «?AGENT»])]) (ap (Const.«instance») ([«?AGENT», Const.«CognitiveAgent»])))),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?LEARN» : Obj) => mkForall (fun («?PROP» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?LEARN», Const.«Learning»]), ap (Const.«agent») ([«?LEARN», «?AGENT»]), ap (Const.«patient») ([«?LEARN», «?PROP»])]) (mkAnd [ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?LEARN»])]), mkNot (ap (Const.«knows») ([«?AGENT», «?PROP»]))]), ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?LEARN»])]), ap (Const.«knows») ([«?AGENT», «?PROP»])])])))),
ap (Const.«subclass») ([Const.«Discovering», Const.«IntentionalPsychologicalProcess»]),
mkForall (fun («?DISCOVER» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?DISCOVER», Const.«Discovering»]), ap (Const.«patient») ([«?DISCOVER», «?OBJ»])]) (mkExists (fun («?PURSUE» : Obj) => mkAnd [ap (Const.«instance») ([«?PURSUE», Const.«Pursuing»]), ap (Const.«meetsTemporally») ([ap (Const.«WhenFn») ([«?PURSUE»]), ap (Const.«WhenFn») ([«?DISCOVER»])])])))),
mkForall (fun («?A» : Obj) => mkForall (fun («?DISCOVER» : Obj) => mkForall (fun («?DISCOVERING» : Obj) => mkForall (fun («?OBJ» : Obj) => mkForall (fun («?PLACE» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?DISCOVER», Const.«Discovering»]), ap (Const.«agent») ([«?DISCOVER», «?A»]), ap (Const.«patient») ([«?DISCOVER», «?OBJ»]), ap (Const.«holdsDuring») ([ap (Const.«WhenFn») ([«?DISCOVER»]), ap (Const.«located») ([«?OBJ», «?PLACE»])])]) (ap (Const.«holdsDuring») ([ap (Const.«ImmediateFutureFn») ([«?DISCOVERING»]), ap (Const.«knows») ([«?A», ap (Const.«located») ([«?OBJ», «?PLACE»])])]))))))),
ap (Const.«subclass») ([Const.«Classifying», Const.«IntentionalPsychologicalProcess»]),
ap (Const.«subclass») ([Const.«Reasoning», Const.«IntentionalPsychologicalProcess»]),
mkForall (fun («?AGENT» : Obj) => mkImp (ap (Const.«instance») ([«?AGENT», Const.«CognitiveAgent»])) (ap (Const.«capability») ([Const.«Reasoning», Const.«agent», «?AGENT»]))),
ap (Const.«subclass») ([Const.«Selecting», Const.«IntentionalPsychologicalProcess»]),
ap (Const.«subclass») ([Const.«Deciding», Const.«Selecting»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?DECIDE» : Obj) => mkForall (fun («?M» : Obj) => mkForall (fun («?S» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?DECIDE», Const.«Deciding»]), ap (Const.«agent») ([«?DECIDE», «?AGENT»]), ap (Const.«instance») ([«?S», Const.«Set»]), ap (Const.«patient») ([«?DECIDE», «?S»]), ap (Const.«element») ([«?M», «?S»])]) (ap (Const.«believes») ([«?AGENT», mkExists (fun («?CLASS» : Obj) => mkAnd [ap (Const.«instance») ([«?M», «?CLASS»]), ap (Const.«subclass») ([«?CLASS», Const.«IntentionalProcess»]), ap (Const.«capability») ([«?CLASS», Const.«agent», «?AGENT»])])])))))),
mkForall (fun («?A» : Obj) => mkForall (fun («?DECIDE» : Obj) => mkForall (fun («?S» : Obj) => mkForall (fun («?X» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?DECIDE», Const.«Deciding»]), ap (Const.«agent») ([«?DECIDE», «?A»]), ap (Const.«patient») ([«?DECIDE», «?S»]), ap (Const.«instance») ([«?S», Const.«Set»]), ap (Const.«result») ([«?DECIDE», «?X»]), ap (Const.«instance») ([«?X», Const.«ContentBearingPhysical»])]) (ap (Const.«containsFormula») ([«?X», ap (Const.«holdsDuring») ([ap (Const.«FutureFn») ([ap (Const.«WhenFn») ([«?DECIDE»])]), mkExists (fun («?M» : Obj) => mkAnd [ap (Const.«element») ([«?M», «?S»]), ap (Const.«instance») ([«?M», Const.«IntentionalProcess»]), ap (Const.«agent») ([«?M», «?A»])])])])))))),
ap (Const.«subclass») ([Const.«Voting», Const.«Selecting»]),
mkForall (fun («?VOTE» : Obj) => mkImp (ap (Const.«instance») ([«?VOTE», Const.«Voting»])) (mkExists (fun («?ELECT» : Obj) => mkAnd [ap (Const.«instance») ([«?ELECT», Const.«Election»]), ap (Const.«subProcess») ([«?VOTE», «?ELECT»])]))),
ap (Const.«subclass») ([Const.«Judging», Const.«Selecting»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?JUDGE» : Obj) => mkForall (fun («?P» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?JUDGE», Const.«Judging»]), ap (Const.«agent») ([«?JUDGE», «?AGENT»]), ap (Const.«result») ([«?JUDGE», «?P»])]) (mkAnd [ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?JUDGE»])]), mkNot (ap (Const.«believes») ([«?AGENT», «?P»]))]), ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?JUDGE»])]), ap (Const.«believes») ([«?AGENT», «?P»])])])))),
ap (Const.«subclass») ([Const.«Comparing», Const.«IntentionalPsychologicalProcess»]),
ap (Const.«subclass») ([Const.«Comparing», Const.«DualObjectProcess»]),
ap (Const.«subclass») ([Const.«Calculating», Const.«IntentionalPsychologicalProcess»]),
ap (Const.«subclass») ([Const.«Measuring», Const.«Calculating»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?MEAS» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?MEAS», Const.«Measuring»]), ap (Const.«agent») ([«?MEAS», «?AGENT»]), ap (Const.«patient») ([«?MEAS», «?OBJ»])]) (mkExists (fun («?QUANT» : Obj) => mkExists (fun («?UNIT» : Obj) => ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?MEAS»])]), ap (Const.«knows») ([«?AGENT», ap (Const.«measure») ([«?OBJ», ap (Const.«MeasureFn») ([«?QUANT», «?UNIT»])])])]))))))),
ap (Const.«subclass») ([Const.«Counting», Const.«Calculating»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?COUNT» : Obj) => mkForall (fun («?ENTITY» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?COUNT», Const.«Counting»]), ap (Const.«agent») ([«?COUNT», «?AGENT»]), ap (Const.«patient») ([«?COUNT», «?ENTITY»])]) (mkExists (fun («?NUMBER» : Obj) => ap (Const.«knows») ([«?AGENT», ap (Const.«equal») ([ap (Const.«CardinalityFn») ([«?ENTITY»]), «?NUMBER»])])))))),
ap (Const.«subclass») ([Const.«Predicting», Const.«IntentionalPsychologicalProcess»]),
mkForall (fun («?FORMULA» : Obj) => mkForall (fun («?PREDICT» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?PREDICT», Const.«Predicting»]), ap (Const.«patient») ([«?PREDICT», «?FORMULA»])]) (mkExists (fun («?TIME» : Obj) => mkAnd [ap (Const.«holdsDuring») ([«?TIME», «?FORMULA»]), ap (Const.«earlier») ([«?TIME», ap (Const.«WhenFn») ([«?PREDICT»])])])))),
ap (Const.«subclass») ([Const.«Remembering», Const.«PsychologicalProcess»]),
mkForall (fun («?FORMULA» : Obj) => mkForall (fun («?REMEMBER» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?REMEMBER», Const.«Remembering»]), ap (Const.«patient») ([«?REMEMBER», «?FORMULA»])]) (mkExists (fun («?TIME» : Obj) => mkAnd [ap (Const.«holdsDuring») ([«?TIME», «?FORMULA»]), mkOr [ap (Const.«before») ([«?TIME», ap (Const.«WhenFn») ([«?REMEMBER»])]), ap (Const.«earlier») ([«?TIME», ap (Const.«WhenFn») ([«?REMEMBER»])])]])))),
ap (Const.«subclass») ([Const.«Keeping», Const.«IntentionalProcess»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?KEEP» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?KEEP», Const.«Keeping»]), ap (Const.«agent») ([«?KEEP», «?AGENT»]), ap (Const.«patient») ([«?KEEP», «?OBJ»])]) (mkExists (fun («?PUT» : Obj) => mkAnd [ap (Const.«instance») ([«?PUT», Const.«Putting»]), ap (Const.«agent») ([«?PUT», «?AGENT»]), ap (Const.«patient») ([«?PUT», «?OBJ»]), ap (Const.«earlier») ([ap (Const.«WhenFn») ([«?PUT»]), ap (Const.«WhenFn») ([«?KEEP»])])]))))),
mkForall (fun («?KEEP» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?KEEP», Const.«Keeping»]), ap (Const.«patient») ([«?KEEP», «?OBJ»])]) (mkExists (fun («?PLACE» : Obj) => mkForall (fun («?TIME» : Obj) => mkImp (ap (Const.«temporalPart») ([«?TIME», ap (Const.«WhenFn») ([«?KEEP»])])) (ap (Const.«holdsDuring») ([«?TIME», ap (Const.«located») ([«?OBJ», «?PLACE»])]))))))),
ap (Const.«subclass») ([Const.«Confining», Const.«Keeping»]),
mkForall (fun («?CONFINE» : Obj) => mkImp (ap (Const.«instance») ([«?CONFINE», Const.«Confining»])) (mkExists (fun («?AGENT» : Obj) => mkAnd [ap (Const.«instance») ([«?AGENT», Const.«Animal»]), ap (Const.«patient») ([«?CONFINE», «?AGENT»])]))),
mkForall (fun («?CONFINE» : Obj) => mkForall (fun («?PERSON» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?CONFINE», Const.«Confining»]), ap (Const.«patient») ([«?CONFINE», «?PERSON»]), ap (Const.«instance») ([«?PERSON», Const.«Human»])]) (mkNot (ap (Const.«desires») ([«?PERSON», ap (Const.«patient») ([«?CONFINE», «?PERSON»])]))))),
ap (Const.«subclass») ([Const.«Maintaining», Const.«IntentionalProcess»]),
ap (Const.«subclass») ([Const.«Repairing», Const.«IntentionalProcess»]),
ap (Const.«relatedInternalConcept») ([Const.«Repairing», Const.«Maintaining»]),
mkForall (fun («?OBJ» : Obj) => mkForall (fun («?REPAIR» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?REPAIR», Const.«Repairing»]), ap (Const.«patient») ([«?REPAIR», «?OBJ»])]) (mkExists (fun («?DAMAGE» : Obj) => mkAnd [ap (Const.«instance») ([«?DAMAGE», Const.«Damaging»]), ap (Const.«patient») ([«?DAMAGE», «?OBJ»]), ap (Const.«earlier») ([ap (Const.«WhenFn») ([«?DAMAGE»]), ap (Const.«WhenFn») ([«?REPAIR»])])])))),
ap (Const.«subclass») ([Const.«TherapeuticProcess», Const.«Repairing»]),
mkForall (fun («?BIO» : Obj) => mkForall (fun («?PROC» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?PROC», Const.«TherapeuticProcess»]), ap (Const.«patient») ([«?PROC», «?BIO»])]) (mkOr [ap (Const.«instance») ([«?BIO», Const.«Organism»]), mkExists (fun («?ORG» : Obj) => mkAnd [ap (Const.«instance») ([«?ORG», Const.«Organism»]), ap (Const.«part») ([«?BIO», «?ORG»])])]))),
ap (Const.«subclass») ([Const.«Surgery», Const.«TherapeuticProcess»]),
mkForall (fun («?ACT» : Obj) => mkForall (fun («?ANIMAL» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?ACT», Const.«Surgery»]), ap (Const.«patient») ([«?ACT», «?ANIMAL»])]) (mkExists (fun («?SUBACT» : Obj) => mkAnd [ap (Const.«instance») ([«?SUBACT», Const.«Cutting»]), ap (Const.«instance») ([«?ANIMAL», Const.«Animal»]), ap (Const.«patient») ([«?SUBACT», «?ANIMAL»]), ap (Const.«subProcess») ([«?SUBACT», «?ACT»])])))),
ap (Const.«subclass») ([Const.«Damaging», Const.«InternalChange»]),
ap (Const.«disjoint») ([Const.«Damaging», Const.«Repairing»]),
ap (Const.«subclass») ([Const.«Destruction», Const.«Damaging»]),
mkForall (fun («?PROCESS» : Obj) => mkImp (ap (Const.«instance») ([«?PROCESS», Const.«Destruction»])) (mkExists (fun («?PATIENT» : Obj) => mkAnd [ap (Const.«patient») ([«?PROCESS», «?PATIENT»]), ap (Const.«time») ([«?PATIENT», ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?PROCESS»])])]), mkNot (ap (Const.«time») ([«?PATIENT», ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?PROCESS»])])]))]))),
ap (Const.«subclass») ([Const.«Killing», Const.«Destruction»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?KILL» : Obj) => mkForall (fun («?PATIENT» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?KILL», Const.«Killing»]), ap (Const.«agent») ([«?KILL», «?AGENT»]), ap (Const.«patient») ([«?KILL», «?PATIENT»])]) (mkAnd [ap (Const.«instance») ([«?AGENT», Const.«Organism»]), ap (Const.«instance») ([«?PATIENT», Const.«Organism»])])))),
mkForall (fun («?KILL» : Obj) => mkForall (fun («?PATIENT» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?KILL», Const.«Killing»]), ap (Const.«patient») ([«?KILL», «?PATIENT»])]) (mkAnd [ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?KILL»])]), ap (Const.«attribute») ([«?PATIENT», Const.«Living»])]), ap (Const.«holdsDuring») ([ap (Const.«FutureFn») ([ap (Const.«WhenFn») ([«?KILL»])]), ap (Const.«attribute») ([«?PATIENT», Const.«Dead»])])]))),
mkForall (fun («?KILL» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?KILL», Const.«Killing»]), ap (Const.«patient») ([«?KILL», «?OBJ»])]) (mkExists (fun («?DEATH» : Obj) => mkAnd [ap (Const.«instance») ([«?DEATH», Const.«Death»]), ap (Const.«experiencer») ([«?DEATH», «?OBJ»]), ap (Const.«causes») ([«?KILL», «?DEATH»])])))),
mkForall (fun («?O» : Obj) => mkImp (ap (Const.«instance») ([«?O», Const.«Organism»])) (ap (Const.«capability») ([Const.«Killing», Const.«agent», «?O»]))),
mkForall (fun («?O» : Obj) => mkImp (ap (Const.«instance») ([«?O», Const.«Organism»])) (ap (Const.«capability») ([Const.«Killing», Const.«patient», «?O»]))),
ap (Const.«subclass») ([Const.«Poking», Const.«IntentionalProcess»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?INST» : Obj) => mkForall (fun («?OBJ» : Obj) => mkForall (fun («?POKE» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?POKE», Const.«Poking»]), ap (Const.«agent») ([«?POKE», «?AGENT»]), ap (Const.«patient») ([«?POKE», «?OBJ»]), ap (Const.«instrument») ([«?POKE», «?INST»])]) (ap (Const.«holdsDuring») ([ap (Const.«WhenFn») ([«?POKE»]), ap (Const.«connects») ([«?INST», «?AGENT», «?OBJ»])])))))),
ap (Const.«subclass») ([Const.«Cutting», Const.«Poking»]),
ap (Const.«subclass») ([Const.«Attaching», Const.«DualObjectProcess»]),
ap (Const.«disjoint») ([Const.«Attaching», Const.«Detaching»]),
ap (Const.«relatedInternalConcept») ([Const.«Attaching», Const.«Putting»]),
mkForall (fun («?ATTACH» : Obj) => mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?ATTACH», Const.«Attaching»]), ap (Const.«patient») ([«?ATTACH», «?OBJ1»]), ap (Const.«patient») ([«?ATTACH», «?OBJ2»])]) (mkAnd [ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?ATTACH»])]), mkNot (ap (Const.«connected») ([«?OBJ1», «?OBJ2»]))]), ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?ATTACH»])]), ap (Const.«connected») ([«?OBJ1», «?OBJ2»])])])))),
mkForall (fun («?ATTACH» : Obj) => mkImp (ap (Const.«instance») ([«?ATTACH», Const.«Attaching»])) (mkExists (fun («?OBJ» : Obj) => mkAnd [ap (Const.«instance») ([«?OBJ», Const.«CorpuscularObject»]), ap (Const.«patient») ([«?ATTACH», «?OBJ»])]))),
ap (Const.«instance») ([Const.«objectAttached», Const.«CaseRole»]),
ap (Const.«subrelation») ([Const.«objectAttached», Const.«patient»]),
mkForall (fun («?A» : Obj) => mkForall (fun («?O1» : Obj) => mkForall (fun («?O2» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?A», Const.«Attaching»]), ap (Const.«patient») ([«?A», «?O1»]), ap (Const.«patient») ([«?A», «?O2»]), ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?A»])]), mkNot (ap (Const.«connected») ([«?O1», «?O2»]))]), ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?A»])]), ap (Const.«connected») ([«?O1», «?O2»])])]) (mkAnd [ap (Const.«objectAttached») ([«?A», «?O1»]), ap (Const.«objectAttached») ([«?A», «?O2»])])))),
ap (Const.«subclass») ([Const.«Detaching», Const.«DualObjectProcess»]),
mkForall (fun («?DETACH» : Obj) => mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?DETACH», Const.«Detaching»]), ap (Const.«patient») ([«?DETACH», «?OBJ1»]), ap (Const.«patient») ([«?DETACH», «?OBJ2»])]) (mkAnd [ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?DETACH»])]), ap (Const.«connected») ([«?OBJ1», «?OBJ2»])]), ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?DETACH»])]), mkNot (ap (Const.«connected») ([«?OBJ1», «?OBJ2»]))])])))),
mkForall (fun («?DETACH» : Obj) => mkImp (ap (Const.«instance») ([«?DETACH», Const.«Detaching»])) (mkExists (fun («?OBJ» : Obj) => mkAnd [ap (Const.«instance») ([«?OBJ», Const.«CorpuscularObject»]), ap (Const.«patient») ([«?DETACH», «?OBJ»])]))),
ap (Const.«instance») ([Const.«objectDetached», Const.«CaseRole»]),
ap (Const.«subrelation») ([Const.«objectDetached», Const.«patient»]),
mkForall (fun («?A» : Obj) => mkForall (fun («?D» : Obj) => mkForall (fun («?O1» : Obj) => mkForall (fun («?O2» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?D», Const.«Detaching»]), ap (Const.«patient») ([«?D», «?O1»]), ap (Const.«patient») ([«?D», «?O2»]), ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?D»])]), ap (Const.«connected») ([«?O1», «?O2»])]), ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?A»])]), mkNot (ap (Const.«connected») ([«?O1», «?O2»]))])]) (mkAnd [ap (Const.«objectDetached») ([«?A», «?O1»]), ap (Const.«objectDetached») ([«?A», «?O2»])]))))),
ap (Const.«subclass») ([Const.«Ungrasping», Const.«Detaching»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?GRAB» : Obj) => mkForall (fun («?RELEASE» : Obj) => mkForall (fun («?THING» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?RELEASE», Const.«Ungrasping»]), ap (Const.«agent») ([«?GRAB», «?AGENT»]), ap (Const.«patient») ([«?GRAB», «?THING»])]) (mkAnd [ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?RELEASE»])]), ap (Const.«grasps») ([«?AGENT», «?THING»])]), ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?RELEASE»])]), mkNot (ap (Const.«grasps») ([«?AGENT», «?THING»]))])]))))),
ap (Const.«subclass») ([Const.«Combining», Const.«DualObjectProcess»]),
mkForall (fun («?COMBINE» : Obj) => mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkIff (mkAnd [ap (Const.«instance») ([«?COMBINE», Const.«Combining»]), ap (Const.«resource») ([«?COMBINE», «?OBJ1»]), ap (Const.«result») ([«?COMBINE», «?OBJ2»])]) (mkAnd [ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?COMBINE»])]), mkNot (ap (Const.«part») ([«?OBJ1», «?OBJ2»]))]), ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?COMBINE»])]), ap (Const.«part») ([«?OBJ1», «?OBJ2»])])])))),
mkForall (fun («?COMBINE» : Obj) => mkImp (ap (Const.«instance») ([«?COMBINE», Const.«Combining»])) (mkExists (fun («?OBJ» : Obj) => mkAnd [ap (Const.«instance») ([«?OBJ», Const.«SelfConnectedObject»]), ap (Const.«patient») ([«?COMBINE», «?OBJ»])]))),
ap (Const.«subclass») ([Const.«Separating», Const.«DualObjectProcess»]),
ap (Const.«disjoint») ([Const.«Separating», Const.«Combining»]),
mkForall (fun («?SEPARATE» : Obj) => mkImp (ap (Const.«instance») ([«?SEPARATE», Const.«Separating»])) (mkExists (fun («?OBJ» : Obj) => mkAnd [ap (Const.«instance») ([«?OBJ», Const.«SelfConnectedObject»]), ap (Const.«patient») ([«?SEPARATE», «?OBJ»])]))),
ap (Const.«subclass») ([Const.«Breaking», Const.«Damaging»]),
ap (Const.«subclass») ([Const.«Breaking», Const.«Separating»]),
ap (Const.«subclass») ([Const.«ChemicalProcess», Const.«InternalChange»]),
ap (Const.«partition») ([Const.«ChemicalProcess», Const.«ChemicalSynthesis», Const.«ChemicalDecomposition»]),
mkForall (fun («?PROC» : Obj) => mkForall (fun («?STUFF» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?PROC», Const.«ChemicalProcess»]), mkOr [ap (Const.«resource») ([«?PROC», «?STUFF»]), ap (Const.«result») ([«?PROC», «?STUFF»])]]) (ap (Const.«instance») ([«?STUFF», Const.«PureSubstance»])))),
ap (Const.«subclass») ([Const.«ChemicalSynthesis», Const.«ChemicalProcess»]),
ap (Const.«subclass») ([Const.«ChemicalSynthesis», Const.«Combining»]),
mkForall (fun («?PROC» : Obj) => mkForall (fun («?SUBSTANCE1» : Obj) => mkForall (fun («?SUBSTANCE2» : Obj) => mkImp (mkAnd [ap (Const.«resource») ([«?PROC», «?SUBSTANCE1»]), ap (Const.«result») ([«?PROC», «?SUBSTANCE2»]), ap (Const.«instance») ([«?SUBSTANCE1», Const.«ElementalSubstance»]), ap (Const.«instance») ([«?SUBSTANCE2», Const.«CompoundSubstance»])]) (ap (Const.«instance») ([«?PROC», Const.«ChemicalSynthesis»]))))),
mkForall (fun («?COMPOUND» : Obj) => mkImp (ap (Const.«instance») ([«?COMPOUND», Const.«CompoundSubstance»])) (mkExists (fun («?ELEMENT1» : Obj) => mkExists (fun («?ELEMENT2» : Obj) => mkExists (fun («?PROCESS» : Obj) => mkAnd [ap (Const.«instance») ([«?ELEMENT1», Const.«ElementalSubstance»]), ap (Const.«instance») ([«?ELEMENT2», Const.«ElementalSubstance»]), mkNot (ap (Const.«equal») ([«?ELEMENT1», «?ELEMENT2»])), ap (Const.«instance») ([«?PROCESS», Const.«ChemicalSynthesis»]), ap (Const.«resource») ([«?PROCESS», «?ELEMENT1»]), ap (Const.«resource») ([«?PROCESS», «?ELEMENT2»]), ap (Const.«result») ([«?PROCESS», «?COMPOUND»])]))))),
mkForall (fun («?COMPOUND» : Obj) => mkForall (fun («?ELEMENT1» : Obj) => mkForall (fun («?ELEMENT2» : Obj) => mkForall (fun («?PROCESS» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?ELEMENT1», Const.«ElementalSubstance»]), ap (Const.«instance») ([«?ELEMENT2», Const.«ElementalSubstance»]), mkNot (ap (Const.«equal») ([«?ELEMENT1», «?ELEMENT2»])), ap (Const.«instance») ([«?PROCESS», Const.«ChemicalSynthesis»]), ap (Const.«resource») ([«?PROCESS», «?ELEMENT1»]), ap (Const.«resource») ([«?PROCESS», «?ELEMENT2»]), ap (Const.«result») ([«?PROCESS», «?COMPOUND»])]) (ap (Const.«instance») ([«?COMPOUND», Const.«CompoundSubstance»])))))),
ap (Const.«subclass») ([Const.«ChemicalDecomposition», Const.«ChemicalProcess»]),
ap (Const.«subclass») ([Const.«ChemicalDecomposition», Const.«Separating»]),
mkForall (fun («?PROC» : Obj) => mkForall (fun («?SUBSTANCE1» : Obj) => mkForall (fun («?SUBSTANCE2» : Obj) => mkImp (mkAnd [ap (Const.«resource») ([«?PROC», «?SUBSTANCE1»]), ap (Const.«result») ([«?PROC», «?SUBSTANCE2»]), ap (Const.«instance») ([«?SUBSTANCE1», Const.«CompoundSubstance»]), ap (Const.«instance») ([«?SUBSTANCE2», Const.«ElementalSubstance»])]) (ap (Const.«instance») ([«?PROC», Const.«ChemicalDecomposition»]))))),
ap (Const.«subclass») ([Const.«Combustion», Const.«ChemicalDecomposition»]),
mkForall (fun («?COMBUSTION» : Obj) => mkImp (ap (Const.«instance») ([«?COMBUSTION», Const.«Combustion»])) (mkExists (fun («?HEAT» : Obj) => mkExists (fun («?LIGHT» : Obj) => mkAnd [ap (Const.«instance») ([«?HEAT», Const.«Heating»]), ap (Const.«instance») ([«?LIGHT», Const.«RadiatingLight»]), ap (Const.«subProcess») ([«?HEAT», «?COMBUSTION»]), ap (Const.«subProcess») ([«?LIGHT», «?COMBUSTION»])])))),
ap (Const.«instance») ([Const.«Flammable», Const.«PhysicalAttribute»]),
mkForall (fun («?X» : Obj) => mkImp (ap (Const.«attribute») ([«?X», Const.«Flammable»])) (ap (Const.«capability») ([Const.«Combustion», Const.«patient», «?X»]))),
ap (Const.«subclass») ([Const.«InternalChange», Const.«Process»]),
mkForall (fun («?CHANGE» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?CHANGE», Const.«InternalChange»]), ap (Const.«patient») ([«?CHANGE», «?OBJ»])]) (mkExists (fun («?PROPERTY» : Obj) => mkOr [mkAnd [ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?CHANGE»])]), ap (Const.«attribute») ([«?OBJ», «?PROPERTY»])]), ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?CHANGE»])]), mkNot (ap (Const.«attribute») ([«?OBJ», «?PROPERTY»]))])], mkAnd [ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?CHANGE»])]), mkNot (ap (Const.«attribute») ([«?OBJ», «?PROPERTY»]))]), ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?CHANGE»])]), ap (Const.«attribute») ([«?OBJ», «?PROPERTY»])])]])))),
ap (Const.«subclass») ([Const.«SurfaceChange», Const.«InternalChange»]),
mkForall (fun («?ALT» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?ALT», Const.«SurfaceChange»]), ap (Const.«patient») ([«?ALT», «?OBJ»])]) (mkExists (fun («?PART» : Obj) => mkExists (fun («?PROPERTY» : Obj) => mkAnd [ap (Const.«superficialPart») ([«?PART», «?OBJ»]), mkOr [mkAnd [ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?ALT»])]), ap (Const.«attribute») ([«?PART», «?PROPERTY»])]), ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?ALT»])]), mkNot (ap (Const.«attribute») ([«?PART», «?PROPERTY»]))])], mkAnd [ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?ALT»])]), mkNot (ap (Const.«attribute») ([«?PART», «?PROPERTY»]))]), ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?ALT»])]), ap (Const.«attribute») ([«?PART», «?PROPERTY»])])]]]))))),
ap (Const.«subclass») ([Const.«Coloring», Const.«SurfaceChange»]),
mkForall (fun («?COLORING» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?COLORING», Const.«Coloring»]), ap (Const.«patient») ([«?COLORING», «?OBJ»])]) (mkExists (fun («?PROPERTY» : Obj) => mkExists (fun («?PART» : Obj) => mkAnd [ap (Const.«part») ([«?PART», «?OBJ»]), ap (Const.«instance») ([«?PROPERTY», Const.«ColorAttribute»]), mkOr [mkAnd [ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?COLORING»])]), ap (Const.«attribute») ([«?PART», «?PROPERTY»])]), ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?COLORING»])]), mkNot (ap (Const.«attribute») ([«?PART», «?PROPERTY»]))])], mkAnd [ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?COLORING»])]), mkNot (ap (Const.«attribute») ([«?PART», «?PROPERTY»]))]), ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?COLORING»])]), ap (Const.«attribute») ([«?PART», «?PROPERTY»])])]]]))))),
ap (Const.«subclass») ([Const.«ShapeChange», Const.«InternalChange»]),
mkForall (fun («?ALT» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?ALT», Const.«ShapeChange»]), ap (Const.«patient») ([«?ALT», «?OBJ»])]) (mkExists (fun («?PROPERTY» : Obj) => mkAnd [ap (Const.«instance») ([«?PROPERTY», Const.«ShapeAttribute»]), mkOr [mkAnd [ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?ALT»])]), ap (Const.«attribute») ([«?OBJ», «?PROPERTY»])]), ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?ALT»])]), mkNot (ap (Const.«attribute») ([«?OBJ», «?PROPERTY»]))])], mkAnd [ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?ALT»])]), mkNot (ap (Const.«attribute») ([«?OBJ», «?PROPERTY»]))]), ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?ALT»])]), ap (Const.«attribute») ([«?OBJ», «?PROPERTY»])])]]])))),
ap (Const.«subclass») ([Const.«ContentDevelopment», Const.«IntentionalProcess»]),
mkForall (fun («?DEVELOP» : Obj) => mkImp (ap (Const.«instance») ([«?DEVELOP», Const.«ContentDevelopment»])) (mkExists (fun («?OBJ» : Obj) => mkAnd [ap (Const.«instance») ([«?OBJ», Const.«ContentBearingObject»]), ap (Const.«result») ([«?DEVELOP», «?OBJ»])]))),
ap (Const.«subclass») ([Const.«Reading», Const.«ContentDevelopment»]),
ap (Const.«relatedInternalConcept») ([Const.«Reading», Const.«Interpreting»]),
mkForall (fun («?READ» : Obj) => mkImp (ap (Const.«instance») ([«?READ», Const.«Reading»])) (mkExists (fun («?TEXT» : Obj) => mkExists (fun («?PROP» : Obj) => mkAnd [ap (Const.«instance») ([«?TEXT», Const.«Text»]), ap (Const.«containsInformation») ([«?TEXT», «?PROP»]), ap (Const.«realization») ([«?READ», «?PROP»])])))),
ap (Const.«subclass») ([Const.«Writing», Const.«ContentDevelopment»]),
ap (Const.«subclass») ([Const.«Encoding», Const.«Writing»]),
ap (Const.«subclass») ([Const.«Decoding», Const.«Writing»]),
ap (Const.«disjoint») ([Const.«Decoding», Const.«Encoding»]),
mkForall (fun («?DECODE» : Obj) => mkForall (fun («?DOC1» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?DECODE», Const.«Decoding»]), ap (Const.«patient») ([«?DECODE», «?DOC1»])]) (mkExists (fun («?ENCODE» : Obj) => mkExists (fun («?DOC2» : Obj) => mkExists (fun («?TIME» : Obj) => mkExists (fun («?PROP» : Obj) => mkAnd [ap (Const.«containsInformation») ([«?DOC2», «?PROP»]), ap (Const.«containsInformation») ([«?DOC1», «?PROP»]), ap (Const.«temporalPart») ([«?TIME», ap (Const.«PastFn») ([ap (Const.«WhenFn») ([«?DECODE»])])]), ap (Const.«holdsDuring») ([«?TIME», mkAnd [ap (Const.«instance») ([«?ENCODE», Const.«Encoding»]), ap (Const.«patient») ([«?ENCODE», «?DOC2»])]])]))))))),
ap (Const.«subclass») ([Const.«Translating», Const.«ContentDevelopment»]),
ap (Const.«subclass») ([Const.«Translating», Const.«DualObjectProcess»]),
mkForall (fun («?EXPRESSION1» : Obj) => mkForall (fun («?EXPRESSION2» : Obj) => mkForall (fun («?TRANSLATE» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?TRANSLATE», Const.«Translating»]), ap (Const.«patient») ([«?TRANSLATE», «?EXPRESSION1»]), ap (Const.«result») ([«?TRANSLATE», «?EXPRESSION2»])]) (mkExists (fun («?LANGUAGE1» : Obj) => mkExists (fun («?LANGUAGE2» : Obj) => mkExists (fun («?ENTITY» : Obj) => mkAnd [ap (Const.«representsInLanguage») ([«?EXPRESSION1», «?ENTITY», «?LANGUAGE1»]), ap (Const.«representsInLanguage») ([«?EXPRESSION2», «?ENTITY», «?LANGUAGE2»]), mkNot (ap (Const.«equal») ([«?LANGUAGE1», «?LANGUAGE2»]))]))))))),
ap (Const.«subclass») ([Const.«Wetting», Const.«Putting»]),
mkForall (fun («?WET» : Obj) => mkImp (ap (Const.«instance») ([«?WET», Const.«Wetting»])) (mkExists (fun («?OBJ» : Obj) => mkAnd [ap (Const.«patient») ([«?WET», «?OBJ»]), ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?WET»])]), mkNot (ap (Const.«attribute») ([«?OBJ», Const.«Damp»]))]), ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?WET»])]), ap (Const.«attribute») ([«?OBJ», Const.«Damp»])])]))),
mkForall (fun («?WET» : Obj) => mkImp (ap (Const.«instance») ([«?WET», Const.«Wetting»])) (mkExists (fun («?OBJ» : Obj) => mkAnd [ap (Const.«attribute») ([«?OBJ», Const.«Liquid»]), ap (Const.«patient») ([«?WET», «?OBJ»])]))),
ap (Const.«subclass») ([Const.«Drying», Const.«Removing»]),
mkForall (fun («?DRY» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?DRY», Const.«Drying»]), ap (Const.«patient») ([«?DRY», «?OBJ»])]) (ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?DRY»])]), ap (Const.«attribute») ([«?OBJ», Const.«Dry»])])))),
ap (Const.«subclass») ([Const.«Creation», Const.«InternalChange»]),
ap (Const.«relatedInternalConcept») ([Const.«Creation», Const.«Destruction»]),
mkForall (fun («?ACTION» : Obj) => mkImp (ap (Const.«instance») ([«?ACTION», Const.«Creation»])) (mkExists (fun («?RESULT» : Obj) => ap (Const.«result») ([«?ACTION», «?RESULT»])))),
mkForall (fun («?PROCESS» : Obj) => mkImp (ap (Const.«instance») ([«?PROCESS», Const.«Creation»])) (mkExists (fun («?PATIENT» : Obj) => mkAnd [ap (Const.«patient») ([«?PROCESS», «?PATIENT»]), ap (Const.«time») ([«?PATIENT», ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?PROCESS»])])]), mkNot (ap (Const.«time») ([«?PATIENT», ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?PROCESS»])])]))]))),
mkForall (fun («?PATIENT» : Obj) => mkForall (fun («?PROCESS» : Obj) => mkImp (mkAnd [ap (Const.«patient») ([«?PROCESS», «?PATIENT»]), ap (Const.«time») ([«?PATIENT», ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?PROCESS»])])]), mkNot (ap (Const.«time») ([«?PATIENT», ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?PROCESS»])])]))]) (ap (Const.«instance») ([«?PROCESS», Const.«Creation»])))),
ap (Const.«subclass») ([Const.«Making», Const.«Creation»]),
ap (Const.«subclass») ([Const.«Making», Const.«IntentionalProcess»]),
mkForall (fun («?MAKING» : Obj) => mkImp (ap (Const.«instance») ([«?MAKING», Const.«Making»])) (mkExists (fun («?ARTIFACT» : Obj) => mkAnd [ap (Const.«instance») ([«?ARTIFACT», Const.«Artifact»]), ap (Const.«result») ([«?MAKING», «?ARTIFACT»])]))),
ap (Const.«subclass») ([Const.«Constructing», Const.«Making»]),
mkForall (fun («?ARTIFACT» : Obj) => mkForall (fun («?BUILD» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?BUILD», Const.«Constructing»]), ap (Const.«result») ([«?BUILD», «?ARTIFACT»])]) (ap (Const.«instance») ([«?ARTIFACT», Const.«StationaryArtifact»])))),
mkForall (fun («?ARTIFACT» : Obj) => mkImp (ap (Const.«instance») ([«?ARTIFACT», Const.«StationaryArtifact»])) (mkExists (fun («?BUILD» : Obj) => mkAnd [ap (Const.«instance») ([«?BUILD», Const.«Constructing»]), ap (Const.«result») ([«?BUILD», «?ARTIFACT»])]))),
ap (Const.«subclass») ([Const.«Manufacture», Const.«Making»]),
ap (Const.«subclass») ([Const.«Publication», Const.«Manufacture»]),
ap (Const.«subclass») ([Const.«Publication», Const.«ContentDevelopment»]),
mkForall (fun («?PUB» : Obj) => mkImp (ap (Const.«instance») ([«?PUB», Const.«Publication»])) (mkExists (fun («?TEXT» : Obj) => mkAnd [ap (Const.«instance») ([«?TEXT», Const.«Text»]), ap (Const.«patient») ([«?PUB», «?TEXT»])]))),
ap (Const.«subclass») ([Const.«Cooking», Const.«Making»]),
mkForall (fun («?COOK» : Obj) => mkImp (ap (Const.«instance») ([«?COOK», Const.«Cooking»])) (mkExists (fun («?FOOD» : Obj) => mkAnd [ap (Const.«instance») ([«?FOOD», ap (Const.«FoodForFn») ([Const.«Human»])]), ap (Const.«result») ([«?COOK», «?FOOD»])]))),
ap (Const.«subclass») ([Const.«Pursuing», Const.«IntentionalProcess»]),
mkForall (fun («?PURSUE» : Obj) => mkImp (ap (Const.«instance») ([«?PURSUE», Const.«Pursuing»])) (mkExists (fun («?OBJ» : Obj) => mkAnd [ap (Const.«instance») ([«?OBJ», Const.«Object»]), ap (Const.«patient») ([«?PURSUE», «?OBJ»])]))),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?OBJ» : Obj) => mkForall (fun («?PURSUE» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?PURSUE», Const.«Pursuing»]), ap (Const.«agent») ([«?PURSUE», «?AGENT»]), ap (Const.«patient») ([«?PURSUE», «?OBJ»])]) (ap (Const.«holdsDuring») ([«?PURSUE», ap (Const.«wants») ([«?AGENT», «?OBJ»])]))))),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?OBJ» : Obj) => mkForall (fun («?PURSUE» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?PURSUE», Const.«Pursuing»]), ap (Const.«agent») ([«?PURSUE», «?AGENT»]), ap (Const.«patient») ([«?PURSUE», «?OBJ»])]) (ap (Const.«holdsDuring») ([«?PURSUE», mkNot (ap (Const.«possesses») ([«?AGENT», «?OBJ»]))]))))),
ap (Const.«subclass») ([Const.«Hunting», Const.«Pursuing»]),
mkForall (fun («?H» : Obj) => mkImp (ap (Const.«instance») ([«?H», Const.«Hunting»])) (mkExists (fun («?T» : Obj) => mkAnd [ap (Const.«instance») ([«?T», Const.«Animal»]), ap (Const.«patient») ([«?H», «?T»])]))),
mkForall (fun («?H» : Obj) => mkForall (fun («?P» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?H», Const.«Hunting»]), ap (Const.«patient») ([«?H», «?P»])]) (ap (Const.«hasPurpose») ([«?H», mkExists (fun («?PROC» : Obj) => mkAnd [ap (Const.«patient») ([«?PROC», «?P»]), mkOr [ap (Const.«instance») ([«?PROC», Const.«Confining»]), ap (Const.«instance») ([«?PROC», Const.«Killing»])]])])))),
ap (Const.«subclass») ([Const.«Investigating», Const.«IntentionalProcess»]),
mkForall (fun («?INVESTIGATE» : Obj) => mkForall (fun («?PROP» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?INVESTIGATE», Const.«Investigating»]), ap (Const.«patient») ([«?INVESTIGATE», «?PROP»])]) (ap (Const.«instance») ([«?PROP», Const.«Formula»])))),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?INVESTIGATE» : Obj) => mkForall (fun («?PROP» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?INVESTIGATE», Const.«Investigating»]), ap (Const.«agent») ([«?INVESTIGATE», «?AGENT»]), ap (Const.«patient») ([«?INVESTIGATE», «?PROP»])]) (ap (Const.«holdsDuring») ([ap (Const.«WhenFn») ([«?INVESTIGATE»]), mkNot (ap (Const.«knows») ([«?AGENT», «?PROP»]))]))))),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?INVESTIGATE» : Obj) => mkForall (fun («?PROP» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?INVESTIGATE», Const.«Investigating»]), ap (Const.«agent») ([«?INVESTIGATE», «?AGENT»]), ap (Const.«patient») ([«?INVESTIGATE», «?PROP»])]) (ap (Const.«hasPurposeForAgent») ([«?INVESTIGATE», ap (Const.«knows») ([«?AGENT», «?PROP»]), «?AGENT»]))))),
ap (Const.«subclass») ([Const.«Experimenting», Const.«Investigating»]),
ap (Const.«subclass») ([Const.«DiagnosticProcess», Const.«Investigating»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?PROC» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?PROC», Const.«DiagnosticProcess»]), ap (Const.«agent») ([«?PROC», «?AGENT»])]) (mkExists (fun («?CAUSE» : Obj) => ap (Const.«hasPurposeForAgent») ([«?PROC», ap (Const.«knows») ([«?AGENT», ap (Const.«causes») ([«?CAUSE», «?PROC»])]), «?AGENT»]))))),
ap (Const.«subclass») ([Const.«Searching», Const.«Investigating»]),
mkForall (fun («?S» : Obj) => mkImp (ap (Const.«instance») ([«?S», Const.«Searching»])) (mkExists (fun («?AGENT» : Obj) => mkExists (fun («?OBJ» : Obj) => mkExists (fun («?LOC» : Obj) => mkAnd [ap (Const.«instance») ([«?AGENT», Const.«CognitiveAgent»]), ap (Const.«agent») ([«?S», «?AGENT»]), ap (Const.«instance») ([«?OBJ», Const.«Physical»]), ap (Const.«patient») ([«?S», «?OBJ»]), ap (Const.«instance») ([«?LOC», Const.«Object»]), ap (Const.«located») ([«?OBJ», «?LOC»]), ap (Const.«hasPurposeForAgent») ([«?S», ap (Const.«knows») ([«?AGENT», ap (Const.«located») ([«?OBJ», «?LOC»])]), «?AGENT»])]))))),
mkForall (fun («?OBJ» : Obj) => mkForall (fun («?S» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?S», Const.«Searching»]), ap (Const.«patient») ([«?S», «?OBJ»]), ap (Const.«instance») ([«?OBJ», Const.«Physical»])]) (mkExists (fun («?LOC» : Obj) => mkExists (fun («?AGENT» : Obj) => mkAnd [ap (Const.«instance») ([«?AGENT», Const.«CognitiveAgent»]), ap (Const.«agent») ([«?S», «?AGENT»]), ap (Const.«instance») ([«?LOC», Const.«Object»]), ap (Const.«located») ([«?OBJ», «?LOC»]), ap (Const.«hasPurposeForAgent») ([«?S», ap (Const.«knows») ([«?AGENT», ap (Const.«located») ([«?OBJ», «?LOC»])]), «?AGENT»])]))))),
ap (Const.«subclass») ([Const.«SocialInteraction», Const.«IntentionalProcess»]),
mkForall (fun («?INTERACTION» : Obj) => mkImp (ap (Const.«instance») ([«?INTERACTION», Const.«SocialInteraction»])) (mkExists (fun («?AGENT1» : Obj) => mkExists (fun («?AGENT2» : Obj) => mkAnd [ap (Const.«involvedInEvent») ([«?INTERACTION», «?AGENT1»]), ap (Const.«involvedInEvent») ([«?INTERACTION», «?AGENT2»]), ap (Const.«instance») ([«?AGENT1», Const.«AutonomousAgent»]), ap (Const.«instance») ([«?AGENT2», Const.«AutonomousAgent»]), mkNot (ap (Const.«equal») ([«?AGENT1», «?AGENT2»]))])))),
mkForall (fun («?A» : Obj) => mkImp (ap (Const.«instance») ([«?A», Const.«AutonomousAgent»])) (ap (Const.«capability») ([Const.«SocialInteraction», Const.«agent», «?A»]))),
ap (Const.«subclass») ([Const.«Pretending», Const.«SocialInteraction»]),
mkForall (fun («?PRETEND» : Obj) => mkImp (ap (Const.«instance») ([«?PRETEND», Const.«Pretending»])) (mkExists (fun («?PERSON» : Obj) => mkExists (fun («?PROP» : Obj) => mkAnd [ap (Const.«hasPurpose») ([«?PRETEND», ap (Const.«believes») ([«?PERSON», «?PROP»])]), ap (Const.«truth») ([«?PROP», Const.«False»])])))),
ap (Const.«subclass») ([Const.«Communication», Const.«SocialInteraction»]),
ap (Const.«subclass») ([Const.«Communication», Const.«ContentBearingProcess»]),
ap (Const.«partition») ([Const.«Communication», Const.«Stating», Const.«Supposing», Const.«Directing», Const.«Committing», Const.«Expressing», Const.«Declaring»]),
ap (Const.«relatedInternalConcept») ([Const.«Communication», Const.«ContentDevelopment»]),
mkForall (fun («?COMMUNICATE» : Obj) => mkImp (ap (Const.«instance») ([«?COMMUNICATE», Const.«Communication»])) (mkExists (fun («?PHYS» : Obj) => mkExists (fun («?ENTITY» : Obj) => mkExists (fun («?AGENT1» : Obj) => mkExists (fun («?AGENT2» : Obj) => mkAnd [ap (Const.«refers») ([«?PHYS», «?ENTITY»]), ap (Const.«patient») ([«?COMMUNICATE», «?PHYS»]), ap (Const.«instance») ([«?AGENT1», Const.«CognitiveAgent»]), ap (Const.«agent») ([«?COMMUNICATE», «?AGENT1»]), ap (Const.«instance») ([«?AGENT2», Const.«CognitiveAgent»]), ap (Const.«destination») ([«?COMMUNICATE», «?AGENT2»])])))))),
ap (Const.«subclass») ([Const.«Disseminating», Const.«Communication»]),
mkForall (fun («?DISSEMINATE» : Obj) => mkImp (ap (Const.«instance») ([«?DISSEMINATE», Const.«Disseminating»])) (mkExists (fun («?AGENT1» : Obj) => mkExists (fun («?AGENT2» : Obj) => mkAnd [ap (Const.«destination») ([«?DISSEMINATE», «?AGENT1»]), ap (Const.«instance») ([«?AGENT1», Const.«CognitiveAgent»]), ap (Const.«destination») ([«?DISSEMINATE», «?AGENT2»]), ap (Const.«instance») ([«?AGENT2», Const.«CognitiveAgent»]), mkNot (ap (Const.«equal») ([«?AGENT1», «?AGENT2»]))])))),
ap (Const.«subclass») ([Const.«Demonstrating», Const.«Disseminating»]),
mkForall (fun («?DEMO» : Obj) => mkImp (ap (Const.«instance») ([«?DEMO», Const.«Demonstrating»])) (mkExists (fun («?PERSON» : Obj) => ap (Const.«attends») ([«?DEMO», «?PERSON»])))),
ap (Const.«subrelation») ([Const.«attends», Const.«experiencer»]),
ap (Const.«instance») ([Const.«attends», Const.«CaseRole»]),
ap (Const.«instance») ([Const.«attends», Const.«PartialValuedRelation»]),
ap (Const.«subclass») ([Const.«Gesture», Const.«Communication»]),
ap (Const.«subclass») ([Const.«Gesture», Const.«BodyMotion»]),
ap (Const.«subclass») ([Const.«Advertising», Const.«Disseminating»]),
mkForall (fun («?ADVERT» : Obj) => mkImp (ap (Const.«instance») ([«?ADVERT», Const.«Advertising»])) (mkExists (fun («?OBJ» : Obj) => mkAnd [ap (Const.«refers») ([«?ADVERT», «?OBJ»]), ap (Const.«hasPurpose») ([«?ADVERT», mkExists (fun («?SALE» : Obj) => mkAnd [ap (Const.«instance») ([«?SALE», Const.«Selling»]), ap (Const.«patient») ([«?SALE», «?OBJ»])])])]))),
ap (Const.«subclass») ([Const.«Expressing», Const.«Communication»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?EXPRESS» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?EXPRESS», Const.«Expressing»]), ap (Const.«agent») ([«?EXPRESS», «?AGENT»])]) (mkExists (fun («?STATE» : Obj) => mkAnd [ap (Const.«instance») ([«?STATE», Const.«StateOfMind»]), ap (Const.«attribute») ([«?AGENT», «?STATE»]), ap (Const.«represents») ([«?EXPRESS», «?STATE»])])))),
ap (Const.«subclass») ([Const.«LinguisticCommunication», Const.«Communication»]),
mkForall (fun («?COMMUNICATE» : Obj) => mkImp (ap (Const.«instance») ([«?COMMUNICATE», Const.«LinguisticCommunication»])) (mkExists (fun («?OBJ» : Obj) => mkAnd [ap (Const.«represents») ([«?COMMUNICATE», «?OBJ»]), ap (Const.«instance») ([«?OBJ», Const.«LinguisticExpression»]), ap (Const.«patient») ([«?COMMUNICATE», «?OBJ»])]))),
ap (Const.«subclass») ([Const.«Stating», Const.«LinguisticCommunication»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?FORMULA» : Obj) => mkForall (fun («?STATE» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?STATE», Const.«Stating»]), ap (Const.«agent») ([«?STATE», «?AGENT»]), ap (Const.«patient») ([«?STATE», «?FORMULA»]), ap (Const.«instance») ([«?FORMULA», Const.«Formula»])]) (ap (Const.«holdsDuring») ([ap (Const.«WhenFn») ([«?STATE»]), ap (Const.«believes») ([«?AGENT», «?FORMULA»])]))))),
ap (Const.«subclass») ([Const.«Disagreeing», Const.«Stating»]),
mkForall (fun («?DIS» : Obj) => mkImp (ap (Const.«instance») ([«?DIS», Const.«Disagreeing»])) (mkExists (fun («?A1» : Obj) => mkExists (fun («?A2» : Obj) => mkExists (fun («?STATE1» : Obj) => mkExists (fun («?STATE2» : Obj) => mkExists (fun («?STMT1» : Obj) => mkExists (fun («?STMT2» : Obj) => mkAnd [ap (Const.«subProcess») ([«?STATE1», «?DIS»]), ap (Const.«subProcess») ([«?STATE2», «?DIS»]), ap (Const.«agent») ([«?STATE1», «?A1»]), ap (Const.«agent») ([«?STATE2», «?A2»]), mkNot (ap (Const.«equal») ([«?A1», «?A2»])), ap (Const.«containsInformation») ([«?STATE1», «?STMT1»]), ap (Const.«containsInformation») ([«?STATE2», «?STMT2»]), mkNot (ap (Const.«consistent») ([«?STMT1», «?STMT2»]))])))))))),
ap (Const.«subclass») ([Const.«Supposing», Const.«LinguisticCommunication»]),
ap (Const.«subclass») ([Const.«Directing», Const.«LinguisticCommunication»]),
ap (Const.«subclass») ([Const.«Ordering», Const.«Directing»]),
mkForall (fun («?FORMULA» : Obj) => mkForall (fun («?ORDER» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?ORDER», Const.«Ordering»]), ap (Const.«patient») ([«?ORDER», «?FORMULA»])]) (ap (Const.«modalAttribute») ([«?FORMULA», Const.«Obligation»])))),
ap (Const.«subclass») ([Const.«Requesting», Const.«Directing»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?FORMULA» : Obj) => mkForall (fun («?REQUEST» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?REQUEST», Const.«Requesting»]), ap (Const.«agent») ([«?REQUEST», «?AGENT»]), ap (Const.«patient») ([«?REQUEST», «?FORMULA»]), ap (Const.«instance») ([«?FORMULA», Const.«Formula»])]) (ap (Const.«desires») ([«?AGENT», «?FORMULA»]))))),
ap (Const.«subclass») ([Const.«Questioning», Const.«Directing»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?FORMULA» : Obj) => mkForall (fun («?QUESTION» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?QUESTION», Const.«Questioning»]), ap (Const.«agent») ([«?QUESTION», «?AGENT»]), ap (Const.«patient») ([«?QUESTION», «?FORMULA»]), ap (Const.«instance») ([«?FORMULA», Const.«Formula»])]) (ap (Const.«holdsDuring») ([ap (Const.«WhenFn») ([«?QUESTION»]), mkNot (ap (Const.«knows») ([«?AGENT», «?FORMULA»]))]))))),
ap (Const.«subclass») ([Const.«Committing», Const.«LinguisticCommunication»]),
mkForall (fun («?COMMIT» : Obj) => mkForall (fun («?FORMULA» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?COMMIT», Const.«Committing»]), ap (Const.«patient») ([«?COMMIT», «?FORMULA»]), ap (Const.«instance») ([«?FORMULA», Const.«Formula»])]) (ap (Const.«modalAttribute») ([«?FORMULA», Const.«Promise»])))),
ap (Const.«subclass») ([Const.«Offering», Const.«Committing»]),
ap (Const.«subclass») ([Const.«Declaring», Const.«LinguisticCommunication»]),
mkForall (fun («?DECLARE» : Obj) => mkImp (ap (Const.«instance») ([«?DECLARE», Const.«Declaring»])) (mkExists (fun («?PROP» : Obj) => mkExists (fun («?NORM» : Obj) => mkOr [ap (Const.«confersNorm») ([«?DECLARE», «?PROP», «?NORM»]), ap (Const.«deprivesNorm») ([«?DECLARE», «?PROP», «?NORM»])])))),
ap (Const.«subclass») ([Const.«Naming», Const.«Declaring»]),
mkForall (fun («?NAME» : Obj) => mkForall (fun («?PROCESS» : Obj) => mkForall (fun («?THING» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?PROCESS», Const.«Naming»]), ap (Const.«patient») ([«?PROCESS», «?THING»]), ap (Const.«destination») ([«?PROCESS», «?NAME»])]) (ap (Const.«holdsDuring») ([ap (Const.«FutureFn») ([ap (Const.«WhenFn») ([«?PROCESS»])]), ap (Const.«names») ([«?NAME», «?THING»])]))))),
ap (Const.«subclass») ([Const.«Cooperation», Const.«SocialInteraction»]),
mkForall (fun («?COOPERATE» : Obj) => mkImp (ap (Const.«instance») ([«?COOPERATE», Const.«Cooperation»])) (mkExists (fun («?PURP» : Obj) => mkForall (fun («?AGENT» : Obj) => mkImp (ap (Const.«agent») ([«?COOPERATE», «?AGENT»])) (ap (Const.«hasPurposeForAgent») ([«?COOPERATE», «?PURP», «?AGENT»])))))),
ap (Const.«subclass») ([Const.«Meeting», Const.«SocialInteraction»]),
mkForall (fun («?AGENT1» : Obj) => mkForall (fun («?AGENT2» : Obj) => mkForall (fun («?MEET» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?MEET», Const.«Meeting»]), ap (Const.«agent») ([«?MEET», «?AGENT1»]), ap (Const.«agent») ([«?MEET», «?AGENT2»])]) (ap (Const.«holdsDuring») ([ap (Const.«WhenFn») ([«?MEET»]), ap (Const.«orientation») ([«?AGENT1», «?AGENT2», Const.«Near»])]))))),
mkForall (fun («?MEET» : Obj) => mkImp (ap (Const.«instance») ([«?MEET», Const.«Meeting»])) (mkExists (fun («?AGENT1» : Obj) => mkExists (fun («?AGENT2» : Obj) => mkAnd [ap (Const.«agent») ([«?MEET», «?AGENT1»]), ap (Const.«agent») ([«?MEET», «?AGENT2»]), ap (Const.«hasPurpose») ([«?MEET», mkExists (fun («?COMM» : Obj) => mkAnd [ap (Const.«instance») ([«?COMM», Const.«Communication»]), ap (Const.«agent») ([«?COMM», «?AGENT1»]), ap (Const.«agent») ([«?COMM», «?AGENT2»])])])])))),
ap (Const.«subclass») ([Const.«Contest», Const.«SocialInteraction»]),
mkForall (fun («?CONTEST» : Obj) => mkImp (ap (Const.«instance») ([«?CONTEST», Const.«Contest»])) (mkExists (fun («?AGENT1» : Obj) => mkExists (fun («?AGENT2» : Obj) => mkExists (fun («?PURP1» : Obj) => mkExists (fun («?PURP2» : Obj) => mkAnd [ap (Const.«agent») ([«?CONTEST», «?AGENT1»]), ap (Const.«agent») ([«?CONTEST», «?AGENT2»]), ap (Const.«hasPurposeForAgent») ([«?CONTEST», «?PURP1», «?AGENT1»]), ap (Const.«hasPurposeForAgent») ([«?CONTEST», «?PURP2», «?AGENT2»]), mkNot (ap (Const.«equal») ([«?AGENT1», «?AGENT2»])), mkNot (ap (Const.«equal») ([«?PURP1», «?PURP2»]))])))))),
ap (Const.«subclass») ([Const.«ViolentContest», Const.«Contest»]),
ap (Const.«subclass») ([Const.«War», Const.«ViolentContest»]),
mkForall (fun («?WAR» : Obj) => mkImp (ap (Const.«instance») ([«?WAR», Const.«War»])) (mkExists (fun («?BATTLE» : Obj) => mkAnd [ap (Const.«instance») ([«?BATTLE», Const.«Battle»]), ap (Const.«subProcess») ([«?BATTLE», «?WAR»])]))),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?WAR» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?WAR», Const.«War»]), ap (Const.«agent») ([«?WAR», «?AGENT»])]) (mkOr [ap (Const.«instance») ([«?AGENT», Const.«GeopoliticalArea»]), mkAnd [ap (Const.«instance») ([«?AGENT», Const.«Organization»]), mkForall (fun («?MEMBER» : Obj) => mkImp (ap (Const.«member») ([«?MEMBER», «?AGENT»])) (ap (Const.«instance») ([«?MEMBER», Const.«GeopoliticalArea»])))]]))),
ap (Const.«subclass») ([Const.«Battle», Const.«ViolentContest»]),
mkForall (fun («?BATTLE» : Obj) => mkImp (ap (Const.«instance») ([«?BATTLE», Const.«Battle»])) (mkExists (fun («?WAR» : Obj) => mkAnd [ap (Const.«instance») ([«?WAR», Const.«War»]), ap (Const.«subProcess») ([«?BATTLE», «?WAR»])]))),
mkForall (fun («?BATTLE» : Obj) => mkImp (ap (Const.«instance») ([«?BATTLE», Const.«Battle»])) (mkExists (fun («?ATTACK» : Obj) => mkAnd [ap (Const.«instance») ([«?ATTACK», Const.«ViolentContest»]), ap (Const.«subProcess») ([«?ATTACK», «?BATTLE»])]))),
ap (Const.«subclass») ([Const.«Game», Const.«Contest»]),
ap (Const.«subclass») ([Const.«Game», Const.«RecreationOrExercise»]),
ap (Const.«subclass») ([Const.«Sport», Const.«Game»]),
ap (Const.«subclass») ([Const.«LegalAction», Const.«Contest»]),
ap (Const.«subclass») ([Const.«Maneuver», Const.«IntentionalProcess»]),
mkForall (fun («?MOVE» : Obj) => mkImp (ap (Const.«instance») ([«?MOVE», Const.«Maneuver»])) (mkExists (fun («?CONTEST» : Obj) => mkAnd [ap (Const.«instance») ([«?CONTEST», Const.«Contest»]), ap (Const.«subProcess») ([«?MOVE», «?CONTEST»])]))),
ap (Const.«subclass») ([Const.«Attack», Const.«Maneuver»]),
mkForall (fun («?ATTACK» : Obj) => mkImp (ap (Const.«instance») ([«?ATTACK», Const.«Attack»])) (mkExists (fun («?CONTEST» : Obj) => mkAnd [ap (Const.«instance») ([«?CONTEST», Const.«ViolentContest»]), ap (Const.«subProcess») ([«?ATTACK», «?CONTEST»])]))),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?ATTACK» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?ATTACK», Const.«Attack»]), ap (Const.«agent») ([«?ATTACK», «?AGENT»]), ap (Const.«patient») ([«?ATTACK», «?OBJ»])]) (ap (Const.«hasPurposeForAgent») ([«?ATTACK», mkExists (fun («?DAMAGE» : Obj) => mkAnd [ap (Const.«instance») ([«?DAMAGE», Const.«Damaging»]), ap (Const.«patient») ([«?DAMAGE», «?OBJ»])]), «?AGENT»]))))),
ap (Const.«subclass») ([Const.«DefensiveManeuver», Const.«Maneuver»]),
mkForall (fun («?DEFENSE» : Obj) => mkImp (ap (Const.«instance») ([«?DEFENSE», Const.«DefensiveManeuver»])) (mkExists (fun («?CONTEST» : Obj) => mkAnd [ap (Const.«instance») ([«?CONTEST», Const.«ViolentContest»]), ap (Const.«subProcess») ([«?DEFENSE», «?CONTEST»])]))),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?DEFENSE» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?DEFENSE», Const.«DefensiveManeuver»]), ap (Const.«agent») ([«?DEFENSE», «?AGENT»])]) (ap (Const.«hasPurposeForAgent») ([«?DEFENSE», mkNot (mkExists (fun («?DAMAGE» : Obj) => mkAnd [ap (Const.«instance») ([«?DAMAGE», Const.«Damaging»]), ap (Const.«patient») ([«?DAMAGE», «?AGENT»])])), «?AGENT»])))),
mkForall (fun («?CONTEST» : Obj) => mkForall (fun («?MANEUVER» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?MANEUVER», Const.«Maneuver»]), ap (Const.«instance») ([«?CONTEST», Const.«ViolentContest»]), ap (Const.«subProcess») ([«?MANEUVER», «?CONTEST»])]) (mkOr [ap (Const.«instance») ([«?MANEUVER», Const.«Attack»]), ap (Const.«instance») ([«?MANEUVER», Const.«DefensiveManeuver»])]))),
ap (Const.«subclass») ([Const.«Perception», Const.«PsychologicalProcess»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?PERCEPT» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?PERCEPT», Const.«Perception»]), ap (Const.«agent») ([«?PERCEPT», «?AGENT»])]) (ap (Const.«instance») ([«?AGENT», Const.«Animal»])))),
mkForall (fun («?AGENT» : Obj) => mkImp (ap (Const.«instance») ([«?AGENT», Const.«SentientAgent»])) (ap (Const.«capability») ([Const.«Perception», Const.«experiencer», «?AGENT»]))),
ap (Const.«instance») ([Const.«ImpairmentFn», Const.«UnaryFunction»]),
mkForall (fun («?A» : Obj) => mkForall (fun («?S» : Obj) => mkForall (fun («?SI» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?SI», ap (Const.«ImpairmentFn») ([«?S»])]), ap (Const.«instrument») ([«?SI», «?A»])]) (mkExists (fun («?A2» : Obj) => mkAnd [mkNot (ap (Const.«equal») ([«?A2», «?A»])), ap (Const.«capability») ([«?S», Const.«instrument», «?A2»]), mkNot (ap (Const.«capability») ([«?S», Const.«instrument», «?A»]))]))))),
ap (Const.«instance») ([Const.«SenseImpairmentFn», Const.«UnaryFunction»]),
mkForall (fun («?A» : Obj) => mkForall (fun («?S» : Obj) => mkForall (fun («?SI» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?SI», ap (Const.«SenseImpairmentFn») ([«?S»])]), ap (Const.«experiencer») ([«?SI», «?A»])]) (mkExists (fun («?A2» : Obj) => mkAnd [mkNot (ap (Const.«equal») ([«?A2», «?A»])), ap (Const.«capability») ([«?S», Const.«experiencer», «?A2»]), mkNot (ap (Const.«capability») ([«?S», Const.«experiencer», «?A»]))]))))),
ap (Const.«instance») ([Const.«SenseInabilityFn», Const.«UnaryFunction»]),
mkForall (fun («?A» : Obj) => mkForall (fun («?S» : Obj) => mkForall (fun («?SI» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?SI», ap (Const.«SenseImpairmentFn») ([«?S»])]), ap (Const.«experiencer») ([«?SI», «?A»])]) (mkNot (ap (Const.«capability») ([«?S», Const.«experiencer», «?A»])))))),
ap (Const.«subclass») ([Const.«Seeing», Const.«Perception»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?OBJ» : Obj) => mkForall (fun («?SEE» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?SEE», Const.«Seeing»]), ap (Const.«agent») ([«?SEE», «?AGENT»]), ap (Const.«patient») ([«?SEE», «?OBJ»])]) (mkExists (fun («?PROP» : Obj) => mkAnd [ap (Const.«instance») ([«?PROP», Const.«ColorAttribute»]), ap (Const.«knows») ([«?AGENT», ap (Const.«attribute») ([«?OBJ», «?PROP»])])]))))),
mkForall (fun («?OBJ» : Obj) => mkForall (fun («?SEE» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?SEE», Const.«Seeing»]), ap (Const.«patient») ([«?SEE», «?OBJ»])]) (ap (Const.«holdsDuring») ([ap (Const.«WhenFn») ([«?SEE»]), ap (Const.«attribute») ([«?OBJ», Const.«Illuminated»])])))),
mkForall (fun («?OBJ» : Obj) => mkForall (fun («?SEE» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?SEE», Const.«Seeing»]), ap (Const.«patient») ([«?SEE», «?OBJ»])]) (mkExists (fun («?ATTR» : Obj) => mkAnd [ap (Const.«instance») ([«?ATTR», Const.«ColorAttribute»]), ap (Const.«holdsDuring») ([ap (Const.«WhenFn») ([«?SEE»]), ap (Const.«attribute») ([«?OBJ», «?ATTR»])])])))),
ap (Const.«subclass») ([Const.«Looking», Const.«Seeing»]),
ap (Const.«subclass») ([Const.«Looking», Const.«IntentionalProcess»]),
ap (Const.«subclass») ([Const.«Smelling», Const.«Perception»]),
mkForall (fun («?OBJ» : Obj) => mkForall (fun («?SMELL» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?SMELL», Const.«Smelling»]), ap (Const.«patient») ([«?SMELL», «?OBJ»])]) (mkExists (fun («?ATTR» : Obj) => mkAnd [ap (Const.«instance») ([«?ATTR», Const.«OlfactoryAttribute»]), ap (Const.«attribute») ([«?OBJ», «?ATTR»])])))),
ap (Const.«subclass») ([Const.«Tasting», Const.«Perception»]),
mkForall (fun («?OBJ» : Obj) => mkForall (fun («?TASTE» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?TASTE», Const.«Tasting»]), ap (Const.«patient») ([«?TASTE», «?OBJ»])]) (mkExists (fun («?ATTR» : Obj) => mkAnd [ap (Const.«instance») ([«?ATTR», Const.«TasteAttribute»]), ap (Const.«attribute») ([«?OBJ», «?ATTR»])])))),
ap (Const.«subclass») ([Const.«Hearing», Const.«Perception»]),
mkForall (fun («?HEAR» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?HEAR», Const.«Hearing»]), ap (Const.«patient») ([«?HEAR», «?OBJ»])]) (mkExists (fun («?ATTR» : Obj) => mkAnd [ap (Const.«instance») ([«?ATTR», Const.«SoundAttribute»]), ap (Const.«attribute») ([«?OBJ», «?ATTR»])])))),
ap (Const.«subclass») ([Const.«SoundAttribute», Const.«PerceptualAttribute»]),
ap (Const.«instance») ([Const.«Audible», Const.«SoundAttribute»]),
ap (Const.«instance») ([Const.«Inaudible», Const.«SoundAttribute»]),
ap (Const.«contraryAttribute») ([Const.«Audible», Const.«Inaudible»]),
mkForall (fun («?OBJ» : Obj) => mkForall (fun («?SOUND» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?SOUND», Const.«RadiatingSound»]), ap (Const.«agent») ([«?SOUND», «?OBJ»]), ap (Const.«attribute») ([«?SOUND», Const.«Audible»])]) (mkExists (fun («?HUMAN» : Obj) => mkExists (fun («?HEAR» : Obj) => mkAnd [ap (Const.«instance») ([«?HUMAN», Const.«Human»]), ap (Const.«capability») ([ap (Const.«KappaFn») ([«?HEAR», mkAnd [ap (Const.«instance») ([«?HEAR», Const.«Hearing»]), ap (Const.«agent») ([«?HEAR», «?HUMAN»]), ap (Const.«destination») ([«?HEAR», «?HUMAN»]), ap (Const.«origin») ([«?HEAR», «?OBJ»])]]), Const.«agent», «?HUMAN»])]))))),
ap (Const.«subclass») ([Const.«Listening», Const.«Hearing»]),
ap (Const.«subclass») ([Const.«Listening», Const.«IntentionalProcess»]),
ap (Const.«subclass») ([Const.«TactilePerception», Const.«Perception»]),
mkForall (fun («?TACTILE» : Obj) => mkImp (ap (Const.«instance») ([«?TACTILE», Const.«TactilePerception»])) (mkExists (fun («?TOUCH» : Obj) => mkAnd [ap (Const.«instance») ([«?TOUCH», Const.«Touching»]), ap (Const.«subProcess») ([«?TOUCH», «?TACTILE»])]))),
ap (Const.«subclass») ([Const.«Radiating», Const.«Motion»]),
ap (Const.«subclass») ([Const.«RadiatingLight», Const.«RadiatingElectromagnetic»]),
mkForall (fun («?EMIT» : Obj) => mkForall (fun («?REGION» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?EMIT», Const.«RadiatingLight»]), ap (Const.«patient») ([«?EMIT», «?REGION»]), ap (Const.«instance») ([«?REGION», Const.«Region»])]) (ap (Const.«attribute») ([«?REGION», Const.«Illuminated»])))),
mkForall (fun («?REGION» : Obj) => mkImp (ap (Const.«attribute») ([«?REGION», Const.«Illuminated»])) (mkExists (fun («?EMIT» : Obj) => mkAnd [ap (Const.«instance») ([«?EMIT», Const.«RadiatingLight»]), ap (Const.«patient») ([«?EMIT», «?REGION»]), ap (Const.«instance») ([«?REGION», Const.«Region»])]))),
ap (Const.«subclass») ([Const.«RadiatingInfrared», Const.«RadiatingElectromagnetic»]),
ap (Const.«subclass») ([Const.«RadiatingXRay», Const.«RadiatingElectromagnetic»]),
ap (Const.«subclass») ([Const.«RadiatingSound», Const.«Radiating»]),
mkForall (fun («?EMIT» : Obj) => mkForall (fun («?SOUND» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?EMIT», Const.«RadiatingSound»]), ap (Const.«agent») ([«?EMIT», «?SOUND»])]) (mkExists (fun («?ATTR» : Obj) => mkAnd [ap (Const.«instance») ([«?ATTR», Const.«SoundAttribute»]), ap (Const.«attribute») ([«?SOUND», «?ATTR»])])))),
ap (Const.«subclass») ([Const.«MakingMusic», Const.«RadiatingSound»]),
ap (Const.«comment») ([Const.«MakingMusic», strLit "Changing the old Music to &%MakingMusic to be more consistent with\nthe verb-form that &%Process seem to take. (09-14-2011)", strLit "KJN"]),
ap (Const.«partition») ([Const.«MakingMusic», Const.«MakingInstrumentalMusic», Const.«MakingVocalMusic»]),
ap (Const.«subclass») ([Const.«MakingInstrumentalMusic», Const.«MakingMusic»]),
mkForall (fun («?M» : Obj) => mkImp (ap (Const.«instance») ([«?M», Const.«MakingInstrumentalMusic»])) (mkExists (fun («?I» : Obj) => mkAnd [ap (Const.«instance») ([«?I», Const.«MusicalInstrument»]), ap (Const.«instrument») ([«?M», «?I»])]))),
ap (Const.«subclass») ([Const.«Vocalizing», Const.«RadiatingSound»]),
ap (Const.«subclass») ([Const.«Vocalizing», Const.«OrganismProcess»]),
ap (Const.«subclass») ([Const.«MakingVocalMusic», Const.«MakingMusic»]),
ap (Const.«subclass») ([Const.«MakingVocalMusic», Const.«Vocalizing»]),
ap (Const.«comment») ([Const.«MakingVocalMusic», strLit "Currently, &%VocalMusic also inherits from &%Speaking.\nChanging this to more general &%Vocalizing.  Acapella groups today use their &%VocalCord\nto create music in ways that are more than just speaking. (09-14-2011)", strLit "KJN"]),
ap (Const.«subclass») ([Const.«Singing», Const.«MakingVocalMusic»]),
mkForall (fun («?S» : Obj) => mkImp (ap (Const.«instance») ([«?S», Const.«Singing»])) (mkExists (fun («?W» : Obj) => mkAnd [ap (Const.«patient») ([«?S», «?W»]), ap (Const.«instance») ([«?W», Const.«Word»])]))),
ap (Const.«subclass») ([Const.«RadiatingElectromagnetic», Const.«Radiating»]),
ap (Const.«subclass») ([Const.«RadiatingNuclear», Const.«Radiating»]),
ap (Const.«subclass») ([Const.«StateChange», Const.«InternalChange»]),
mkForall (fun («?OBJ» : Obj) => mkForall (fun («?PROCESS» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?PROCESS», Const.«StateChange»]), ap (Const.«patient») ([«?PROCESS», «?OBJ»])]) (mkExists (fun («?PART» : Obj) => mkExists (fun («?STATE1» : Obj) => mkExists (fun («?STATE2» : Obj) => mkAnd [ap (Const.«part») ([«?PART», «?OBJ»]), ap (Const.«instance») ([«?STATE1», Const.«PhysicalState»]), ap (Const.«instance») ([«?STATE2», Const.«PhysicalState»]), mkNot (ap (Const.«equal») ([«?STATE1», «?STATE2»])), ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?PROCESS»])]), ap (Const.«attribute») ([«?PART», «?STATE1»])]), ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?PROCESS»])]), ap (Const.«attribute») ([«?PART», «?STATE2»])])])))))),
ap (Const.«instance») ([Const.«atomicNumber», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«atomicNumber», Const.«PartialValuedRelation»]),
mkForall (fun («?ATOM» : Obj) => mkForall (fun («?NUMBER» : Obj) => mkForall (fun («?PROTON» : Obj) => mkForall (fun («?SUBSTANCE» : Obj) => mkForall (fun («?TYPE» : Obj) => mkImp (ap (Const.«atomicNumber») ([«?TYPE», «?NUMBER»])) (mkImp (mkAnd [ap (Const.«instance») ([«?SUBSTANCE», «?TYPE»]), ap (Const.«part») ([«?ATOM», «?SUBSTANCE»]), ap (Const.«instance») ([«?ATOM», Const.«Atom»])]) (ap (Const.«equal») ([«?NUMBER», ap (Const.«CardinalityFn») ([ap (Const.«KappaFn») ([«?PROTON», mkAnd [ap (Const.«part») ([«?PROTON», «?ATOM»]), ap (Const.«instance») ([«?PROTON», Const.«Proton»])]])])])))))))),
ap (Const.«instance») ([Const.«boilingPoint», Const.«BinaryPredicate»]),
mkForall (fun («?BOIL» : Obj) => mkForall (fun («?PRES» : Obj) => mkForall (fun («?TEMP» : Obj) => mkForall (fun («?X» : Obj) => mkForall (fun («?Y» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?X», «?Y»]), ap (Const.«subclass») ([«?Y», Const.«PureSubstance»]), ap (Const.«barometricPressure») ([«?X», ap (Const.«MeasureFn») ([«?PRES», Const.«InchMercury»])]), ap (Const.«greaterThan») ([numLit "29.92", «?PRES»]), ap (Const.«boilingPoint») ([«?Y», ap (Const.«MeasureFn») ([«?BOIL», Const.«KelvinDegree»])]), ap (Const.«measure») ([«?X», ap (Const.«MeasureFn») ([«?TEMP», Const.«KelvinDegree»])]), ap (Const.«greaterThan») ([«?TEMP», «?BOIL»])]) (ap (Const.«attribute») ([«?X», Const.«Gas»]))))))),
mkForall (fun («?BOIL» : Obj) => mkForall (fun («?MELT» : Obj) => mkForall (fun («?TEMP» : Obj) => mkForall (fun («?X» : Obj) => mkForall (fun («?Y» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?X», «?Y»]), ap (Const.«subclass») ([«?Y», Const.«PureSubstance»]), ap (Const.«boilingPoint») ([«?Y», ap (Const.«MeasureFn») ([«?BOIL», Const.«KelvinDegree»])]), ap (Const.«meltingPoint») ([«?Y», ap (Const.«MeasureFn») ([«?MELT», Const.«KelvinDegree»])]), ap (Const.«measure») ([«?X», ap (Const.«MeasureFn») ([«?TEMP», Const.«KelvinDegree»])]), ap (Const.«greaterThan») ([«?TEMP», «?MELT»]), ap (Const.«lessThan») ([«?TEMP», «?BOIL»])]) (ap (Const.«attribute») ([«?X», Const.«Liquid»]))))))),
mkForall (fun («?MELT» : Obj) => mkForall (fun («?PRES» : Obj) => mkForall (fun («?TEMP» : Obj) => mkForall (fun («?X» : Obj) => mkForall (fun («?Y» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?X», «?Y»]), ap (Const.«subclass») ([«?Y», Const.«PureSubstance»]), ap (Const.«meltingPoint») ([«?Y», ap (Const.«MeasureFn») ([«?MELT», Const.«KelvinDegree»])]), ap (Const.«barometricPressure») ([«?X», ap (Const.«MeasureFn») ([«?PRES», Const.«InchMercury»])]), ap (Const.«greaterThan») ([«?PRES», numLit "29.92"]), ap (Const.«measure») ([«?X», ap (Const.«MeasureFn») ([«?TEMP», Const.«KelvinDegree»])]), ap (Const.«lessThan») ([«?TEMP», «?MELT»])]) (ap (Const.«attribute») ([«?X», Const.«Solid»]))))))),
mkForall (fun («?BOILING» : Obj) => mkForall (fun («?MEASURE» : Obj) => mkForall (fun («?SUBSTANCE» : Obj) => mkForall (fun («?TEMP1» : Obj) => mkForall (fun («?TEMP2» : Obj) => mkForall (fun («?TYPE» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?BOILING», Const.«Boiling»]), ap (Const.«boilingPoint») ([«?TYPE», ap (Const.«MeasureFn») ([«?TEMP1», «?MEASURE»])]), ap (Const.«instance») ([«?SUBSTANCE», «?TYPE»]), ap (Const.«patient») ([«?BOILING», «?SUBSTANCE»]), ap (Const.«holdsDuring») ([ap (Const.«WhenFn») ([«?BOILING»]), ap (Const.«measure») ([«?SUBSTANCE», ap (Const.«MeasureFn») ([«?TEMP2», «?MEASURE»])])]), ap (Const.«instance») ([«?MEASURE», Const.«UnitOfTemperature»])]) (ap (Const.«greaterThanOrEqualTo») ([«?TEMP2», «?TEMP1»])))))))),
mkForall (fun («?MEASURE» : Obj) => mkForall (fun («?SUBSTANCE» : Obj) => mkForall (fun («?TEMP1» : Obj) => mkForall (fun («?TEMP2» : Obj) => mkForall (fun («?TIME» : Obj) => mkForall (fun («?TYPE» : Obj) => mkImp (mkAnd [ap (Const.«boilingPoint») ([«?TYPE», ap (Const.«MeasureFn») ([«?TEMP1», «?MEASURE»])]), ap (Const.«instance») ([«?SUBSTANCE», «?TYPE»]), ap (Const.«holdsDuring») ([«?TIME», ap (Const.«measure») ([«?SUBSTANCE», ap (Const.«MeasureFn») ([«?TEMP2», «?MEASURE»])])]), ap (Const.«instance») ([«?MEASURE», Const.«UnitOfTemperature»]), ap (Const.«greaterThanOrEqualTo») ([«?TEMP2», «?TEMP1»])]) (mkOr [ap (Const.«holdsDuring») ([«?TIME», ap (Const.«attribute») ([«?SUBSTANCE», Const.«Gas»])]), mkExists (fun («?BOIL» : Obj) => mkAnd [ap (Const.«overlapsTemporally») ([ap (Const.«WhenFn») ([«?BOIL»]), «?TIME»]), ap (Const.«instance») ([«?BOIL», Const.«Boiling»]), ap (Const.«patient») ([«?BOIL», «?SUBSTANCE»])])]))))))),
ap (Const.«instance») ([Const.«meltingPoint», Const.«BinaryPredicate»]),
mkForall (fun («?MEASURE» : Obj) => mkForall (fun («?SUBSTANCE» : Obj) => mkForall (fun («?TEMP1» : Obj) => mkForall (fun («?TEMP2» : Obj) => mkForall (fun («?TEMP3» : Obj) => mkForall (fun («?TIME» : Obj) => mkForall (fun («?TYPE» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?SUBSTANCE», «?TYPE»]), ap (Const.«boilingPoint») ([«?TYPE», ap (Const.«MeasureFn») ([«?TEMP1», «?MEASURE»])]), ap (Const.«meltingPoint») ([«?TYPE», ap (Const.«MeasureFn») ([«?TEMP2», «?MEASURE»])]), ap (Const.«instance») ([«?MEASURE», Const.«UnitOfTemperature»]), ap (Const.«holdsDuring») ([«?TIME», ap (Const.«measure») ([«?SUBSTANCE», ap (Const.«MeasureFn») ([«?TEMP3», «?MEASURE»])])]), ap (Const.«greaterThan») ([«?TEMP3», «?TEMP2»]), ap (Const.«lessThan») ([«?TEMP3», «?TEMP1»])]) (mkOr [ap (Const.«holdsDuring») ([«?TIME», ap (Const.«attribute») ([«?SUBSTANCE», Const.«Liquid»])]), mkExists (fun («?MELT» : Obj) => mkAnd [ap (Const.«overlapsTemporally») ([ap (Const.«WhenFn») ([«?MELT»]), «?TIME»]), ap (Const.«instance») ([«?MELT», Const.«Melting»]), ap (Const.«patient») ([«?MELT», «?SUBSTANCE»])])])))))))),
mkForall (fun («?MEASURE» : Obj) => mkForall (fun («?SUBSTANCE» : Obj) => mkForall (fun («?TEMP1» : Obj) => mkForall (fun («?TEMP2» : Obj) => mkForall (fun («?TIME» : Obj) => mkForall (fun («?TYPE» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?SUBSTANCE», «?TYPE»]), ap (Const.«meltingPoint») ([«?TYPE», ap (Const.«MeasureFn») ([«?TEMP1», «?MEASURE»])]), ap (Const.«holdsDuring») ([«?TIME», ap (Const.«measure») ([«?SUBSTANCE», ap (Const.«MeasureFn») ([«?TEMP2», «?MEASURE»])])]), ap (Const.«instance») ([«?MEASURE», Const.«UnitOfTemperature»]), ap (Const.«lessThan») ([«?TEMP2», «?TEMP1»])]) (mkOr [ap (Const.«holdsDuring») ([«?TIME», ap (Const.«attribute») ([«?SUBSTANCE», Const.«Solid»])]), mkExists (fun («?FREEZE» : Obj) => mkAnd [ap (Const.«overlapsTemporally») ([ap (Const.«WhenFn») ([«?FREEZE»]), «?TIME»]), ap (Const.«instance») ([«?FREEZE», Const.«Freezing»]), ap (Const.«patient») ([«?FREEZE», «?SUBSTANCE»])])]))))))),
mkForall (fun («?BOIL» : Obj) => mkForall (fun («?MELT» : Obj) => mkForall (fun («?TYPE» : Obj) => mkForall (fun («?U» : Obj) => mkImp (mkAnd [ap (Const.«meltingPoint») ([«?TYPE», ap (Const.«MeasureFn») ([«?MELT», «?U»])]), ap (Const.«boilingPoint») ([«?TYPE», ap (Const.«MeasureFn») ([«?BOIL», «?U»])])]) (ap (Const.«greaterThanOrEqualTo») ([«?BOIL», «?MELT»])))))),
ap (Const.«subclass») ([Const.«Melting», Const.«StateChange»]),
mkForall (fun («?MELT» : Obj) => mkImp (ap (Const.«instance») ([«?MELT», Const.«Melting»])) (mkExists (fun («?HEAT» : Obj) => mkAnd [ap (Const.«instance») ([«?HEAT», Const.«Heating»]), ap (Const.«subProcess») ([«?HEAT», «?MELT»])]))),
mkForall (fun («?MELT» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?MELT», Const.«Melting»]), ap (Const.«patient») ([«?MELT», «?OBJ»])]) (mkExists (fun («?PART» : Obj) => mkAnd [ap (Const.«part») ([«?PART», «?OBJ»]), ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?MELT»])]), ap (Const.«attribute») ([«?PART», Const.«Solid»])]), ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?MELT»])]), ap (Const.«attribute») ([«?PART», Const.«Liquid»])])])))),
ap (Const.«subclass») ([Const.«Boiling», Const.«StateChange»]),
mkForall (fun («?BOIL» : Obj) => mkImp (ap (Const.«instance») ([«?BOIL», Const.«Boiling»])) (mkExists (fun («?HEAT» : Obj) => mkAnd [ap (Const.«instance») ([«?HEAT», Const.«Heating»]), ap (Const.«subProcess») ([«?HEAT», «?BOIL»])]))),
mkForall (fun («?BOIL» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?BOIL», Const.«Boiling»]), ap (Const.«patient») ([«?BOIL», «?OBJ»])]) (mkExists (fun («?PART» : Obj) => mkAnd [ap (Const.«part») ([«?PART», «?OBJ»]), ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?BOIL»])]), ap (Const.«attribute») ([«?PART», Const.«Liquid»])]), ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?BOIL»])]), ap (Const.«attribute») ([«?PART», Const.«Gas»])])])))),
mkForall (fun («?L» : Obj) => mkImp (ap (Const.«attribute») ([«?L», Const.«Liquid»])) (ap (Const.«capability») ([Const.«Boiling», Const.«patient», «?L»]))),
ap (Const.«subclass») ([Const.«Evaporating», Const.«StateChange»]),
mkForall (fun («?BOILVAL» : Obj) => mkForall (fun («?CLASS» : Obj) => mkForall (fun («?EVAP» : Obj) => mkForall (fun («?MEAS» : Obj) => mkForall (fun («?OBJ» : Obj) => mkForall (fun («?VAL» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?EVAP», Const.«Evaporating»]), ap (Const.«boilingPoint») ([«?CLASS», ap (Const.«MeasureFn») ([«?BOILVAL», «?MEAS»])]), ap (Const.«instance») ([«?OBJ», «?CLASS»]), ap (Const.«measure») ([«?OBJ», ap (Const.«MeasureFn») ([«?VAL», «?MEAS»])]), ap (Const.«instance») ([«?MEAS», Const.«UnitOfTemperature»]), ap (Const.«patient») ([«?EVAP», «?OBJ»])]) (mkExists (fun («?PART» : Obj) => mkAnd [ap (Const.«part») ([«?PART», «?OBJ»]), ap (Const.«greaterThan») ([«?BOILVAL», «?VAL»]), ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?EVAP»])]), ap (Const.«attribute») ([«?PART», Const.«Liquid»])]), ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?EVAP»])]), ap (Const.«attribute») ([«?PART», Const.«Gas»])])])))))))),
ap (Const.«subclass») ([Const.«Condensing», Const.«StateChange»]),
mkForall (fun («?COND» : Obj) => mkImp (ap (Const.«instance») ([«?COND», Const.«Condensing»])) (mkExists (fun («?COOL» : Obj) => mkAnd [ap (Const.«instance») ([«?COOL», Const.«Cooling»]), ap (Const.«subProcess») ([«?COOL», «?COND»])]))),
mkForall (fun («?COND» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?COND», Const.«Condensing»]), ap (Const.«patient») ([«?COND», «?OBJ»])]) (mkExists (fun («?PART» : Obj) => mkAnd [ap (Const.«part») ([«?PART», «?OBJ»]), ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?COND»])]), ap (Const.«attribute») ([«?PART», Const.«Gas»])]), ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?COND»])]), ap (Const.«attribute») ([«?PART», Const.«Liquid»])])])))),
ap (Const.«subclass») ([Const.«Freezing», Const.«StateChange»]),
mkForall (fun («?FREEZE» : Obj) => mkImp (ap (Const.«instance») ([«?FREEZE», Const.«Freezing»])) (mkExists (fun («?COOL» : Obj) => mkAnd [ap (Const.«instance») ([«?COOL», Const.«Cooling»]), ap (Const.«subProcess») ([«?COOL», «?FREEZE»])]))),
mkForall (fun («?FREEZE» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?FREEZE», Const.«Freezing»]), ap (Const.«patient») ([«?FREEZE», «?OBJ»])]) (mkExists (fun («?PART» : Obj) => mkAnd [ap (Const.«part») ([«?PART», «?OBJ»]), ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?FREEZE»])]), ap (Const.«attribute») ([«?PART», Const.«Liquid»])]), ap (Const.«holdsDuring») ([ap (Const.«EndFn») ([ap (Const.«WhenFn») ([«?FREEZE»])]), ap (Const.«attribute») ([«?PART», Const.«Solid»])])])))),
ap (Const.«subclass») ([Const.«AstronomicalBody», Const.«Object»]),
ap (Const.«disjoint») ([Const.«AstronomicalBody», Const.«GeographicArea»]),
ap (Const.«subclass») ([Const.«GeographicArea», Const.«Region»]),
ap (Const.«partition») ([Const.«GeographicArea», Const.«WaterArea», Const.«LandArea»]),
ap (Const.«subclass») ([Const.«LocalizablePlace», Const.«GeographicArea»]),
ap (Const.«instance») ([Const.«geographicSubregion», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«geographicSubregion», Const.«TransitiveRelation»]),
ap (Const.«instance») ([Const.«geographicSubregion», Const.«AsymmetricRelation»]),
ap (Const.«subrelation») ([Const.«geographicSubregion», Const.«properPart»]),
ap (Const.«subrelation») ([Const.«geographicSubregion», Const.«located»]),
ap (Const.«subclass») ([Const.«GeopoliticalArea», Const.«GeographicArea»]),
ap (Const.«subclass») ([Const.«GeopoliticalArea», Const.«AutonomousAgent»]),
mkForall (fun («?AREA» : Obj) => mkForall (fun («?PERSON» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?AREA», Const.«GeopoliticalArea»]), ap (Const.«leader») ([ap (Const.«GovernmentFn») ([«?AREA»]), «?PERSON»])]) (ap (Const.«leader») ([«?AREA», «?PERSON»])))),
mkForall (fun («?AREA» : Obj) => mkForall (fun («?PERSON» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?AREA», Const.«GeopoliticalArea»]), ap (Const.«leader») ([«?AREA», «?PERSON»])]) (ap (Const.«leader») ([ap (Const.«GovernmentFn») ([«?AREA»]), «?PERSON»])))),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?EVENT» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?EVENT», Const.«Election»]), ap (Const.«agent») ([«?EVENT», «?AGENT»]), ap (Const.«instance») ([«?AGENT», Const.«GeopoliticalArea»])]) (ap (Const.«instance») ([«?EVENT», Const.«PoliticalProcess»])))),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?AREA» : Obj) => mkForall (fun («?EVENT» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?EVENT», Const.«Election»]), ap (Const.«agent») ([«?EVENT», «?AGENT»]), ap (Const.«instance») ([«?AREA», Const.«GeopoliticalArea»]), ap (Const.«instance») ([«?AGENT», ap (Const.«GovernmentFn») ([«?AREA»])])]) (ap (Const.«instance») ([«?EVENT», Const.«PoliticalProcess»]))))),
ap (Const.«instance») ([Const.«geopoliticalSubdivision», Const.«AsymmetricRelation»]),
ap (Const.«instance») ([Const.«geopoliticalSubdivision», Const.«TransitiveRelation»]),
ap (Const.«subrelation») ([Const.«geopoliticalSubdivision», Const.«geographicSubregion»]),
ap (Const.«subclass») ([Const.«WaterArea», Const.«GeographicArea»]),
mkForall (fun («?AREA» : Obj) => mkImp (ap (Const.«instance») ([«?AREA», Const.«WaterArea»])) (mkExists (fun («?BED» : Obj) => mkExists (fun («?HOLE» : Obj) => mkExists (fun («?WATER» : Obj) => mkAnd [ap (Const.«equal») ([ap (Const.«HoleHostFn») ([«?HOLE»]), «?BED»]), ap (Const.«instance») ([«?WATER», Const.«Water»]), ap (Const.«properlyFills») ([«?WATER», «?HOLE»]), ap (Const.«equal») ([ap (Const.«MereologicalSumFn») ([«?BED», «?WATER»]), «?AREA»])]))))),
ap (Const.«subclass») ([Const.«SaltWaterArea», Const.«WaterArea»]),
ap (Const.«disjoint») ([Const.«SaltWaterArea», Const.«FreshWaterArea»]),
ap (Const.«subclass») ([Const.«FreshWaterArea», Const.«WaterArea»]),
ap (Const.«subclass») ([Const.«LandArea», Const.«GeographicArea»]),
mkForall (fun («?LAND1» : Obj) => mkImp (ap (Const.«instance») ([«?LAND1», Const.«LandArea»])) (mkExists (fun («?LAND2» : Obj) => mkAnd [ap (Const.«part») ([«?LAND1», «?LAND2»]), mkOr [ap (Const.«instance») ([«?LAND2», Const.«Continent»]), ap (Const.«instance») ([«?LAND2», Const.«Island»])]]))),
ap (Const.«subclass») ([Const.«ShoreArea», Const.«LandArea»]),
mkForall (fun («?BANK» : Obj) => mkImp (ap (Const.«instance») ([«?BANK», Const.«ShoreArea»])) (mkExists (fun («?WATER» : Obj) => mkAnd [ap (Const.«instance») ([«?WATER», Const.«WaterArea»]), ap (Const.«meetsSpatially») ([«?BANK», «?WATER»])]))),
ap (Const.«subclass») ([Const.«Continent», Const.«LandArea»]),
ap (Const.«equal») ([ap (Const.«CardinalityFn») ([Const.«Continent»]), numLit "7"]),
ap (Const.«subclass») ([Const.«Island», Const.«LandArea»]),
mkForall (fun («?ISLAND» : Obj) => mkImp (ap (Const.«instance») ([«?ISLAND», Const.«Island»])) (mkNot (mkExists (fun («?AREA» : Obj) => mkExists (fun («?PART1» : Obj) => mkExists (fun («?PART2» : Obj) => mkAnd [ap (Const.«instance») ([«?AREA», Const.«LandArea»]), ap (Const.«part») ([«?PART1», «?ISLAND»]), ap (Const.«part») ([«?PART2», «?AREA»]), mkNot (ap (Const.«part») ([«?ISLAND», «?AREA»])), mkNot (ap (Const.«part») ([«?AREA», «?ISLAND»])), ap (Const.«meetsSpatially») ([«?PART1», «?PART2»])])))))),
mkForall (fun («?AREA» : Obj) => mkForall (fun («?ISLE» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?ISLE», Const.«Island»]), ap (Const.«instance») ([«?AREA», Const.«GeographicArea»]), ap (Const.«meetsSpatially») ([«?ISLE», «?AREA»])]) (mkNot (ap (Const.«instance») ([«?AREA», Const.«LandArea»]))))),
mkForall (fun («?ISLE» : Obj) => mkImp (ap (Const.«instance») ([«?ISLE», Const.«Island»])) (mkExists (fun («?WATER» : Obj) => mkAnd [ap (Const.«instance») ([«?WATER», Const.«WaterArea»]), ap (Const.«meetsSpatially») ([«?ISLE», «?WATER»])]))),
ap (Const.«subclass») ([Const.«Nation», Const.«GeopoliticalArea»]),
ap (Const.«subclass») ([Const.«Nation», Const.«LandArea»]),
ap (Const.«subclass») ([Const.«StateOrProvince», Const.«GeopoliticalArea»]),
ap (Const.«subclass») ([Const.«StateOrProvince», Const.«LandArea»]),
mkForall (fun («?STATE» : Obj) => mkImp (ap (Const.«instance») ([«?STATE», Const.«StateOrProvince»])) (mkExists (fun («?LAND» : Obj) => mkAnd [ap (Const.«instance») ([«?LAND», Const.«Nation»]), ap (Const.«properPart») ([«?STATE», «?LAND»])]))),
ap (Const.«subclass») ([Const.«City», Const.«GeopoliticalArea»]),
ap (Const.«subclass») ([Const.«City», Const.«LandArea»]),
ap (Const.«subclass») ([Const.«County», Const.«GeopoliticalArea»]),
ap (Const.«subclass») ([Const.«County», Const.«LandArea»]),
mkForall (fun («?STATE» : Obj) => mkImp (ap (Const.«instance») ([«?STATE», Const.«County»])) (mkExists (fun («?LAND» : Obj) => mkAnd [ap (Const.«instance») ([«?LAND», Const.«StateOrProvince»]), ap (Const.«properPart») ([«?STATE», «?LAND»])]))),
ap (Const.«subclass») ([Const.«Transitway», Const.«Region»]),
ap (Const.«subclass») ([Const.«Transitway», Const.«SelfConnectedObject»]),
mkForall (fun («?WAY» : Obj) => mkImp (ap (Const.«instance») ([«?WAY», Const.«Transitway»])) (ap (Const.«hasPurpose») ([«?WAY», mkExists (fun («?TRANSPORT» : Obj) => mkAnd [ap (Const.«instance») ([«?TRANSPORT», Const.«Translocation»]), ap (Const.«path») ([«?TRANSPORT», «?WAY»])])]))),
ap (Const.«subclass») ([Const.«LandTransitway», Const.«Transitway»]),
ap (Const.«subclass») ([Const.«LandTransitway», Const.«LandArea»]),
mkForall (fun («?WAY» : Obj) => mkImp (ap (Const.«instance») ([«?WAY», Const.«LandTransitway»])) (ap (Const.«hasPurpose») ([«?WAY», mkExists (fun («?MOVE» : Obj) => mkExists (fun («?LAND» : Obj) => mkAnd [ap (Const.«instance») ([«?MOVE», Const.«Translocation»]), ap (Const.«path») ([«?MOVE», «?WAY»]), ap (Const.«eventLocated») ([«?MOVE», «?LAND»]), ap (Const.«instance») ([«?LAND», Const.«LandArea»])]))]))),
ap (Const.«subclass») ([Const.«Roadway», Const.«LandTransitway»]),
ap (Const.«subclass») ([Const.«Water», Const.«CompoundSubstance»]),
ap (Const.«subclass») ([Const.«Mineral», Const.«Substance»]),
ap (Const.«instance») ([Const.«developmentalForm», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«developmentalForm», Const.«AsymmetricRelation»]),
ap (Const.«instance») ([Const.«developmentalForm», Const.«TransitiveRelation»]),
ap (Const.«subrelation») ([Const.«developmentalForm», Const.«attribute»]),
mkForall (fun («?ATTR1» : Obj) => mkForall (fun («?ATTR2» : Obj) => mkForall (fun («?OBJ» : Obj) => mkForall (fun («?TIME1» : Obj) => mkImp (mkAnd [ap (Const.«holdsDuring») ([«?TIME1», ap (Const.«developmentalForm») ([«?OBJ», «?ATTR1»])]), ap (Const.«successorAttributeClosure») ([«?ATTR2», «?ATTR1»])]) (mkExists (fun («?TIME2» : Obj) => mkAnd [ap (Const.«earlier») ([«?TIME2», «?TIME1»]), ap (Const.«holdsDuring») ([«?TIME2», ap (Const.«developmentalForm») ([«?OBJ», «?ATTR2»])])])))))),
ap (Const.«subclass») ([Const.«OrganicObject», Const.«CorpuscularObject»]),
ap (Const.«subclass») ([Const.«OrganicObject», Const.«OrganicThing»]),
ap (Const.«partition») ([Const.«OrganicObject», Const.«Organism», Const.«AnatomicalStructure»]),
ap (Const.«subclass») ([Const.«Organism», Const.«OrganicObject»]),
ap (Const.«subclass») ([Const.«Organism», Const.«AutonomousAgent»]),
ap (Const.«disjoint») ([Const.«Organism», Const.«Artifact»]),
ap (Const.«partition») ([Const.«Organism», Const.«Animal», Const.«Plant», Const.«Fungus», Const.«Microorganism»]),
mkForall (fun («?ORGANISM» : Obj) => mkImp (ap (Const.«instance») ([«?ORGANISM», Const.«Organism»])) (mkExists (fun («?BIRTH» : Obj) => mkAnd [ap (Const.«instance») ([«?BIRTH», Const.«Birth»]), ap (Const.«experiencer») ([«?BIRTH», «?ORGANISM»])]))),
ap (Const.«instance») ([Const.«inhabits», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«inhabits», Const.«AsymmetricRelation»]),
mkForall (fun («?OBJ» : Obj) => mkForall (fun («?ORGANISM» : Obj) => mkForall (fun («?T1» : Obj) => mkImp (ap (Const.«holdsDuring») ([«?T1», ap (Const.«inhabits») ([«?ORGANISM», «?OBJ»])])) (mkExists (fun («?TIME» : Obj) => mkAnd [ap (Const.«instance») ([«?TIME», Const.«TimeInterval»]), ap (Const.«temporalPart») ([«?TIME», «?T1»]), ap (Const.«holdsDuring») ([«?TIME», ap (Const.«located») ([«?ORGANISM», «?OBJ»])])]))))),
ap (Const.«subrelation») ([Const.«home», Const.«inhabits»]),
ap (Const.«instance») ([Const.«home», Const.«BinaryPredicate»]),
ap (Const.«subrelation») ([Const.«stays», Const.«inhabits»]),
ap (Const.«instance») ([Const.«stays», Const.«BinaryPredicate»]),
ap (Const.«disjointRelation») ([Const.«stays», Const.«home»]),
ap (Const.«subclass») ([Const.«Plant», Const.«Organism»]),
ap (Const.«subclass») ([Const.«FloweringPlant», Const.«Plant»]),
ap (Const.«subclass») ([Const.«NonFloweringPlant», Const.«Plant»]),
ap (Const.«disjoint») ([Const.«NonFloweringPlant», Const.«FloweringPlant»]),
ap (Const.«disjointDecomposition») ([Const.«NonFloweringPlant», Const.«Alga», Const.«Fern», Const.«Moss»]),
ap (Const.«subclass») ([Const.«Alga», Const.«NonFloweringPlant»]),
mkForall (fun («?ALGA» : Obj) => mkImp (ap (Const.«instance») ([«?ALGA», Const.«Alga»])) (mkExists (fun («?WATER» : Obj) => mkAnd [ap (Const.«inhabits») ([«?ALGA», «?WATER»]), ap (Const.«instance») ([«?WATER», Const.«Water»])]))),
ap (Const.«subclass») ([Const.«Fungus», Const.«Organism»]),
mkForall (fun («?FUNGUS» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?FUNGUS», Const.«Fungus»]), ap (Const.«inhabits») ([«?FUNGUS», «?OBJ»])]) (ap (Const.«instance») ([«?OBJ», Const.«Organism»])))),
ap (Const.«subclass») ([Const.«Moss», Const.«NonFloweringPlant»]),
ap (Const.«subclass») ([Const.«Fern», Const.«NonFloweringPlant»]),
ap (Const.«subclass») ([Const.«Animal», Const.«Organism»]),
ap (Const.«partition») ([Const.«Animal», Const.«Vertebrate», Const.«Invertebrate»]),
ap (Const.«subclass») ([Const.«Microorganism», Const.«Organism»]),
ap (Const.«subclass») ([Const.«Bacterium», Const.«Microorganism»]),
mkForall (fun («?BACTERIUM» : Obj) => mkImp (ap (Const.«instance») ([«?BACTERIUM», Const.«Bacterium»])) (mkExists (fun («?CELL1» : Obj) => mkAnd [ap (Const.«component») ([«?CELL1», «?BACTERIUM»]), ap (Const.«instance») ([«?CELL1», Const.«Cell»]), mkForall (fun («?CELL2» : Obj) => mkImp (mkAnd [ap (Const.«component») ([«?CELL2», «?BACTERIUM»]), ap (Const.«instance») ([«?CELL2», Const.«Cell»])]) (ap (Const.«equal») ([«?CELL1», «?CELL2»])))]))),
mkForall (fun («?BACTERIUM» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?BACTERIUM», Const.«Bacterium»]), ap (Const.«inhabits») ([«?BACTERIUM», «?OBJ»])]) (ap (Const.«instance») ([«?OBJ», Const.«Organism»])))),
ap (Const.«subclass») ([Const.«Virus», Const.«Microorganism»]),
mkForall (fun («?OBJ» : Obj) => mkForall (fun («?VIRUS» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?VIRUS», Const.«Virus»]), ap (Const.«inhabits») ([«?VIRUS», «?OBJ»])]) (ap (Const.«instance») ([«?OBJ», Const.«Organism»])))),
mkForall (fun («?PROC» : Obj) => mkForall (fun («?VIRUS» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?VIRUS», Const.«Virus»]), ap (Const.«instance») ([«?PROC», Const.«Replication»]), ap (Const.«agent») ([«?PROC», «?VIRUS»])]) (mkExists (fun («?CELL» : Obj) => mkAnd [ap (Const.«located») ([«?PROC», «?CELL»]), ap (Const.«instance») ([«?CELL», Const.«Cell»])])))),
ap (Const.«subclass») ([Const.«Vertebrate», Const.«Animal»]),
ap (Const.«subclass») ([Const.«Invertebrate», Const.«Animal»]),
ap (Const.«disjointDecomposition») ([Const.«Invertebrate», Const.«Worm», Const.«Mollusk», Const.«Arthropod»]),
ap (Const.«subclass») ([Const.«Worm», Const.«Invertebrate»]),
ap (Const.«subclass») ([Const.«Leech», Const.«Worm»]),
ap (Const.«subclass») ([Const.«Mollusk», Const.«Invertebrate»]),
ap (Const.«subclass») ([Const.«Arthropod», Const.«Invertebrate»]),
ap (Const.«disjointDecomposition») ([Const.«Arthropod», Const.«Arachnid», Const.«Myriapod», Const.«Insect», Const.«Crustacean»]),
ap (Const.«subclass») ([Const.«Arachnid», Const.«Arthropod»]),
ap (Const.«subclass») ([Const.«Myriapod», Const.«Arthropod»]),
ap (Const.«subclass») ([Const.«Insect», Const.«Arthropod»]),
ap (Const.«subclass») ([Const.«Crustacean», Const.«Arthropod»]),
ap (Const.«subclass») ([Const.«ColdBloodedVertebrate», Const.«Vertebrate»]),
ap (Const.«disjointDecomposition») ([Const.«ColdBloodedVertebrate», Const.«Amphibian», Const.«Fish», Const.«Reptile»]),
ap (Const.«subclass») ([Const.«WarmBloodedVertebrate», Const.«Vertebrate»]),
ap (Const.«disjoint») ([Const.«WarmBloodedVertebrate», Const.«ColdBloodedVertebrate»]),
ap (Const.«subclass») ([Const.«Amphibian», Const.«ColdBloodedVertebrate»]),
ap (Const.«subclass») ([Const.«Bird», Const.«WarmBloodedVertebrate»]),
ap (Const.«disjoint») ([Const.«Bird», Const.«Mammal»]),
ap (Const.«subclass») ([Const.«Fish», Const.«ColdBloodedVertebrate»]),
mkForall (fun («?FISH» : Obj) => mkImp (ap (Const.«instance») ([«?FISH», Const.«Fish»])) (mkExists (fun («?WATER» : Obj) => mkAnd [ap (Const.«inhabits») ([«?FISH», «?WATER»]), ap (Const.«instance») ([«?WATER», Const.«Water»])]))),
ap (Const.«subclass») ([Const.«Mammal», Const.«WarmBloodedVertebrate»]),
ap (Const.«disjointDecomposition») ([Const.«Mammal», Const.«AquaticMammal», Const.«HoofedMammal», Const.«Marsupial», Const.«Rodent», Const.«Primate»]),
ap (Const.«subclass») ([Const.«AquaticMammal», Const.«Mammal»]),
ap (Const.«subclass») ([Const.«HoofedMammal», Const.«Mammal»]),
ap (Const.«subclass») ([Const.«Marsupial», Const.«Mammal»]),
ap (Const.«subclass») ([Const.«Carnivore», Const.«Organism»]),
mkForall (fun («?CARNIVORE» : Obj) => mkForall (fun («?EAT» : Obj) => mkForall (fun («?PREY» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?CARNIVORE», Const.«Carnivore»]), ap (Const.«instance») ([«?EAT», Const.«Eating»]), ap (Const.«agent») ([«?EAT», «?CARNIVORE»]), ap (Const.«patient») ([«?EAT», «?PREY»])]) (ap (Const.«instance») ([«?PREY», Const.«Animal»]))))),
ap (Const.«subclass») ([Const.«Canine», Const.«Carnivore»]),
ap (Const.«disjoint») ([Const.«Canine», Const.«Feline»]),
ap (Const.«subclass») ([Const.«Feline», Const.«Carnivore»]),
ap (Const.«subclass») ([Const.«Rodent», Const.«Mammal»]),
ap (Const.«subclass») ([Const.«Primate», Const.«Mammal»]),
ap (Const.«disjointDecomposition») ([Const.«Primate», Const.«Ape», Const.«Monkey», Const.«Hominid»]),
ap (Const.«subclass») ([Const.«Ape», Const.«Primate»]),
ap (Const.«subclass») ([Const.«Monkey», Const.«Primate»]),
ap (Const.«subclass») ([Const.«Hominid», Const.«Primate»]),
ap (Const.«subclass») ([Const.«Human», Const.«Hominid»]),
ap (Const.«subclass») ([Const.«Human», Const.«CognitiveAgent»]),
ap (Const.«partition») ([Const.«Human», Const.«Man», Const.«Woman»]),
ap (Const.«subclass») ([Const.«Man», Const.«Human»]),
mkForall (fun («?MAN» : Obj) => mkImp (ap (Const.«instance») ([«?MAN», Const.«Man»])) (ap (Const.«attribute») ([«?MAN», Const.«Male»]))),
ap (Const.«subclass») ([Const.«Woman», Const.«Human»]),
mkForall (fun («?WOMAN» : Obj) => mkImp (ap (Const.«instance») ([«?WOMAN», Const.«Woman»])) (ap (Const.«attribute») ([«?WOMAN», Const.«Female»]))),
ap (Const.«subclass») ([Const.«Reptile», Const.«ColdBloodedVertebrate»]),
ap (Const.«subclass») ([Const.«BiologicallyActiveSubstance», Const.«Substance»]),
ap (Const.«subclass») ([Const.«Nutrient», Const.«BiologicallyActiveSubstance»]),
ap (Const.«disjointDecomposition») ([Const.«Nutrient», Const.«Protein», Const.«Carbohydrate», Const.«Vitamin»]),
ap (Const.«relatedInternalConcept») ([Const.«Nutrient», Const.«Food»]),
ap (Const.«subclass») ([Const.«Protein», Const.«Nutrient»]),
ap (Const.«subclass») ([Const.«Enzyme», Const.«Protein»]),
ap (Const.«subclass») ([Const.«Carbohydrate», Const.«Nutrient»]),
ap (Const.«subclass») ([Const.«Carbohydrate», Const.«CompoundSubstance»]),
ap (Const.«subclass») ([Const.«Vitamin», Const.«Nutrient»]),
ap (Const.«subclass») ([Const.«LiquidMixture», Const.«Mixture»]),
ap (Const.«partition») ([Const.«LiquidMixture», Const.«Solution», Const.«Suspension»]),
mkForall (fun («?MIX» : Obj) => mkImp (ap (Const.«instance») ([«?MIX», Const.«LiquidMixture»])) (mkExists (fun («?PART» : Obj) => mkAnd [ap (Const.«part») ([«?PART», «?MIX»]), ap (Const.«attribute») ([«?PART», Const.«Liquid»])]))),
ap (Const.«subclass») ([Const.«Solution», Const.«LiquidMixture»]),
ap (Const.«subclass») ([Const.«Suspension», Const.«LiquidMixture»]),
ap (Const.«subclass») ([Const.«Suspension», Const.«GasMixture»]),
ap (Const.«subclass») ([Const.«GasMixture», Const.«Mixture»]),
ap (Const.«disjoint») ([Const.«GasMixture», Const.«LiquidMixture»]),
mkForall (fun («?MIX» : Obj) => mkImp (ap (Const.«instance») ([«?MIX», Const.«GasMixture»])) (mkExists (fun («?PART» : Obj) => mkAnd [ap (Const.«part») ([«?PART», «?MIX»]), ap (Const.«attribute») ([«?PART», Const.«Gas»])]))),
ap (Const.«subclass») ([Const.«Cloud», Const.«GasMixture»]),
mkForall (fun («?CLOUD» : Obj) => mkImp (ap (Const.«instance») ([«?CLOUD», Const.«Cloud»])) (ap (Const.«capability») ([Const.«Seeing», Const.«patient», «?CLOUD»]))),
ap (Const.«subclass») ([Const.«Smoke», Const.«Cloud»]),
mkForall (fun («?SMOKE» : Obj) => mkImp (ap (Const.«instance») ([«?SMOKE», Const.«Smoke»])) (mkExists (fun («?BURNING» : Obj) => mkAnd [ap (Const.«instance») ([«?BURNING», Const.«Combustion»]), ap (Const.«result») ([«?BURNING», «?SMOKE»])]))),
ap (Const.«subclass») ([Const.«WaterCloud», Const.«Cloud»]),
mkForall (fun («?CLOUD» : Obj) => mkImp (ap (Const.«instance») ([«?CLOUD», Const.«WaterCloud»])) (mkExists (fun («?WATER» : Obj) => mkAnd [ap (Const.«instance») ([«?WATER», Const.«Water»]), ap (Const.«part») ([«?WATER», «?CLOUD»])]))),
mkForall (fun («?CLOUD» : Obj) => mkImp (ap (Const.«instance») ([«?CLOUD», Const.«WaterCloud»])) (mkForall (fun («?PART» : Obj) => mkImp (mkAnd [ap (Const.«part») ([«?PART», «?CLOUD»]), mkNot (ap (Const.«instance») ([«?PART», Const.«Water»]))]) (mkExists (fun («?WATER» : Obj) => mkExists (fun («?MEASURE1» : Obj) => mkExists (fun («?MEASURE2» : Obj) => mkExists (fun («?U» : Obj) => mkAnd [ap (Const.«instance») ([«?WATER», Const.«Water»]), ap (Const.«part») ([«?WATER», «?CLOUD»]), ap (Const.«measure») ([«?WATER», ap (Const.«MeasureFn») ([«?MEASURE1», «?U»])]), ap (Const.«measure») ([«?PART», ap (Const.«MeasureFn») ([«?MEASURE2», «?U»])]), ap (Const.«greaterThan») ([«?MEASURE1», «?MEASURE2»])])))))))),
ap (Const.«subclass») ([Const.«Air», Const.«GasMixture»]),
mkForall (fun («?WIND» : Obj) => mkImp (ap (Const.«instance») ([«?WIND», Const.«Wind»])) (mkExists (fun («?AIR» : Obj) => mkAnd [ap (Const.«patient») ([«?WIND», «?AIR»]), ap (Const.«instance») ([«?AIR», Const.«Air»])]))),
ap (Const.«subclass») ([Const.«BodySubstance», Const.«Substance»]),
ap (Const.«subclass») ([Const.«AnimalSubstance», Const.«BodySubstance»]),
mkForall (fun («?ANIMAL» : Obj) => mkForall (fun («?SUBSTANCE» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?SUBSTANCE», Const.«AnimalSubstance»]), ap (Const.«instance») ([«?ANIMAL», Const.«Organism»]), ap (Const.«part») ([«?SUBSTANCE», «?ANIMAL»])]) (ap (Const.«instance») ([«?ANIMAL», Const.«Animal»])))),
ap (Const.«subclass») ([Const.«PlantSubstance», Const.«BodySubstance»]),
mkForall (fun («?PLANT» : Obj) => mkForall (fun («?SUBSTANCE» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?SUBSTANCE», Const.«PlantSubstance»]), ap (Const.«instance») ([«?PLANT», Const.«Organism»]), ap (Const.«part») ([«?SUBSTANCE», «?PLANT»])]) (ap (Const.«instance») ([«?PLANT», Const.«Plant»])))),
ap (Const.«subclass») ([Const.«Hormone», Const.«BodySubstance»]),
ap (Const.«subclass») ([Const.«Hormone», Const.«BiologicallyActiveSubstance»]),
mkForall (fun («?HORMONE» : Obj) => mkImp (ap (Const.«instance») ([«?HORMONE», Const.«Hormone»])) (mkExists (fun («?PROCESS» : Obj) => mkExists (fun («?GLAND» : Obj) => mkAnd [ap (Const.«instance») ([«?GLAND», Const.«Gland»]), ap (Const.«instrument») ([«?PROCESS», «?GLAND»]), ap (Const.«result») ([«?PROCESS», «?HORMONE»])])))),
ap (Const.«subclass») ([Const.«Blood», Const.«BodySubstance»]),
ap (Const.«instance») ([Const.«FoodForFn», Const.«UnaryFunction»]),
mkForall (fun («?A» : Obj) => mkForall (fun («?FOOD» : Obj) => mkImp (ap (Const.«instance») ([«?FOOD», ap (Const.«FoodForFn») ([«?A»])])) (mkExists (fun («?NUTRIENT» : Obj) => mkAnd [ap (Const.«instance») ([«?NUTRIENT», Const.«Nutrient»]), ap (Const.«part») ([«?NUTRIENT», «?FOOD»])])))),
ap (Const.«equal») ([Const.«Food», ap (Const.«FoodForFn») ([Const.«Human»])]),
ap (Const.«subclass») ([Const.«Food», Const.«SelfConnectedObject»]),
ap (Const.«subclass») ([Const.«Meat», Const.«AnimalSubstance»]),
mkForall (fun («?MEAT» : Obj) => mkImp (ap (Const.«instance») ([«?MEAT», Const.«Meat»])) (mkForall (fun («?PART» : Obj) => mkImp (ap (Const.«part») ([«?PART», «?MEAT»])) (mkExists (fun («?SUBPART» : Obj) => mkExists (fun («?TIME» : Obj) => mkExists (fun («?ANIMAL» : Obj) => mkAnd [ap (Const.«part») ([«?SUBPART», «?PART»]), ap (Const.«holdsDuring») ([«?TIME», mkAnd [ap (Const.«instance») ([«?ANIMAL», Const.«Animal»]), ap (Const.«part») ([«?SUBPART», «?ANIMAL»])]])]))))))),
ap (Const.«subclass») ([Const.«AnatomicalStructure», Const.«OrganicObject»]),
ap (Const.«partition») ([Const.«AnatomicalStructure», Const.«BodyPart», Const.«AbnormalAnatomicalStructure»]),
ap (Const.«partition») ([Const.«AnatomicalStructure», Const.«AnimalAnatomicalStructure», Const.«PlantAnatomicalStructure»]),
mkForall (fun («?ANAT» : Obj) => mkImp (ap (Const.«instance») ([«?ANAT», Const.«AnatomicalStructure»])) (mkExists (fun («?ORGANISM» : Obj) => mkExists (fun («?TIME» : Obj) => mkAnd [ap (Const.«instance») ([«?ORGANISM», Const.«Organism»]), ap (Const.«temporalPart») ([«?TIME», ap (Const.«WhenFn») ([«?ORGANISM»])]), ap (Const.«holdsDuring») ([«?TIME», ap (Const.«part») ([«?ANAT», «?ORGANISM»])])])))),
mkForall (fun («?PART» : Obj) => mkImp (ap (Const.«instance») ([«?PART», Const.«AnatomicalStructure»])) (mkExists (fun («?CELL» : Obj) => mkAnd [ap (Const.«instance») ([«?CELL», Const.«Cell»]), ap (Const.«part») ([«?CELL», «?PART»])]))),
ap (Const.«subclass») ([Const.«AbnormalAnatomicalStructure», Const.«AnatomicalStructure»]),
mkForall (fun («?STRUCTURE» : Obj) => mkImp (ap (Const.«instance») ([«?STRUCTURE», Const.«AbnormalAnatomicalStructure»])) (mkExists (fun («?PROC» : Obj) => mkAnd [ap (Const.«instance») ([«?PROC», Const.«PathologicProcess»]), ap (Const.«result») ([«?PROC», «?STRUCTURE»])]))),
ap (Const.«subclass») ([Const.«BodyPart», Const.«AnatomicalStructure»]),
mkForall (fun («?PART» : Obj) => mkImp (ap (Const.«instance») ([«?PART», Const.«BodyPart»])) (mkExists (fun («?ORGANISM» : Obj) => mkExists (fun («?TIME» : Obj) => mkAnd [ap (Const.«instance») ([«?ORGANISM», Const.«Organism»]), ap (Const.«temporalPart») ([«?TIME», ap (Const.«WhenFn») ([«?ORGANISM»])]), ap (Const.«holdsDuring») ([«?TIME», ap (Const.«component») ([«?PART», «?ORGANISM»])])])))),
mkForall (fun («?PART» : Obj) => mkImp (ap (Const.«instance») ([«?PART», Const.«BodyPart»])) (mkExists (fun («?PROC» : Obj) => mkAnd [ap (Const.«instance») ([«?PROC», Const.«PhysiologicProcess»]), ap (Const.«result») ([«?PROC», «?PART»])]))),
ap (Const.«instance») ([Const.«BodySideFn», Const.«BinaryFunction»]),
mkForall (fun («?A» : Obj) => mkForall (fun («?BPC» : Obj) => mkForall (fun («?P» : Obj) => mkForall (fun («?S» : Obj) => mkForall (fun («?SO» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?A», Const.«Animal»]), ap (Const.«instance») ([«?P», ap (Const.«BodySideFn») ([«?S», «?BPC»])]), ap (Const.«contraryAttribute») ([«?S», «?SO»]), ap (Const.«attribute») ([«?A», Const.«Healthy»])]) (mkExists (fun («?PO» : Obj) => mkAnd [ap (Const.«instance») ([«?PO», ap (Const.«BodySideFn») ([«?SO», «?BPC»])]), ap (Const.«orientation») ([«?P», «?PO», «?S»])]))))))),
mkForall (fun («?P» : Obj) => mkForall (fun («?S» : Obj) => mkForall (fun («?X» : Obj) => mkImp (ap (Const.«instance») ([«?X», ap (Const.«BodySideFn») ([«?S», «?P»])])) (ap (Const.«instance») ([«?X», «?P»]))))),
ap (Const.«subclass») ([Const.«AnimalAnatomicalStructure», Const.«AnatomicalStructure»]),
mkForall (fun («?ANIMAL» : Obj) => mkForall (fun («?STRUCTURE» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?STRUCTURE», Const.«AnimalAnatomicalStructure»]), ap (Const.«instance») ([«?ANIMAL», Const.«Organism»]), ap (Const.«part») ([«?STRUCTURE», «?ANIMAL»])]) (ap (Const.«instance») ([«?ANIMAL», Const.«Animal»])))),
ap (Const.«subclass») ([Const.«PlantAnatomicalStructure», Const.«AnatomicalStructure»]),
mkForall (fun («?PLANT» : Obj) => mkForall (fun («?STRUCTURE» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?STRUCTURE», Const.«PlantAnatomicalStructure»]), ap (Const.«instance») ([«?PLANT», Const.«Organism»]), ap (Const.«part») ([«?STRUCTURE», «?PLANT»])]) (ap (Const.«instance») ([«?PLANT», Const.«Plant»])))),
ap (Const.«subclass») ([Const.«ReproductiveBody», Const.«BodyPart»]),
ap (Const.«subclass») ([Const.«Egg», Const.«ReproductiveBody»]),
ap (Const.«subclass») ([Const.«Egg», Const.«AnimalAnatomicalStructure»]),
ap (Const.«subclass») ([Const.«Egg», Const.«Meat»]),
ap (Const.«subclass») ([Const.«Seed», Const.«ReproductiveBody»]),
ap (Const.«subclass») ([Const.«Seed», Const.«PlantAnatomicalStructure»]),
mkForall (fun («?SEED» : Obj) => mkImp (ap (Const.«instance») ([«?SEED», Const.«Seed»])) (mkExists (fun («?PLANT» : Obj) => mkExists (fun («?TIME» : Obj) => mkAnd [ap (Const.«instance») ([«?PLANT», Const.«FloweringPlant»]), ap (Const.«holdsDuring») ([«?TIME», ap (Const.«part») ([«?SEED», «?PLANT»])])])))),
ap (Const.«subclass») ([Const.«Pollen», Const.«ReproductiveBody»]),
ap (Const.«subclass») ([Const.«Pollen», Const.«PlantAnatomicalStructure»]),
ap (Const.«subclass») ([Const.«FruitOrVegetable», Const.«PlantAnatomicalStructure»]),
ap (Const.«subclass») ([Const.«FruitOrVegetable», Const.«ReproductiveBody»]),
ap (Const.«subclass») ([Const.«Spore», Const.«ReproductiveBody»]),
ap (Const.«subclass») ([Const.«Spore», Const.«PlantAnatomicalStructure»]),
mkForall (fun («?SPORE» : Obj) => mkImp (ap (Const.«instance») ([«?SPORE», Const.«Spore»])) (mkExists (fun («?PLANT» : Obj) => mkExists (fun («?TIME» : Obj) => mkAnd [ap (Const.«instance») ([«?PLANT», Const.«NonFloweringPlant»]), ap (Const.«holdsDuring») ([«?TIME», ap (Const.«part») ([«?SPORE», «?PLANT»])])])))),
ap (Const.«subclass») ([Const.«BodyCovering», Const.«BodyPart»]),
mkForall (fun («?COVER» : Obj) => mkImp (ap (Const.«instance») ([«?COVER», Const.«BodyCovering»])) (mkExists (fun («?BODY» : Obj) => mkAnd [ap (Const.«superficialPart») ([«?COVER», «?BODY»]), mkOr [ap (Const.«instance») ([«?BODY», Const.«Organism»]), ap (Const.«instance») ([«?BODY», Const.«BodyPart»])]]))),
ap (Const.«subclass») ([Const.«BodyJunction», Const.«BodyPart»]),
mkForall (fun («?JUNCT» : Obj) => mkImp (ap (Const.«instance») ([«?JUNCT», Const.«BodyJunction»])) (mkExists (fun («?OBJ1» : Obj) => mkExists (fun («?OBJ2» : Obj) => mkAnd [ap (Const.«instance») ([«?OBJ1», Const.«BodyPart»]), ap (Const.«instance») ([«?OBJ2», Const.«BodyPart»]), ap (Const.«connects») ([«?JUNCT», «?OBJ1», «?OBJ2»])])))),
ap (Const.«subclass») ([Const.«BodyCavity», Const.«BodyPart»]),
ap (Const.«subclass») ([Const.«BodyVessel», Const.«BodyCavity»]),
ap (Const.«subclass») ([Const.«Cell», Const.«BodyPart»]),
ap (Const.«subclass») ([Const.«Organ», Const.«BodyPart»]),
mkForall (fun («?ORGAN» : Obj) => mkImp (ap (Const.«instance») ([«?ORGAN», Const.«Organ»])) (mkExists (fun («?PURP» : Obj) => ap (Const.«hasPurpose») ([«?ORGAN», «?PURP»])))),
ap (Const.«subclass») ([Const.«Gland», Const.«Organ»]),
ap (Const.«subclass») ([Const.«Tissue», Const.«BodySubstance»]),
ap (Const.«disjointDecomposition») ([Const.«Tissue», Const.«ConnectiveTissue», Const.«MuscleTissue», Const.«NervousTissue», Const.«EpithelialTissue»]),
mkForall (fun («?STUFF» : Obj) => mkImp (ap (Const.«instance») ([«?STUFF», Const.«Tissue»])) (mkExists (fun («?PART» : Obj) => mkAnd [ap (Const.«instance») ([«?PART», Const.«Cell»]), ap (Const.«part») ([«?PART», «?STUFF»])]))),
mkForall (fun («?STUFF» : Obj) => mkImp (ap (Const.«instance») ([«?STUFF», Const.«Tissue»])) (mkExists (fun («?ORGANISM» : Obj) => mkAnd [ap (Const.«instance») ([«?ORGANISM», Const.«Organism»]), ap (Const.«part») ([«?STUFF», «?ORGANISM»])]))),
ap (Const.«subclass») ([Const.«ConnectiveTissue», Const.«Tissue»]),
ap (Const.«externalImage») ([Const.«ConnectiveTissue», strLit "https://en.wikipedia.org/wiki/Connective_tissue#/media/File:Hist.Technik_(2).jpg"]),
mkForall (fun («?H» : Obj) => mkForall (fun («?T1» : Obj) => mkForall (fun («?T1C» : Obj) => mkForall (fun («?T2» : Obj) => mkForall (fun («?T2C» : Obj) => mkImp (mkAnd [ap (Const.«subclass») ([«?T1C», Const.«Tissue»]), ap (Const.«subclass») ([«?T2C», Const.«Tissue»]), ap (Const.«instance») ([«?T1», «?T1C»]), ap (Const.«instance») ([«?T2», «?T2C»]), ap (Const.«instance») ([«?H», Const.«Human»]), ap (Const.«part») ([«?T1», «?H»]), ap (Const.«part») ([«?T2», «?H»]), mkNot (ap (Const.«equal») ([«?T1C», «?T2C»])), mkNot (ap (Const.«subclass») ([«?T1C», «?T2C»])), mkNot (ap (Const.«subclass») ([«?T2C», «?T1C»])), ap (Const.«orientation») ([«?T1», «?T2», Const.«Adjacent»])]) (ap (Const.«modalAttribute») ([mkExists (fun («?CT» : Obj) => mkAnd [ap (Const.«instance») ([«?CT», Const.«ConnectiveTissue»]), ap (Const.«between») ([«?T1», «?CT», «?T2»])]), Const.«Likely»]))))))),
ap (Const.«subclass») ([Const.«BoneTissue», Const.«ConnectiveTissue»]),
ap (Const.«subclass») ([Const.«BoneTissue», Const.«AnimalSubstance»]),
mkForall (fun («?BONE» : Obj) => mkImp (ap (Const.«instance») ([«?BONE», Const.«BoneTissue»])) (mkExists (fun («?VERT» : Obj) => mkAnd [ap (Const.«instance») ([«?VERT», Const.«Vertebrate»]), ap (Const.«part») ([«?BONE», «?VERT»])]))),
ap (Const.«subclass») ([Const.«Bone», Const.«BodyPart»]),
mkForall (fun («?B» : Obj) => mkImp (ap (Const.«instance») ([«?B», Const.«Bone»])) (ap (Const.«material») ([Const.«BoneTissue», «?B»]))),
ap (Const.«subclass») ([Const.«EpithelialTissue», Const.«Tissue»]),
mkForall (fun («?G» : Obj) => mkImp (ap (Const.«instance») ([«?G», Const.«Gland»])) (ap (Const.«material») ([Const.«EpithelialTissue», «?G»]))),
ap (Const.«subclass») ([Const.«MuscleTissue», Const.«Tissue»]),
ap (Const.«subclass») ([Const.«MuscleTissue», Const.«AnimalSubstance»]),
ap (Const.«subclass») ([Const.«Muscle», Const.«BodyPart»]),
mkForall (fun («?M» : Obj) => mkImp (ap (Const.«instance») ([«?M», Const.«Muscle»])) (ap (Const.«material») ([Const.«MuscleTissue», Const.«Muscle»]))),
ap (Const.«subclass») ([Const.«FatTissue», Const.«ConnectiveTissue»]),
ap (Const.«subclass») ([Const.«NervousTissue», Const.«Tissue»]),
mkForall (fun («?NC» : Obj) => mkImp (ap (Const.«instance») ([«?NC», Const.«NerveCell»])) (ap (Const.«material») ([Const.«NervousTissue», «?NC»]))),
ap (Const.«subclass») ([Const.«Noun», Const.«Word»]),
ap (Const.«partition») ([Const.«Word», Const.«Noun», Const.«Verb», Const.«Adjective», Const.«Adverb», Const.«ParticleWord»]),
ap (Const.«subclass») ([Const.«Verb», Const.«Word»]),
ap (Const.«subclass») ([Const.«Adjective», Const.«Word»]),
ap (Const.«subclass») ([Const.«Adverb», Const.«Word»]),
ap (Const.«subclass») ([Const.«ParticleWord», Const.«Word»]),
ap (Const.«subclass») ([Const.«Morpheme», Const.«LinguisticExpression»]),
mkForall (fun («?MORPH» : Obj) => mkImp (ap (Const.«instance») ([«?MORPH», Const.«Morpheme»])) (mkNot (mkExists (fun («?OTHERMORPH» : Obj) => mkAnd [ap (Const.«instance») ([«?OTHERMORPH», Const.«Morpheme»]), ap (Const.«part») ([«?OTHERMORPH», «?MORPH»]), mkNot (ap (Const.«equal») ([«?OTHERMORPH», «?MORPH»]))])))),
mkForall (fun («?MORPH» : Obj) => mkImp (ap (Const.«instance») ([«?MORPH», Const.«Morpheme»])) (mkExists (fun («?WORD» : Obj) => mkAnd [ap (Const.«instance») ([«?WORD», Const.«Word»]), ap (Const.«part») ([«?MORPH», «?WORD»])]))),
mkForall (fun («?WORD» : Obj) => mkImp (ap (Const.«instance») ([«?WORD», Const.«Word»])) (mkExists (fun («?PART» : Obj) => mkAnd [ap (Const.«part») ([«?PART», «?WORD»]), ap (Const.«instance») ([«?PART», Const.«Morpheme»])]))),
ap (Const.«subclass») ([Const.«Phrase», Const.«LinguisticExpression»]),
ap (Const.«disjointDecomposition») ([Const.«Phrase», Const.«VerbPhrase», Const.«NounPhrase», Const.«PrepositionalPhrase»]),
mkForall (fun («?PHRASE» : Obj) => mkImp (ap (Const.«instance») ([«?PHRASE», Const.«Phrase»])) (mkExists (fun («?PART1» : Obj) => mkExists (fun («?PART2» : Obj) => mkAnd [ap (Const.«part») ([«?PART1», «?PHRASE»]), ap (Const.«part») ([«?PART2», «?PHRASE»]), ap (Const.«instance») ([«?PART1», Const.«Word»]), ap (Const.«instance») ([«?PART2», Const.«Word»]), mkNot (ap (Const.«equal») ([«?PART1», «?PART2»]))])))),
ap (Const.«subclass») ([Const.«VerbPhrase», Const.«Phrase»]),
mkForall (fun («?PHRASE» : Obj) => mkImp (ap (Const.«instance») ([«?PHRASE», Const.«VerbPhrase»])) (mkExists (fun («?VERB» : Obj) => mkAnd [ap (Const.«instance») ([«?VERB», Const.«Verb»]), ap (Const.«part») ([«?VERB», «?PHRASE»])]))),
ap (Const.«subclass») ([Const.«NounPhrase», Const.«Phrase»]),
ap (Const.«disjoint») ([Const.«NounPhrase», Const.«VerbPhrase»]),
mkForall (fun («?SENTENCE» : Obj) => mkImp (ap (Const.«instance») ([«?SENTENCE», Const.«Sentence»])) (mkExists (fun («?PHRASE1» : Obj) => mkExists (fun («?PHRASE2» : Obj) => mkAnd [ap (Const.«instance») ([«?PHRASE1», Const.«NounPhrase»]), ap (Const.«instance») ([«?PHRASE2», Const.«VerbPhrase»]), ap (Const.«part») ([«?PHRASE1», «?SENTENCE»]), ap (Const.«part») ([«?PHRASE2», «?SENTENCE»])])))),
mkForall (fun («?PHRASE» : Obj) => mkImp (ap (Const.«instance») ([«?PHRASE», Const.«NounPhrase»])) (mkExists (fun («?NOUN» : Obj) => mkAnd [ap (Const.«instance») ([«?NOUN», Const.«Noun»]), ap (Const.«part») ([«?NOUN», «?PHRASE»])]))),
ap (Const.«subclass») ([Const.«PrepositionalPhrase», Const.«Phrase»]),
mkForall (fun («?PHRASE» : Obj) => mkImp (ap (Const.«instance») ([«?PHRASE», Const.«PrepositionalPhrase»])) (mkExists (fun («?PREP» : Obj) => mkAnd [ap (Const.«instance») ([«?PREP», Const.«ParticleWord»]), ap (Const.«part») ([«?PREP», «?PHRASE»])]))),
ap (Const.«subclass») ([Const.«Text», Const.«LinguisticExpression»]),
ap (Const.«subclass») ([Const.«Text», Const.«ContentBearingObject»]),
ap (Const.«subclass») ([Const.«Text», Const.«Artifact»]),
mkForall (fun («?TEXT» : Obj) => mkImp (ap (Const.«instance») ([«?TEXT», Const.«Text»])) (mkExists (fun («?PART» : Obj) => mkAnd [ap (Const.«part») ([«?PART», «?TEXT»]), ap (Const.«instance») ([«?PART», Const.«LinguisticExpression»])]))),
mkForall (fun («?TEXT» : Obj) => mkImp (ap (Const.«instance») ([«?TEXT», Const.«Text»])) (mkExists (fun («?WRITE» : Obj) => mkAnd [ap (Const.«instance») ([«?WRITE», Const.«Writing»]), ap (Const.«result») ([«?WRITE», «?TEXT»])]))),
ap (Const.«subclass») ([Const.«FactualText», Const.«Text»]),
ap (Const.«disjoint») ([Const.«FactualText», Const.«FictionalText»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?CLASS» : Obj) => mkForall (fun («?CONTENT» : Obj) => mkForall (fun («?TEXT» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?TEXT», «?CLASS»]), ap (Const.«subclass») ([«?CLASS», Const.«FactualText»]), ap (Const.«authors») ([«?AGENT», «?CLASS»]), ap (Const.«subsumesContentInstance») ([«?TEXT», «?CONTENT»]), ap (Const.«instance») ([«?CONTENT», Const.«Formula»])]) (ap (Const.«believes») ([«?AGENT», «?CONTENT»])))))),
ap (Const.«subclass») ([Const.«FictionalText», Const.«Text»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?CLASS» : Obj) => mkForall (fun («?TEXT» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?TEXT», «?CLASS»]), ap (Const.«subclass») ([«?CLASS», Const.«FictionalText»]), ap (Const.«authors») ([«?AGENT», «?CLASS»])]) (mkExists (fun («?CONTENT» : Obj) => mkAnd [ap (Const.«subsumesContentInstance») ([«?TEXT», «?CONTENT»]), ap (Const.«instance») ([«?CONTENT», Const.«Formula»]), mkNot (ap (Const.«believes») ([«?AGENT», «?CONTENT»]))]))))),
ap (Const.«subclass») ([Const.«Sentence», Const.«LinguisticExpression»]),
mkForall (fun («?SENT» : Obj) => mkImp (ap (Const.«instance») ([«?SENT», Const.«Sentence»])) (mkExists (fun («?PROP» : Obj) => mkAnd [ap (Const.«instance») ([«?PROP», Const.«Proposition»]), ap (Const.«containsInformation») ([«?SENT», «?PROP»])]))),
ap (Const.«instance») ([Const.«authors», Const.«BinaryPredicate»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?TEXTCLASS» : Obj) => mkImp (ap (Const.«authors») ([«?AGENT», «?TEXTCLASS»])) (mkExists (fun («?PROCESS» : Obj) => mkExists (fun («?INSTANCE» : Obj) => mkAnd [ap (Const.«agent») ([«?PROCESS», «?AGENT»]), ap (Const.«instance») ([«?INSTANCE», «?TEXTCLASS»]), ap (Const.«result») ([«?PROCESS», «?INSTANCE»])]))))),
ap (Const.«instance») ([Const.«editor», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«publishes», Const.«BinaryPredicate»]),
mkForall (fun («?INST» : Obj) => mkForall (fun («?ORG» : Obj) => mkForall (fun («?TEXTCLASS» : Obj) => mkImp (mkAnd [ap (Const.«publishes») ([«?ORG», «?TEXTCLASS»]), ap (Const.«instance») ([«?INST», «?TEXTCLASS»])]) (mkExists (fun («?PUB» : Obj) => mkAnd [ap (Const.«instance») ([«?PUB», Const.«Publication»]), ap (Const.«agent») ([«?PUB», «?ORG»]), ap (Const.«patient») ([«?PUB», «?INST»])]))))),
ap (Const.«instance») ([Const.«EditionFn», Const.«BinaryFunction»]),
ap (Const.«instance») ([Const.«EditionFn», Const.«PartialValuedRelation»]),
mkForall (fun («?CBO1» : Obj) => mkForall (fun («?CBO2» : Obj) => mkForall (fun («?DATE1» : Obj) => mkForall (fun («?DATE2» : Obj) => mkForall (fun («?EDITION1» : Obj) => mkForall (fun («?EDITION2» : Obj) => mkForall (fun («?INT1» : Obj) => mkForall (fun («?INT2» : Obj) => mkForall (fun («?PUB1» : Obj) => mkForall (fun («?PUB2» : Obj) => mkForall (fun («?TEXT» : Obj) => mkImp (mkAnd [ap (Const.«equal») ([ap (Const.«EditionFn») ([«?TEXT», «?INT1»]), «?EDITION1»]), ap (Const.«equal») ([ap (Const.«EditionFn») ([«?TEXT», «?INT2»]), «?EDITION2»]), ap (Const.«greaterThan») ([«?INT2», «?INT1»]), ap (Const.«instance») ([«?PUB1», Const.«Publication»]), ap (Const.«instance») ([«?PUB2», Const.«Publication»]), ap (Const.«instance») ([«?CBO1», «?EDITION1»]), ap (Const.«instance») ([«?CBO2», «?EDITION2»]), ap (Const.«patient») ([«?PUB1», «?CBO1»]), ap (Const.«patient») ([«?PUB2», «?CBO2»]), ap (Const.«date») ([«?PUB1», «?DATE1»]), ap (Const.«date») ([«?PUB2», «?DATE2»])]) (ap (Const.«before») ([ap (Const.«EndFn») ([«?DATE1»]), ap (Const.«EndFn») ([«?DATE2»])]))))))))))))),
mkForall (fun («?NUMBER» : Obj) => mkForall (fun («?TEXT1» : Obj) => mkForall (fun («?TEXT2» : Obj) => mkImp (ap (Const.«equal») ([ap (Const.«EditionFn») ([«?TEXT1», «?NUMBER»]), «?TEXT2»])) (ap (Const.«subsumesContentClass») ([«?TEXT1», «?TEXT2»]))))),
ap (Const.«subclass») ([Const.«Summary», Const.«Text»]),
mkForall (fun («?TEXT» : Obj) => mkImp (ap (Const.«instance») ([«?TEXT», Const.«Summary»])) (mkExists (fun («?TEXT2» : Obj) => mkAnd [ap (Const.«instance») ([«?TEXT2», Const.«Text»]), ap (Const.«subsumesContentInstance») ([«?TEXT2», «?TEXT»])]))),
ap (Const.«subclass») ([Const.«Certificate», Const.«Text»]),
mkForall (fun («?DOC» : Obj) => mkImp (ap (Const.«instance») ([«?DOC», Const.«Certificate»])) (mkExists (fun («?PROP» : Obj) => mkExists (fun («?NORM» : Obj) => mkOr [ap (Const.«confersNorm») ([«?DOC», «?PROP», «?NORM»]), ap (Const.«deprivesNorm») ([«?DOC», «?PROP», «?NORM»])])))),
ap (Const.«subclass») ([Const.«FinancialInstrument», Const.«Certificate»]),
ap (Const.«subclass») ([Const.«Currency», Const.«FinancialInstrument»]),
mkForall (fun («?CURRENCY» : Obj) => mkImp (ap (Const.«instance») ([«?CURRENCY», Const.«Currency»])) (mkExists (fun («?MEASURE» : Obj) => ap (Const.«monetaryValue») ([«?CURRENCY», «?MEASURE»])))),
ap (Const.«subclass») ([Const.«Patent», Const.«Certificate»]),
ap (Const.«subclass») ([Const.«Molecule», Const.«CompoundSubstance»]),
mkForall (fun («?MOLE» : Obj) => mkImp (ap (Const.«instance») ([«?MOLE», Const.«Molecule»])) (mkExists (fun («?ATOM1» : Obj) => mkExists (fun («?ATOM2» : Obj) => mkAnd [ap (Const.«instance») ([«?ATOM1», Const.«Atom»]), ap (Const.«instance») ([«?ATOM2», Const.«Atom»]), ap (Const.«part») ([«?ATOM1», «?MOLE»]), ap (Const.«part») ([«?ATOM2», «?MOLE»]), mkNot (ap (Const.«equal») ([«?ATOM1», «?ATOM2»]))])))),
ap (Const.«subclass») ([Const.«Artifact», Const.«Object»]),
mkForall (fun («?ARTIFACT» : Obj) => mkImp (ap (Const.«instance») ([«?ARTIFACT», Const.«Artifact»])) (mkExists (fun («?MAKING» : Obj) => mkAnd [ap (Const.«instance») ([«?MAKING», Const.«Making»]), ap (Const.«result») ([«?MAKING», «?ARTIFACT»])]))),
ap (Const.«subclass») ([Const.«Product», Const.«Artifact»]),
mkForall (fun («?PRODUCT» : Obj) => mkImp (ap (Const.«instance») ([«?PRODUCT», Const.«Product»])) (mkExists (fun («?MANUFACTURE» : Obj) => mkAnd [ap (Const.«instance») ([«?MANUFACTURE», Const.«Manufacture»]), ap (Const.«result») ([«?MANUFACTURE», «?PRODUCT»])]))),
ap (Const.«instance») ([Const.«version», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«version», Const.«AsymmetricRelation»]),
ap (Const.«instance») ([Const.«version», Const.«TransitiveRelation»]),
mkForall (fun («?ARTIFACT1» : Obj) => mkForall (fun («?ARTIFACT2» : Obj) => mkImp (ap (Const.«version») ([«?ARTIFACT1», «?ARTIFACT2»])) (ap (Const.«subclass») ([«?ARTIFACT1», «?ARTIFACT2»])))),
ap (Const.«subclass») ([Const.«StationaryArtifact», Const.«Artifact»]),
mkForall (fun («?ARTIFACT» : Obj) => mkImp (ap (Const.«instance») ([«?ARTIFACT», Const.«StationaryArtifact»])) (mkExists (fun («?PLACE» : Obj) => mkAnd [ap (Const.«holdsDuring») ([ap (Const.«WhenFn») ([«?ARTIFACT»]), ap (Const.«located») ([«?ARTIFACT», «?PLACE»])]), mkNot (mkExists (fun («?P2» : Obj) => mkAnd [ap (Const.«holdsDuring») ([ap (Const.«WhenFn») ([«?ARTIFACT»]), ap (Const.«located») ([«?ARTIFACT», «?P2»])]), mkNot (ap (Const.«equal») ([«?PLACE», «?P2»]))]))]))),
ap (Const.«subclass») ([Const.«Building», Const.«StationaryArtifact»]),
mkForall (fun («?BUILDING» : Obj) => mkImp (ap (Const.«instance») ([«?BUILDING», Const.«Building»])) (mkExists (fun («?HUMAN» : Obj) => mkAnd [ap (Const.«instance») ([«?HUMAN», Const.«Human»]), mkOr [ap (Const.«inhabits») ([«?HUMAN», «?BUILDING»]), mkExists (fun («?ACT» : Obj) => mkAnd [ap (Const.«agent») ([«?ACT», «?HUMAN»]), ap (Const.«located») ([«?ACT», «?BUILDING»])])]]))),
ap (Const.«subclass») ([Const.«Room», Const.«StationaryArtifact»]),
ap (Const.«disjoint») ([Const.«Room», Const.«Building»]),
mkForall (fun («?ROOM» : Obj) => mkImp (ap (Const.«instance») ([«?ROOM», Const.«Room»])) (mkExists (fun («?BUILD» : Obj) => mkAnd [ap (Const.«instance») ([«?BUILD», Const.«Building»]), ap (Const.«properPart») ([«?ROOM», «?BUILD»])]))),
ap (Const.«subclass») ([Const.«House», Const.«ResidentialBuilding»]),
ap (Const.«subclass») ([Const.«House», Const.«SingleFamilyResidence»]),
ap (Const.«subclass») ([Const.«Residence», Const.«StationaryArtifact»]),
ap (Const.«disjointDecomposition») ([Const.«Residence», Const.«PermanentResidence», Const.«TemporaryResidence»]),
mkForall (fun («?RESIDENCE» : Obj) => mkImp (ap (Const.«instance») ([«?RESIDENCE», Const.«Residence»])) (mkOr [ap (Const.«instance») ([«?RESIDENCE», Const.«House»]), mkExists (fun («?BUILDING» : Obj) => mkAnd [ap (Const.«instance») ([«?BUILDING», Const.«ResidentialBuilding»]), ap (Const.«part») ([«?RESIDENCE», «?BUILDING»])])])),
ap (Const.«subclass») ([Const.«PermanentResidence», Const.«Residence»]),
mkForall (fun («?RESIDENCE» : Obj) => mkImp (ap (Const.«instance») ([«?RESIDENCE», Const.«PermanentResidence»])) (mkExists (fun («?PERSON» : Obj) => ap (Const.«home») ([«?PERSON», «?RESIDENCE»])))),
ap (Const.«subclass») ([Const.«TemporaryResidence», Const.«Residence»]),
ap (Const.«subclass») ([Const.«ResidentialBuilding», Const.«Building»]),
ap (Const.«subclass») ([Const.«ResidentialBuilding», Const.«Residence»]),
ap (Const.«subclass») ([Const.«SingleFamilyResidence», Const.«PermanentResidence»]),
mkForall (fun («?RESIDENCE» : Obj) => mkImp (ap (Const.«instance») ([«?RESIDENCE», Const.«SingleFamilyResidence»])) (ap (Const.«hasPurpose») ([«?RESIDENCE», mkForall (fun («?AGENT1» : Obj) => mkForall (fun («?AGENT2» : Obj) => mkImp (mkAnd [ap (Const.«home») ([«?AGENT1», «?RESIDENCE»]), ap (Const.«home») ([«?AGENT2», «?RESIDENCE»])]) (mkExists (fun («?UNIT» : Obj) => mkAnd [ap (Const.«instance») ([«?UNIT», Const.«SocialUnit»]), ap (Const.«member») ([«?AGENT1», «?UNIT»]), ap (Const.«member») ([«?AGENT2», «?UNIT»])]))))]))),
ap (Const.«subclass») ([Const.«ArtWork», Const.«Artifact»]),
mkForall (fun («?AW» : Obj) => mkImp (ap (Const.«instance») ([«?AW», Const.«ArtWork»])) (ap (Const.«hasPurpose») ([«?AW», mkExists (fun («?H» : Obj) => mkExists (fun («?P» : Obj) => mkAnd [ap (Const.«instance») ([«?H», Const.«Human»]), ap (Const.«instance») ([«?P», Const.«Perception»]), ap (Const.«experiencer») ([«?P», «?H»]), ap (Const.«patient») ([«?P», «?AW»])]))]))),
mkForall (fun («?AW» : Obj) => mkImp (ap (Const.«instance») ([«?AW», Const.«ArtWork»])) (ap (Const.«hasPurpose») ([«?AW», mkExists (fun («?H» : Obj) => mkAnd [ap (Const.«instance») ([«?H», Const.«Human»]), ap (Const.«desires») ([«?H», mkExists (fun («?P» : Obj) => mkAnd [ap (Const.«instance») ([«?P», Const.«Perception»]), ap (Const.«experiencer») ([«?P», «?H»]), ap (Const.«patient») ([«?P», «?AW»])])])])]))),
ap (Const.«subclass») ([Const.«RepresentationalArtWork», Const.«ArtWork»]),
ap (Const.«subclass») ([Const.«RepresentationalArtWork», Const.«Icon»]),
mkForall (fun («?RA» : Obj) => mkImp (ap (Const.«instance») ([«?RA», Const.«RepresentationalArtWork»])) (mkExists (fun («?P» : Obj) => mkAnd [ap (Const.«instance») ([«?P», Const.«Physical»]), ap (Const.«represents») ([«?RA», «?P»])]))),
ap (Const.«subclass») ([Const.«Fabric», Const.«Artifact»]),
ap (Const.«disjoint») ([Const.«Fabric», Const.«StationaryArtifact»]),
ap (Const.«subclass») ([Const.«WearableItem», Const.«Artifact»]),
mkForall (fun («?WI» : Obj) => mkImp (ap (Const.«instance») ([«?WI», Const.«WearableItem»])) (ap (Const.«hasPurpose») ([«?WI», mkExists (fun («?H» : Obj) => mkAnd [ap (Const.«instance») ([«?H», Const.«Human»]), ap (Const.«wears») ([«?H», «?WI»])])]))),
ap (Const.«instance») ([Const.«covers», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«covers», Const.«TransitiveRelation»]),
ap (Const.«instance») ([Const.«covers», Const.«SpatialRelation»]),
mkForall (fun («?A» : Obj) => mkForall (fun («?B» : Obj) => mkForall (fun («?S» : Obj) => mkImp (mkAnd [ap (Const.«covers») ([«?A», «?B»]), ap (Const.«superficialPart») ([«?S», «?B»])]) (ap (Const.«meetsSpatially») ([«?A», «?S»]))))),
mkForall (fun («?C» : Obj) => mkForall (fun («?I» : Obj) => mkForall (fun («?P» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?C», Const.«Covering»]), ap (Const.«patient») ([«?C», «?P»]), ap (Const.«instrument») ([«?C», «?I»])]) (ap (Const.«holdsDuring») ([ap (Const.«ImmediateFutureFn») ([ap (Const.«WhenFn») ([«?C»])]), ap (Const.«covers») ([«?I», «?P»])]))))),
ap (Const.«subclass») ([Const.«Clothing», Const.«WearableItem»]),
ap (Const.«disjoint») ([Const.«Clothing», Const.«StationaryArtifact»]),
mkForall (fun («?CLOTHING» : Obj) => mkImp (ap (Const.«instance») ([«?CLOTHING», Const.«Clothing»])) (ap (Const.«modalAttribute») ([mkExists (fun («?FABRIC» : Obj) => mkAnd [ap (Const.«instance») ([«?FABRIC», Const.«Fabric»]), ap (Const.«part») ([«?FABRIC», «?CLOTHING»])]), Const.«Likely»]))),
mkForall (fun («?CLOTHING» : Obj) => mkImp (ap (Const.«instance») ([«?CLOTHING», Const.«Clothing»])) (ap (Const.«hasPurpose») ([«?CLOTHING», mkExists (fun («?H» : Obj) => mkExists (fun («?P» : Obj) => mkAnd [ap (Const.«instance») ([«?H», Const.«Animal»]), ap (Const.«part») ([«?P», «?H»]), ap (Const.«covers») ([«?CLOTHING», «?P»])]))]))),
ap (Const.«instance») ([Const.«wears», Const.«BinaryPredicate»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?WI» : Obj) => mkImp (ap (Const.«wears») ([«?AGENT», «?WI»])) (ap (Const.«located») ([«?WI», «?AGENT»])))),
mkForall (fun («?A» : Obj) => mkForall (fun («?C» : Obj) => mkForall (fun («?P» : Obj) => mkImp (mkAnd [ap (Const.«wears») ([«?A», «?C»]), ap (Const.«part») ([«?P», «?C»])]) (ap (Const.«wears») ([«?A», «?P»]))))),
ap (Const.«subclass») ([Const.«Device», Const.«Artifact»]),
mkForall (fun («?DEVICE» : Obj) => mkImp (ap (Const.«instance») ([«?DEVICE», Const.«Device»])) (mkExists (fun («?PROC» : Obj) => ap (Const.«capability») ([«?PROC», Const.«instrument», «?DEVICE»])))),
mkForall (fun («?DEVICE» : Obj) => mkImp (ap (Const.«instance») ([«?DEVICE», Const.«Device»])) (mkExists (fun («?PROC» : Obj) => ap (Const.«hasPurpose») ([«?DEVICE», mkExists (fun («?INST» : Obj) => mkAnd [ap (Const.«instance») ([«?INST», «?PROC»]), ap (Const.«instrument») ([«?INST», «?DEVICE»])])])))),
ap (Const.«subclass») ([Const.«MusicalInstrument», Const.«Device»]),
mkForall (fun («?INSTRUMENT» : Obj) => mkImp (ap (Const.«instance») ([«?INSTRUMENT», Const.«MusicalInstrument»])) (ap (Const.«capability») ([Const.«MakingMusic», Const.«instrument», «?INSTRUMENT»]))),
ap (Const.«subclass») ([Const.«TransportationDevice», Const.«Device»]),
mkForall (fun («?DEVICE» : Obj) => mkImp (ap (Const.«instance») ([«?DEVICE», Const.«TransportationDevice»])) (ap (Const.«capability») ([Const.«Transportation», Const.«instrument», «?DEVICE»]))),
ap (Const.«subclass») ([Const.«Vehicle», Const.«TransportationDevice»]),
mkForall (fun («?FROM» : Obj) => mkForall (fun («?MOVE» : Obj) => mkForall (fun («?TRANSPORT» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?TRANSPORT», Const.«Vehicle»]), ap (Const.«instance») ([«?MOVE», Const.«Translocation»]), ap (Const.«instrument») ([«?MOVE», «?TRANSPORT»]), ap (Const.«origin») ([«?MOVE», «?FROM»])]) (ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?MOVE»])]), ap (Const.«located») ([«?TRANSPORT», «?FROM»])]))))),
mkForall (fun («?MOVE» : Obj) => mkForall (fun («?TO» : Obj) => mkForall (fun («?TRANSPORT» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?TRANSPORT», Const.«Vehicle»]), ap (Const.«instance») ([«?MOVE», Const.«Translocation»]), ap (Const.«instrument») ([«?MOVE», «?TRANSPORT»]), ap (Const.«destination») ([«?MOVE», «?TO»])]) (ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?MOVE»])]), ap (Const.«located») ([«?TRANSPORT», «?TO»])]))))),
ap (Const.«subclass») ([Const.«MeasuringDevice», Const.«Device»]),
mkForall (fun («?DEVICE» : Obj) => mkImp (ap (Const.«instance») ([«?DEVICE», Const.«MeasuringDevice»])) (ap (Const.«hasPurpose») ([«?DEVICE», mkExists (fun («?MEASURE» : Obj) => mkAnd [ap (Const.«instance») ([«?MEASURE», Const.«Measuring»]), ap (Const.«instrument») ([«?MEASURE», «?DEVICE»])])]))),
ap (Const.«subclass») ([Const.«AttachingDevice», Const.«Device»]),
mkForall (fun («?DEVICE» : Obj) => mkImp (ap (Const.«instance») ([«?DEVICE», Const.«AttachingDevice»])) (mkExists (fun («?ATTACH» : Obj) => mkAnd [ap (Const.«instance») ([«?ATTACH», Const.«Attaching»]), ap (Const.«instrument») ([«?ATTACH», «?DEVICE»])]))),
ap (Const.«subclass») ([Const.«Weapon», Const.«Device»]),
mkForall (fun («?WEAPON» : Obj) => mkImp (ap (Const.«instance») ([«?WEAPON», Const.«Weapon»])) (ap (Const.«capability») ([Const.«Damaging», Const.«instrument», «?WEAPON»]))),
mkForall (fun («?WEAPON» : Obj) => mkImp (ap (Const.«instance») ([«?WEAPON», Const.«Weapon»])) (ap (Const.«hasPurpose») ([«?WEAPON», mkExists (fun («?D» : Obj) => mkExists (fun («?PATIENT» : Obj) => mkAnd [ap (Const.«instance») ([«?D», Const.«Damaging»]), ap (Const.«instrument») ([«?D», «?WEAPON»]), ap (Const.«patient») ([«?D», «?PATIENT»])]))]))),
ap (Const.«subclass») ([Const.«Machine», Const.«Device»]),
mkForall (fun («?MACHINE» : Obj) => mkImp (ap (Const.«instance») ([«?MACHINE», Const.«Machine»])) (mkForall (fun («?PROC» : Obj) => mkImp (ap (Const.«instrument») ([«?PROC», «?MACHINE»])) (mkExists (fun («?RESOURCE» : Obj) => mkExists (fun («?RESULT» : Obj) => mkAnd [ap (Const.«resource») ([«?PROC», «?RESOURCE»]), ap (Const.«result») ([«?PROC», «?RESULT»])])))))),
ap (Const.«subclass») ([Const.«EngineeringComponent», Const.«Device»]),
mkForall (fun («?COMP» : Obj) => mkImp (ap (Const.«instance») ([«?COMP», Const.«EngineeringComponent»])) (mkExists (fun («?DEVICE» : Obj) => mkAnd [ap (Const.«instance») ([«?DEVICE», Const.«Device»]), ap (Const.«component») ([«?COMP», «?DEVICE»])]))),
mkForall (fun («?MACHINE» : Obj) => mkImp (ap (Const.«instance») ([«?MACHINE», Const.«Machine»])) (mkExists (fun («?COMP1» : Obj) => mkExists (fun («?COMP2» : Obj) => mkAnd [ap (Const.«instance») ([«?COMP1», Const.«EngineeringComponent»]), ap (Const.«instance») ([«?COMP2», Const.«EngineeringComponent»]), mkNot (ap (Const.«equal») ([«?COMP1», «?COMP2»])), ap (Const.«part») ([«?COMP1», «?MACHINE»]), ap (Const.«part») ([«?COMP2», «?MACHINE»])])))),
ap (Const.«subrelation») ([Const.«engineeringSubcomponent», Const.«properPart»]),
ap (Const.«instance») ([Const.«engineeringSubcomponent», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«connectedEngineeringComponents», Const.«SymmetricRelation»]),
ap (Const.«instance») ([Const.«connectedEngineeringComponents», Const.«IrreflexiveRelation»]),
ap (Const.«instance») ([Const.«connectedEngineeringComponents», Const.«PartialValuedRelation»]),
ap (Const.«subrelation») ([Const.«connectedEngineeringComponents», Const.«connected»]),
mkForall (fun («?COMP1» : Obj) => mkForall (fun («?COMP2» : Obj) => mkImp (ap (Const.«connectedEngineeringComponents») ([«?COMP1», «?COMP2»])) (mkAnd [mkNot (ap (Const.«engineeringSubcomponent») ([«?COMP1», «?COMP2»])), mkNot (ap (Const.«engineeringSubcomponent») ([«?COMP2», «?COMP1»]))]))),
ap (Const.«subclass») ([Const.«EngineeringConnection», Const.«EngineeringComponent»]),
mkForall (fun («?CONNECTION» : Obj) => mkImp (ap (Const.«instance») ([«?CONNECTION», Const.«EngineeringConnection»])) (mkExists (fun («?COMP1» : Obj) => mkExists (fun («?COMP2» : Obj) => ap (Const.«connectsEngineeringComponents») ([«?CONNECTION», «?COMP1», «?COMP2»]))))),
mkForall (fun («?COMP1» : Obj) => mkForall (fun («?COMP2» : Obj) => mkImp (ap (Const.«connectedEngineeringComponents») ([«?COMP1», «?COMP2»])) (mkNot (mkOr [ap (Const.«instance») ([«?COMP1», Const.«EngineeringConnection»]), ap (Const.«instance») ([«?COMP2», Const.«EngineeringConnection»])])))),
mkForall (fun («?COMP1» : Obj) => mkForall (fun («?COMP2» : Obj) => mkImp (ap (Const.«connectedEngineeringComponents») ([«?COMP1», «?COMP2»])) (mkExists (fun («?CONNECTION» : Obj) => ap (Const.«connectsEngineeringComponents») ([«?CONNECTION», «?COMP1», «?COMP2»]))))),
mkForall (fun («?COMP1» : Obj) => mkForall (fun («?COMP2» : Obj) => mkForall (fun («?CONNECTION» : Obj) => mkImp (ap (Const.«connectsEngineeringComponents») ([«?CONNECTION», «?COMP1», «?COMP2»])) (ap (Const.«connectedEngineeringComponents») ([«?COMP1», «?COMP2»]))))),
ap (Const.«subrelation») ([Const.«connectsEngineeringComponents», Const.«connects»]),
ap (Const.«instance») ([Const.«connectsEngineeringComponents», Const.«TernaryPredicate»]),
ap (Const.«subclass») ([Const.«CommercialAgent», Const.«AutonomousAgent»]),
ap (Const.«subclass») ([Const.«Business», Const.«CommercialAgent»]),
ap (Const.«subclass») ([Const.«Business», Const.«Organization»]),
ap (Const.«subclass») ([Const.«Corporation», Const.«Business»]),
ap (Const.«subclass») ([Const.«Corporation», Const.«LegalAgent»]),
ap (Const.«subclass») ([Const.«Manufacturer», Const.«Corporation»]),
mkForall (fun («?ORG» : Obj) => mkImp (ap (Const.«instance») ([«?ORG», Const.«Manufacturer»])) (ap (Const.«hasPurpose») ([«?ORG», mkExists (fun («?MANUFACTURE» : Obj) => mkAnd [ap (Const.«instance») ([«?MANUFACTURE», Const.«Manufacture»]), ap (Const.«instance») ([«?MANUFACTURE», Const.«CommercialService»]), ap (Const.«agent») ([«?MANUFACTURE», «?ORG»])])]))),
ap (Const.«subclass») ([Const.«MercantileOrganization», Const.«Corporation»]),
mkForall (fun («?ORG» : Obj) => mkImp (ap (Const.«instance») ([«?ORG», Const.«MercantileOrganization»])) (ap (Const.«hasPurpose») ([«?ORG», mkExists (fun («?SELL» : Obj) => mkAnd [ap (Const.«instance») ([«?SELL», Const.«Selling»]), ap (Const.«instance») ([«?SELL», Const.«CommercialService»]), ap (Const.«agent») ([«?SELL», «?ORG»])])]))),
ap (Const.«subclass») ([Const.«Group», Const.«Collection»]),
ap (Const.«subclass») ([Const.«Group», Const.«AutonomousAgent»]),
mkForall (fun («?GROUP» : Obj) => mkForall (fun («?MEMB» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?GROUP», Const.«Group»]), ap (Const.«member») ([«?MEMB», «?GROUP»])]) (ap (Const.«instance») ([«?MEMB», Const.«AutonomousAgent»])))),
ap (Const.«subclass») ([Const.«GroupOfPeople», Const.«Group»]),
mkForall (fun («?GROUP» : Obj) => mkForall (fun («?MEMBER» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?GROUP», Const.«GroupOfPeople»]), ap (Const.«member») ([«?MEMBER», «?GROUP»])]) (ap (Const.«instance») ([«?MEMBER», Const.«Human»])))),
ap (Const.«subclass») ([Const.«AgeGroup», Const.«GroupOfPeople»]),
mkForall (fun («?GROUP» : Obj) => mkImp (ap (Const.«instance») ([«?GROUP», Const.«AgeGroup»])) (mkForall (fun («?MEMB1» : Obj) => mkForall (fun («?MEMB2» : Obj) => mkForall (fun («?AGE1» : Obj) => mkForall (fun («?AGE2» : Obj) => mkImp (mkAnd [ap (Const.«member») ([«?MEMB1», «?GROUP»]), ap (Const.«member») ([«?MEMB2», «?GROUP»]), ap (Const.«age») ([«?MEMB1», «?AGE1»]), ap (Const.«age») ([«?MEMB2», «?AGE2»])]) (ap (Const.«equal») ([«?AGE1», «?AGE2»])))))))),
ap (Const.«subclass») ([Const.«FamilyGroup», Const.«GroupOfPeople»]),
mkForall (fun («?GROUP» : Obj) => mkImp (ap (Const.«instance») ([«?GROUP», Const.«FamilyGroup»])) (mkForall (fun («?MEMB1» : Obj) => mkForall (fun («?MEMB2» : Obj) => mkImp (mkAnd [ap (Const.«member») ([«?MEMB1», «?GROUP»]), ap (Const.«member») ([«?MEMB2», «?GROUP»])]) (ap (Const.«familyRelation») ([«?MEMB1», «?MEMB2»])))))),
ap (Const.«subclass») ([Const.«SocialUnit», Const.«GroupOfPeople»]),
mkForall (fun («?UNIT» : Obj) => mkImp (ap (Const.«instance») ([«?UNIT», Const.«SocialUnit»])) (mkExists (fun («?HOME» : Obj) => mkExists (fun («?MEMBER» : Obj) => mkImp (ap (Const.«member») ([«?MEMBER», «?UNIT»])) (ap (Const.«home») ([«?MEMBER», «?HOME»])))))),
ap (Const.«instance») ([Const.«ImmediateFamilyFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«ImmediateFamilyFn», Const.«TotalValuedRelation»]),
mkForall (fun («?FAMILY» : Obj) => mkForall (fun («?P» : Obj) => mkImp (ap (Const.«equal») ([ap (Const.«ImmediateFamilyFn») ([«?P»]), «?FAMILY»])) (mkForall (fun («?MEMBER» : Obj) => mkImp (ap (Const.«member») ([«?MEMBER», «?FAMILY»])) (mkExists (fun («?OTHER» : Obj) => mkOr [ap (Const.«parent») ([«?MEMBER», «?OTHER»]), ap (Const.«parent») ([«?OTHER», «?MEMBER»])])))))),
mkForall (fun («?FAMILY» : Obj) => mkForall (fun («?PERSON» : Obj) => mkImp (ap (Const.«equal») ([ap (Const.«ImmediateFamilyFn») ([«?PERSON»]), «?FAMILY»])) (mkExists (fun («?MEMBER» : Obj) => mkAnd [ap (Const.«member») ([«?MEMBER», «?FAMILY»]), mkOr [ap (Const.«parent») ([«?MEMBER», «?PERSON»]), ap (Const.«parent») ([«?PERSON», «?MEMBER»])]])))),
ap (Const.«instance») ([Const.«relative», Const.«BinaryPredicate»]),
ap (Const.«subrelation») ([Const.«familyRelation», Const.«relative»]),
ap (Const.«subrelation») ([Const.«spouse», Const.«relative»]),
mkForall (fun («?A1» : Obj) => mkForall (fun («?A2» : Obj) => mkForall (fun («?T1» : Obj) => mkImp (mkAnd [ap (Const.«holdsDuring») ([«?T1», ap (Const.«legalRelation») ([«?A1», «?A2»])]), ap (Const.«instance») ([«?A1», Const.«Organism»]), ap (Const.«instance») ([«?A2», Const.«Organism»])]) (ap (Const.«holdsDuring») ([«?T1», ap (Const.«relative») ([«?A1», «?A2»])]))))),
ap (Const.«instance») ([Const.«familyRelation», Const.«BinaryPredicate»]),
mkForall (fun («?ORGANISM1» : Obj) => mkForall (fun («?ORGANISM2» : Obj) => mkImp (ap (Const.«familyRelation») ([«?ORGANISM1», «?ORGANISM2»])) (mkExists (fun («?ORGANISM3» : Obj) => mkAnd [ap (Const.«ancestor») ([«?ORGANISM3», «?ORGANISM1»]), ap (Const.«ancestor») ([«?ORGANISM3», «?ORGANISM2»])])))),
ap (Const.«instance») ([Const.«ancestor», Const.«TransitiveRelation»]),
ap (Const.«instance») ([Const.«ancestor», Const.«IrreflexiveRelation»]),
ap (Const.«instance») ([Const.«ancestor», Const.«TotalValuedRelation»]),
ap (Const.«instance») ([Const.«ancestor», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«parent», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«parent», Const.«AsymmetricRelation»]),
ap (Const.«instance») ([Const.«parent», Const.«IntransitiveRelation»]),
ap (Const.«instance») ([Const.«parent», Const.«TotalValuedRelation»]),
mkForall (fun («?CHILD» : Obj) => mkForall (fun («?PARENT» : Obj) => mkImp (ap (Const.«parent») ([«?CHILD», «?PARENT»])) (ap (Const.«ancestor») ([«?CHILD», «?PARENT»])))),
mkForall (fun («?CHILD» : Obj) => mkForall (fun («?PARENT» : Obj) => mkImp (ap (Const.«parent») ([«?CHILD», «?PARENT»])) (ap (Const.«before») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?PARENT»])]), ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?CHILD»])])])))),
mkForall (fun («?CHILD» : Obj) => mkForall (fun («?CLASS» : Obj) => mkForall (fun («?PARENT» : Obj) => mkImp (mkAnd [ap (Const.«parent») ([«?CHILD», «?PARENT»]), ap (Const.«subclass») ([«?CLASS», Const.«Organism»]), ap (Const.«instance») ([«?PARENT», «?CLASS»])]) (ap (Const.«instance») ([«?CHILD», «?CLASS»]))))),
mkForall (fun («?CHILD» : Obj) => mkForall (fun («?PARENT» : Obj) => mkForall (fun («?REP» : Obj) => mkImp (mkAnd [ap (Const.«parent») ([«?CHILD», «?PARENT»]), ap (Const.«instance») ([«?REP», Const.«SexualReproduction»]), ap (Const.«agent») ([«?REP», «?PARENT»]), ap (Const.«result») ([«?REP», «?CHILD»])]) (mkOr [ap (Const.«mother») ([«?CHILD», «?PARENT»]), ap (Const.«father») ([«?CHILD», «?PARENT»])])))),
mkForall (fun («?ORGANISM» : Obj) => mkImp (ap (Const.«instance») ([«?ORGANISM», Const.«Organism»])) (mkExists (fun («?PARENT» : Obj) => ap (Const.«parent») ([«?ORGANISM», «?PARENT»])))),
ap (Const.«instance») ([Const.«mother», Const.«SingleValuedRelation»]),
ap (Const.«instance») ([Const.«mother», Const.«PartialValuedRelation»]),
ap (Const.«instance») ([Const.«mother», Const.«BinaryPredicate»]),
mkForall (fun («?A» : Obj) => mkForall (fun («?B» : Obj) => mkImp (ap (Const.«mother») ([«?A», «?B»])) (ap (Const.«parent») ([«?A», «?B»])))),
mkForall (fun («?CHILD» : Obj) => mkForall (fun («?MOTHER» : Obj) => mkImp (ap (Const.«mother») ([«?CHILD», «?MOTHER»])) (ap (Const.«attribute») ([«?MOTHER», Const.«Female»])))),
ap (Const.«instance») ([Const.«father», Const.«SingleValuedRelation»]),
ap (Const.«instance») ([Const.«father», Const.«PartialValuedRelation»]),
ap (Const.«instance») ([Const.«father», Const.«BinaryPredicate»]),
mkForall (fun («?A» : Obj) => mkForall (fun («?B» : Obj) => mkImp (ap (Const.«father») ([«?A», «?B»])) (ap (Const.«parent») ([«?A», «?B»])))),
mkForall (fun («?CHILD» : Obj) => mkForall (fun («?FATHER» : Obj) => mkImp (ap (Const.«father») ([«?CHILD», «?FATHER»])) (ap (Const.«attribute») ([«?FATHER», Const.«Male»])))),
ap (Const.«instance») ([Const.«daughter», Const.«BinaryPredicate»]),
ap (Const.«subrelation») ([Const.«daughter», Const.«parent»]),
mkForall (fun («?CHILD» : Obj) => mkForall (fun («?PARENT» : Obj) => mkImp (ap (Const.«daughter») ([«?CHILD», «?PARENT»])) (ap (Const.«attribute») ([«?CHILD», Const.«Female»])))),
ap (Const.«subrelation») ([Const.«son», Const.«parent»]),
ap (Const.«instance») ([Const.«son», Const.«BinaryPredicate»]),
mkForall (fun («?CHILD» : Obj) => mkForall (fun («?PARENT» : Obj) => mkImp (ap (Const.«son») ([«?CHILD», «?PARENT»])) (ap (Const.«attribute») ([«?CHILD», Const.«Male»])))),
ap (Const.«instance») ([Const.«sibling», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«sibling», Const.«PartialValuedRelation»]),
ap (Const.«subrelation») ([Const.«sibling», Const.«familyRelation»]),
ap (Const.«instance») ([Const.«sibling», Const.«SymmetricRelation»]),
ap (Const.«instance») ([Const.«sibling», Const.«IrreflexiveRelation»]),
mkForall (fun («?ORGANISM1» : Obj) => mkForall (fun («?ORGANISM2» : Obj) => mkForall (fun («?PARENT1» : Obj) => mkForall (fun («?PARENT2» : Obj) => mkImp (mkAnd [ap (Const.«parent») ([«?ORGANISM1», «?PARENT1»]), ap (Const.«parent») ([«?ORGANISM2», «?PARENT1»]), ap (Const.«parent») ([«?ORGANISM1», «?PARENT2»]), ap (Const.«parent») ([«?ORGANISM2», «?PARENT2»]), mkNot (ap (Const.«equal») ([«?ORGANISM1», «?ORGANISM2»])), mkNot (ap (Const.«equal») ([«?PARENT1», «?PARENT2»]))]) (ap (Const.«sibling») ([«?ORGANISM1», «?ORGANISM2»])))))),
mkForall (fun («?ORG1» : Obj) => mkForall (fun («?ORG2» : Obj) => mkForall (fun («?PARENT» : Obj) => mkImp (mkAnd [ap (Const.«sibling») ([«?ORG1», «?ORG2»]), ap (Const.«parent») ([«?ORG1», «?PARENT»])]) (ap (Const.«parent») ([«?ORG2», «?PARENT»]))))),
mkForall (fun («?CHILD» : Obj) => mkForall (fun («?PARENT» : Obj) => mkImp (mkAnd [ap (Const.«parent») ([«?CHILD», «?PARENT»]), ap (Const.«attribute») ([«?PARENT», Const.«Male»])]) (ap (Const.«father») ([«?CHILD», «?PARENT»])))),
mkForall (fun («?CHILD» : Obj) => mkForall (fun («?PARENT» : Obj) => mkImp (mkAnd [ap (Const.«parent») ([«?CHILD», «?PARENT»]), ap (Const.«attribute») ([«?PARENT», Const.«Female»])]) (ap (Const.«mother») ([«?CHILD», «?PARENT»])))),
ap (Const.«subrelation») ([Const.«brother», Const.«sibling»]),
ap (Const.«instance») ([Const.«brother», Const.«IrreflexiveRelation»]),
ap (Const.«instance») ([Const.«brother», Const.«TransitiveRelation»]),
ap (Const.«instance») ([Const.«brother», Const.«PartialValuedRelation»]),
ap (Const.«subrelation») ([Const.«sister», Const.«sibling»]),
ap (Const.«instance») ([Const.«sister», Const.«IrreflexiveRelation»]),
ap (Const.«instance») ([Const.«sister», Const.«TransitiveRelation»]),
ap (Const.«instance») ([Const.«sister», Const.«PartialValuedRelation»]),
ap (Const.«instance») ([Const.«legalRelation», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«legalRelation», Const.«SymmetricRelation»]),
mkForall (fun («?AGENT1» : Obj) => mkForall (fun («?AGENT2» : Obj) => mkImp (ap (Const.«legalRelation») ([«?AGENT1», «?AGENT2»])) (mkExists (fun («?DECLARE» : Obj) => mkExists (fun («?OBLIGATION» : Obj) => mkAnd [ap (Const.«instance») ([«?DECLARE», Const.«Declaring»]), ap (Const.«confersObligation») ([«?OBLIGATION», «?DECLARE», «?AGENT1»]), ap (Const.«confersObligation») ([«?OBLIGATION», «?DECLARE», «?AGENT2»])]))))),
ap (Const.«instance») ([Const.«acquaintance», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«mutualAcquaintance», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«mutualAcquaintance», Const.«SymmetricRelation»]),
ap (Const.«subrelation») ([Const.«mutualAcquaintance», Const.«acquaintance»]),
ap (Const.«subrelation») ([Const.«spouse», Const.«mutualAcquaintance»]),
ap (Const.«subrelation») ([Const.«spouse», Const.«legalRelation»]),
ap (Const.«instance») ([Const.«spouse», Const.«IrreflexiveRelation»]),
ap (Const.«instance») ([Const.«spouse», Const.«SymmetricRelation»]),
ap (Const.«instance») ([Const.«spouse», Const.«PartialValuedRelation»]),
ap (Const.«instance») ([Const.«husband», Const.«AsymmetricRelation»]),
ap (Const.«instance») ([Const.«husband», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«husband», Const.«IrreflexiveRelation»]),
ap (Const.«instance») ([Const.«husband», Const.«PartialValuedRelation»]),
ap (Const.«inverse») ([Const.«husband», Const.«wife»]),
ap (Const.«instance») ([Const.«wife», Const.«AsymmetricRelation»]),
ap (Const.«instance») ([Const.«wife», Const.«IrreflexiveRelation»]),
ap (Const.«instance») ([Const.«wife», Const.«BinaryPredicate»]),
ap (Const.«subclass») ([Const.«EthnicGroup», Const.«GroupOfPeople»]),
ap (Const.«subclass») ([Const.«BeliefGroup», Const.«GroupOfPeople»]),
mkForall (fun («?GROUP» : Obj) => mkImp (ap (Const.«instance») ([«?GROUP», Const.«BeliefGroup»])) (mkExists (fun («?BELIEF» : Obj) => mkForall (fun («?MEMB» : Obj) => mkImp (ap (Const.«member») ([«?MEMB», «?GROUP»])) (ap (Const.«believes») ([«?MEMB», «?BELIEF»])))))),
ap (Const.«subclass») ([Const.«Organization», Const.«Group»]),
ap (Const.«subclass») ([Const.«Organization», Const.«AutonomousAgent»]),
mkForall (fun («?ORG» : Obj) => mkImp (ap (Const.«instance») ([«?ORG», Const.«Organization»])) (mkExists (fun («?PURP» : Obj) => mkForall (fun («?MEMBER» : Obj) => mkImp (ap (Const.«member») ([«?MEMBER», «?ORG»])) (ap (Const.«hasPurpose») ([«?MEMBER», «?PURP»])))))),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?ORG» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?ORG», Const.«Organization»]), ap (Const.«member») ([«?AGENT», «?ORG»])]) (ap (Const.«instance») ([«?AGENT», Const.«AutonomousAgent»])))),
ap (Const.«instance») ([Const.«employs», Const.«BinaryPredicate»]),
ap (Const.«subclass») ([Const.«PoliticalOrganization», Const.«Organization»]),
mkForall (fun («?POL» : Obj) => mkImp (ap (Const.«instance») ([«?POL», Const.«PoliticalOrganization»])) (mkExists (fun («?PROC» : Obj) => mkAnd [ap (Const.«instance») ([«?PROC», Const.«PoliticalProcess»]), ap (Const.«agent») ([«?PROC», «?POL»])]))),
ap (Const.«subclass») ([Const.«MilitaryForce», Const.«PoliticalOrganization»]),
mkForall (fun («?ORG» : Obj) => mkImp (ap (Const.«instance») ([«?ORG», Const.«MilitaryForce»])) (ap (Const.«capability») ([Const.«ViolentContest», Const.«agent», «?ORG»]))),
ap (Const.«subclass») ([Const.«MilitaryOrganization», Const.«MilitaryForce»]),
ap (Const.«subclass») ([Const.«MilitaryOrganization», Const.«GovernmentOrganization»]),
ap (Const.«subclass») ([Const.«ParamilitaryOrganization», Const.«MilitaryForce»]),
ap (Const.«disjoint») ([Const.«ParamilitaryOrganization», Const.«GovernmentOrganization»]),
ap (Const.«subclass») ([Const.«GovernmentOrganization», Const.«Organization»]),
mkForall (fun («?ORG» : Obj) => mkImp (ap (Const.«instance») ([«?ORG», Const.«GovernmentOrganization»])) (mkExists (fun («?GOV» : Obj) => mkAnd [ap (Const.«instance») ([«?GOV», Const.«Government»]), ap (Const.«subOrganization») ([«?ORG», «?GOV»])]))),
mkForall (fun («?GOV» : Obj) => mkForall (fun («?ORG» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?GOV», Const.«Government»]), ap (Const.«subOrganization») ([«?ORG», «?GOV»])]) (ap (Const.«instance») ([«?ORG», Const.«GovernmentOrganization»])))),
mkForall (fun («?GOV» : Obj) => mkForall (fun («?ORG» : Obj) => mkImp (mkAnd [ap (Const.«subOrganization») ([«?ORG», «?GOV»]), ap (Const.«instance») ([«?GOV», Const.«GovernmentOrganization»])]) (ap (Const.«instance») ([«?ORG», Const.«GovernmentOrganization»])))),
ap (Const.«subclass») ([Const.«Government», Const.«GovernmentOrganization»]),
ap (Const.«subclass») ([Const.«Government», Const.«LegalAgent»]),
ap (Const.«instance») ([Const.«GovernmentFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«GovernmentFn», Const.«PartialValuedRelation»]),
ap (Const.«subclass») ([Const.«PoliceOrganization», Const.«GovernmentOrganization»]),
ap (Const.«subclass») ([Const.«JudicialOrganization», Const.«GovernmentOrganization»]),
ap (Const.«subclass») ([Const.«EducationalOrganization», Const.«Organization»]),
ap (Const.«subclass») ([Const.«ReligiousOrganization», Const.«Organization»]),
ap (Const.«subclass») ([Const.«ReligiousOrganization», Const.«BeliefGroup»]),
ap (Const.«subrelation») ([Const.«subOrganization», Const.«subCollection»]),
ap (Const.«instance») ([Const.«subOrganization», Const.«PartialOrderingRelation»]),
ap (Const.«instance») ([Const.«citizen», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«citizen», Const.«AsymmetricRelation»]),
ap (Const.«subclass») ([Const.«FieldOfStudy», Const.«Proposition»]),
ap (Const.«subclass») ([Const.«Procedure», Const.«Proposition»]),
ap (Const.«subclass») ([Const.«ComputerProgram», Const.«Procedure»]),
ap (Const.«subclass») ([Const.«ComputerProgramming», Const.«ContentDevelopment»]),
mkForall (fun («?CP» : Obj) => mkImp (ap (Const.«instance») ([«?CP», Const.«ComputerProgramming»])) (mkExists (fun («?C» : Obj) => mkAnd [ap (Const.«instance») ([«?C», Const.«ComputerProgram»]), ap (Const.«result») ([«?CP», «?C»])]))),
ap (Const.«subclass») ([Const.«Plan», Const.«Procedure»]),
mkForall (fun («?OBJ» : Obj) => mkForall (fun («?PLAN» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?PLAN», Const.«Plan»]), ap (Const.«instance») ([«?OBJ», Const.«ContentBearingObject»]), ap (Const.«containsInformation») ([«?OBJ», «?PLAN»])]) (mkExists (fun («?PLANNING» : Obj) => mkAnd [ap (Const.«instance») ([«?PLANNING», Const.«Planning»]), ap (Const.«result») ([«?PLANNING», «?OBJ»])])))),
ap (Const.«subclass») ([Const.«Argument», Const.«Proposition»]),
ap (Const.«partition») ([Const.«Argument», Const.«DeductiveArgument», Const.«InductiveArgument»]),
mkForall (fun («?REASON» : Obj) => mkImp (ap (Const.«instance») ([«?REASON», Const.«Reasoning»])) (mkExists (fun («?ARGUMENT» : Obj) => mkAnd [ap (Const.«instance») ([«?ARGUMENT», Const.«Argument»]), ap (Const.«realization») ([«?REASON», «?ARGUMENT»])]))),
mkForall (fun («?ARGUMENT» : Obj) => mkImp (ap (Const.«instance») ([«?ARGUMENT», Const.«Argument»])) (mkExists (fun («?PREMISES» : Obj) => mkExists (fun («?CONCLUSION» : Obj) => mkAnd [ap (Const.«equal») ([ap (Const.«PremisesFn») ([«?ARGUMENT»]), «?PREMISES»]), ap (Const.«conclusion») ([«?CONCLUSION», «?ARGUMENT»])])))),
ap (Const.«subclass») ([Const.«DeductiveArgument», Const.«Argument»]),
ap (Const.«partition») ([Const.«DeductiveArgument», Const.«ValidDeductiveArgument», Const.«InvalidDeductiveArgument»]),
ap (Const.«subclass») ([Const.«ValidDeductiveArgument», Const.«DeductiveArgument»]),
mkForall (fun («?ARGUMENT» : Obj) => mkForall (fun («?CONCLUSION» : Obj) => mkForall (fun («?PREMISES» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?ARGUMENT», Const.«ValidDeductiveArgument»]), ap (Const.«equal») ([«?PREMISES», ap (Const.«PremisesFn») ([«?ARGUMENT»])]), ap (Const.«conclusion») ([«?CONCLUSION», «?ARGUMENT»])]) (mkExists (fun («?FORMULA1» : Obj) => mkExists (fun («?FORMULA2» : Obj) => mkAnd [ap (Const.«containsInformation») ([«?FORMULA1», «?PREMISES»]), ap (Const.«containsInformation») ([«?FORMULA2», «?CONCLUSION»]), ap (Const.«entails») ([«?PREMISES», «?CONCLUSION»])])))))),
ap (Const.«subclass») ([Const.«InvalidDeductiveArgument», Const.«DeductiveArgument»]),
ap (Const.«subclass») ([Const.«Explanation», Const.«DeductiveArgument»]),
ap (Const.«subclass») ([Const.«InductiveArgument», Const.«Argument»]),
ap (Const.«instance») ([Const.«premise», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«premise», Const.«TotalValuedRelation»]),
ap (Const.«instance») ([Const.«PremisesFn», Const.«UnaryFunction»]),
ap (Const.«instance») ([Const.«PremisesFn», Const.«TotalValuedRelation»]),
mkForall (fun («?ARGUMENT» : Obj) => mkForall (fun («?PREMISES» : Obj) => mkForall (fun («?PROPOSITION» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?ARGUMENT», Const.«Argument»]), ap (Const.«equal») ([«?PREMISES», ap (Const.«PremisesFn») ([«?ARGUMENT»])])]) (mkIff (ap (Const.«subProposition») ([«?PROPOSITION», «?PREMISES»])) (ap (Const.«premise») ([«?ARGUMENT», «?PROPOSITION»])))))),
ap (Const.«instance») ([Const.«conclusion», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«conclusion», Const.«SingleValuedRelation»]),
ap (Const.«instance») ([Const.«conclusion», Const.«TotalValuedRelation»]),
ap (Const.«instance») ([Const.«consistent», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«consistent», Const.«SymmetricRelation»]),
ap (Const.«instance») ([Const.«orientation», Const.«SpatialRelation»]),
ap (Const.«instance») ([Const.«orientation», Const.«TernaryPredicate»]),
mkForallRow (fun («@ROW» : List Obj) => mkForall (fun («?ATTR1» : Obj) => mkForall (fun («?ATTR2» : Obj) => mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkImp (mkAnd [ap (Const.«orientation») ([«?OBJ1», «?OBJ2», «?ATTR1»]), ap (Const.«contraryAttribute») («@ROW»), ap (Const.«inList») ([«?ATTR1», ap (Const.«ListFn») («@ROW»)]), ap (Const.«inList») ([«?ATTR2», ap (Const.«ListFn») («@ROW»)]), mkNot (ap (Const.«equal») ([«?ATTR1», «?ATTR2»]))]) (mkNot (ap (Const.«orientation») ([«?OBJ1», «?OBJ2», «?ATTR2»])))))))),
mkForall (fun («?X» : Obj) => mkForall (fun («?Y» : Obj) => mkForall (fun («?Z» : Obj) => mkImp (mkAnd [ap (Const.«orientation») ([«?X», «?Y», Const.«Right»]), ap (Const.«orientation») ([«?Z», «?Y», Const.«Left»])]) (ap (Const.«orientation») ([«?X», «?Z», Const.«Right»]))))),
ap (Const.«instance») ([Const.«direction», Const.«PartialValuedRelation»]),
ap (Const.«subrelation») ([Const.«direction», Const.«involvedInEvent»]),
mkForall (fun («?ATTR1» : Obj) => mkForall (fun («?PROC» : Obj) => mkForall (fun («?TIME» : Obj) => mkImp (ap (Const.«holdsDuring») ([«?TIME», ap (Const.«direction») ([«?PROC», «?ATTR1»])])) (mkForall (fun («?ATTR2» : Obj) => mkImp (ap (Const.«holdsDuring») ([«?TIME», ap (Const.«direction») ([«?PROC», «?ATTR2»])])) (ap (Const.«equal») ([«?ATTR2», «?ATTR1»]))))))),
ap (Const.«instance») ([Const.«faces», Const.«BinaryPredicate»]),
mkForall (fun («?ATTR1» : Obj) => mkForall (fun («?PROC» : Obj) => mkForall (fun («?TIME» : Obj) => mkImp (ap (Const.«holdsDuring») ([«?TIME», ap (Const.«faces») ([«?PROC», «?ATTR1»])])) (mkForall (fun («?ATTR2» : Obj) => mkImp (ap (Const.«holdsDuring») ([«?TIME», ap (Const.«faces») ([«?PROC», «?ATTR2»])])) (ap (Const.«equal») ([«?ATTR2», «?ATTR1»]))))))),
ap (Const.«subclass») ([Const.«TruthValue», Const.«RelationalAttribute»]),
mkForall (fun («?ITEM» : Obj) => mkForall (fun («?VALUE» : Obj) => mkImp (mkAnd [ap (Const.«property») ([«?ITEM», «?VALUE»]), ap (Const.«instance») ([«?VALUE», Const.«TruthValue»])]) (mkOr [ap (Const.«instance») ([«?ITEM», Const.«Sentence»]), ap (Const.«instance») ([«?ITEM», Const.«Proposition»])]))),
ap (Const.«instance») ([Const.«True», Const.«TruthValue»]),
ap (Const.«instance») ([Const.«False», Const.«TruthValue»]),
ap (Const.«contraryAttribute») ([Const.«False», Const.«True»]),
ap (Const.«subrelation») ([Const.«truth», Const.«property»]),
ap (Const.«instance») ([Const.«truth», Const.«BinaryPredicate»]),
ap (Const.«subclass») ([Const.«PositionalAttribute», Const.«RelationalAttribute»]),
ap (Const.«subclass») ([Const.«DirectionalAttribute», Const.«PositionalAttribute»]),
mkForall (fun («?DIRECT» : Obj) => mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkForall (fun («?OBJ3» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?DIRECT», Const.«DirectionalAttribute»]), ap (Const.«orientation») ([«?OBJ1», «?OBJ2», «?DIRECT»]), ap (Const.«orientation») ([«?OBJ2», «?OBJ3», «?DIRECT»])]) (ap (Const.«between») ([«?OBJ1», «?OBJ2», «?OBJ3»])))))),
ap (Const.«instance») ([Const.«North», Const.«DirectionalAttribute»]),
ap (Const.«contraryAttribute») ([Const.«North», Const.«South», Const.«East», Const.«West»]),
ap (Const.«instance») ([Const.«South», Const.«DirectionalAttribute»]),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkIff (ap (Const.«orientation») ([«?OBJ1», «?OBJ2», Const.«North»])) (ap (Const.«orientation») ([«?OBJ2», «?OBJ1», Const.«South»])))),
ap (Const.«instance») ([Const.«East», Const.«DirectionalAttribute»]),
ap (Const.«instance») ([Const.«West», Const.«DirectionalAttribute»]),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkIff (ap (Const.«orientation») ([«?OBJ1», «?OBJ2», Const.«East»])) (ap (Const.«orientation») ([«?OBJ2», «?OBJ1», Const.«West»])))),
ap (Const.«instance») ([Const.«Vertical», Const.«PositionalAttribute»]),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkIff (ap (Const.«orientation») ([«?OBJ1», «?OBJ2», Const.«Vertical»])) (ap (Const.«orientation») ([«?OBJ2», «?OBJ1», Const.«Vertical»])))),
ap (Const.«instance») ([Const.«Horizontal», Const.«PositionalAttribute»]),
ap (Const.«contraryAttribute») ([Const.«Horizontal», Const.«Vertical»]),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkIff (ap (Const.«orientation») ([«?OBJ1», «?OBJ2», Const.«Horizontal»])) (ap (Const.«orientation») ([«?OBJ2», «?OBJ1», Const.«Horizontal»])))),
ap (Const.«subclass») ([Const.«SymmetricPositionalAttribute», Const.«PositionalAttribute»]),
mkForall (fun («?O1» : Obj) => mkForall (fun («?O2» : Obj) => mkForall (fun («?P» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?P», Const.«SymmetricPositionalAttribute»]), ap (Const.«orientation») ([«?O1», «?O2», «?P»])]) (ap (Const.«orientation») ([«?O2», «?O1», «?P»]))))),
ap (Const.«subclass») ([Const.«AntiSymmetricPositionalAttribute», Const.«PositionalAttribute»]),
mkForall (fun («?O1» : Obj) => mkForall (fun («?O2» : Obj) => mkForall (fun («?P» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?P», Const.«AntiSymmetricPositionalAttribute»]), ap (Const.«orientation») ([«?O1», «?O2», «?P»])]) (mkNot (ap (Const.«orientation») ([«?O2», «?O1», «?P»])))))),
ap (Const.«instance») ([Const.«Above», Const.«PositionalAttribute»]),
ap (Const.«instance») ([Const.«Above», Const.«AntiSymmetricPositionalAttribute»]),
ap (Const.«contraryAttribute») ([Const.«Above», Const.«Below»]),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkImp (ap (Const.«orientation») ([«?OBJ1», «?OBJ2», Const.«Above»])) (mkNot (ap (Const.«connected») ([«?OBJ1», «?OBJ2»]))))),
ap (Const.«instance») ([Const.«Below», Const.«PositionalAttribute»]),
ap (Const.«instance») ([Const.«Below», Const.«AntiSymmetricPositionalAttribute»]),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkIff (ap (Const.«orientation») ([«?OBJ1», «?OBJ2», Const.«Below»])) (mkOr [ap (Const.«orientation») ([«?OBJ2», «?OBJ1», Const.«On»]), ap (Const.«orientation») ([«?OBJ2», «?OBJ1», Const.«Above»])]))),
ap (Const.«instance») ([Const.«Adjacent», Const.«SymmetricPositionalAttribute»]),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkIff (ap (Const.«orientation») ([«?OBJ1», «?OBJ2», Const.«Adjacent»])) (mkOr [ap (Const.«orientation») ([«?OBJ1», «?OBJ2», Const.«Near»]), ap (Const.«connected») ([«?OBJ1», «?OBJ2»])]))),
ap (Const.«instance») ([Const.«Left», Const.«PositionalAttribute»]),
ap (Const.«instance») ([Const.«Left», Const.«AntiSymmetricPositionalAttribute»]),
ap (Const.«instance») ([Const.«Right», Const.«PositionalAttribute»]),
ap (Const.«instance») ([Const.«Right», Const.«AntiSymmetricPositionalAttribute»]),
ap (Const.«contraryAttribute») ([Const.«Right», Const.«Left»]),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkIff (ap (Const.«orientation») ([«?OBJ1», «?OBJ2», Const.«Right»])) (ap (Const.«orientation») ([«?OBJ2», «?OBJ1», Const.«Left»])))),
ap (Const.«instance») ([Const.«Near», Const.«SymmetricPositionalAttribute»]),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkImp (ap (Const.«orientation») ([«?OBJ1», «?OBJ2», Const.«Near»])) (mkNot (ap (Const.«connected») ([«?OBJ1», «?OBJ2»]))))),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkImp (ap (Const.«orientation») ([«?OBJ1», «?OBJ2», Const.«Near»])) (ap (Const.«orientation») ([«?OBJ2», «?OBJ1», Const.«Near»])))),
ap (Const.«instance») ([Const.«On», Const.«AntiSymmetricPositionalAttribute»]),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkImp (ap (Const.«orientation») ([«?OBJ1», «?OBJ2», Const.«On»])) (ap (Const.«connected») ([«?OBJ1», «?OBJ2»])))),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkImp (ap (Const.«orientation») ([«?OBJ1», «?OBJ2», Const.«On»])) (ap (Const.«located») ([«?OBJ1», «?OBJ2»])))),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkImp (ap (Const.«orientation») ([«?OBJ1», «?OBJ2», Const.«Inside»])) (ap (Const.«located») ([«?OBJ1», «?OBJ2»])))),
mkForall (fun («?OBJ1» : Obj) => mkForall (fun («?OBJ2» : Obj) => mkImp (ap (Const.«orientation») ([«?OBJ1», «?OBJ2», Const.«On»])) (mkNot (ap (Const.«orientation») ([«?OBJ2», «?OBJ1», Const.«On»]))))),
ap (Const.«subclass») ([Const.«TimeZone», Const.«RelationalAttribute»]),
ap (Const.«instance») ([Const.«CoordinatedUniversalTimeZone», Const.«TimeZone»]),
ap (Const.«instance») ([Const.«PacificTimeZone», Const.«TimeZone»]),
mkForall (fun («?D» : Obj) => mkForall (fun («?H1» : Obj) => mkForall (fun («?H2» : Obj) => mkForall (fun («?M» : Obj) => mkForall (fun («?PST» : Obj) => mkForall (fun («?UTC» : Obj) => mkForall (fun («?Y» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?UTC», ap (Const.«HourFn») ([«?H1», ap (Const.«DayFn») ([«?D», ap (Const.«MonthFn») ([«?M», ap (Const.«YearFn») ([«?Y»])])])])]), ap (Const.«instance») ([«?PST», ap (Const.«HourFn») ([«?H2», ap (Const.«DayFn») ([«?D», ap (Const.«MonthFn») ([«?M», ap (Const.«YearFn») ([«?Y»])])])])]), ap (Const.«equal») ([ap (Const.«RelativeTimeFn») ([«?UTC», Const.«PacificTimeZone»]), «?PST»])]) (ap (Const.«equal») ([«?H2», ap (Const.«AdditionFn») ([«?H1», numLit "8"])]))))))))),
ap (Const.«instance») ([Const.«MountainTimeZone», Const.«TimeZone»]),
mkForall (fun («?D» : Obj) => mkForall (fun («?H1» : Obj) => mkForall (fun («?H2» : Obj) => mkForall (fun («?M» : Obj) => mkForall (fun («?MST» : Obj) => mkForall (fun («?UTC» : Obj) => mkForall (fun («?Y» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?UTC», ap (Const.«HourFn») ([«?H1», ap (Const.«DayFn») ([«?D», ap (Const.«MonthFn») ([«?M», ap (Const.«YearFn») ([«?Y»])])])])]), ap (Const.«instance») ([«?MST», ap (Const.«HourFn») ([«?H2», ap (Const.«DayFn») ([«?D», ap (Const.«MonthFn») ([«?M», ap (Const.«YearFn») ([«?Y»])])])])]), ap (Const.«equal») ([ap (Const.«RelativeTimeFn») ([«?UTC», Const.«MountainTimeZone»]), «?MST»])]) (ap (Const.«equal») ([«?H2», ap (Const.«AdditionFn») ([«?H1», numLit "7"])]))))))))),
ap (Const.«instance») ([Const.«CentralTimeZone», Const.«TimeZone»]),
mkForall (fun («?CST» : Obj) => mkForall (fun («?D» : Obj) => mkForall (fun («?H1» : Obj) => mkForall (fun («?H2» : Obj) => mkForall (fun («?M» : Obj) => mkForall (fun («?UTC» : Obj) => mkForall (fun («?Y» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?UTC», ap (Const.«HourFn») ([«?H1», ap (Const.«DayFn») ([«?D», ap (Const.«MonthFn») ([«?M», ap (Const.«YearFn») ([«?Y»])])])])]), ap (Const.«instance») ([«?CST», ap (Const.«HourFn») ([«?H2», ap (Const.«DayFn») ([«?D», ap (Const.«MonthFn») ([«?M», ap (Const.«YearFn») ([«?Y»])])])])]), ap (Const.«equal») ([ap (Const.«RelativeTimeFn») ([«?UTC», Const.«CentralTimeZone»]), «?CST»])]) (ap (Const.«equal») ([«?H2», ap (Const.«AdditionFn») ([«?H1», numLit "6"])]))))))))),
ap (Const.«instance») ([Const.«EasternTimeZone», Const.«TimeZone»]),
mkForall (fun («?D» : Obj) => mkForall (fun («?EST» : Obj) => mkForall (fun («?H1» : Obj) => mkForall (fun («?H2» : Obj) => mkForall (fun («?M» : Obj) => mkForall (fun («?UTC» : Obj) => mkForall (fun («?Y» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?UTC», ap (Const.«HourFn») ([«?H1», ap (Const.«DayFn») ([«?D», ap (Const.«MonthFn») ([«?M», ap (Const.«YearFn») ([«?Y»])])])])]), ap (Const.«instance») ([«?EST», ap (Const.«HourFn») ([«?H2», ap (Const.«DayFn») ([«?D», ap (Const.«MonthFn») ([«?M», ap (Const.«YearFn») ([«?Y»])])])])]), ap (Const.«equal») ([ap (Const.«RelativeTimeFn») ([«?UTC», Const.«EasternTimeZone»]), «?EST»])]) (ap (Const.«equal») ([«?H2», ap (Const.«AdditionFn») ([«?H1», numLit "5"])]))))))))),
ap (Const.«instance») ([Const.«RelativeTimeFn», Const.«BinaryFunction»]),
ap (Const.«instance») ([Const.«RelativeTimeFn», Const.«TemporalRelation»]),
ap (Const.«instance») ([Const.«RelativeTimeFn», Const.«TotalValuedRelation»]),
ap (Const.«subclass») ([Const.«SocialRole», Const.«RelationalAttribute»]),
mkForall (fun («?ATTRIBUTE» : Obj) => mkForall (fun («?PERSON» : Obj) => mkImp (mkAnd [ap (Const.«attribute») ([«?PERSON», «?ATTRIBUTE»]), ap (Const.«instance») ([«?ATTRIBUTE», Const.«SocialRole»])]) (ap (Const.«instance») ([«?PERSON», Const.«Human»])))),
ap (Const.«instance») ([Const.«Unemployed», Const.«SocialRole»]),
mkForall (fun («?PERSON» : Obj) => mkForall (fun («?T» : Obj) => mkIff (ap (Const.«holdsDuring») ([«?T», mkAnd [ap (Const.«instance») ([«?PERSON», Const.«Human»]), mkForall (fun («?ORG» : Obj) => mkNot (ap (Const.«employs») ([«?ORG», «?PERSON»])))]])) (ap (Const.«holdsDuring») ([«?T», ap (Const.«attribute») ([«?PERSON», Const.«Unemployed»])])))),
ap (Const.«subclass») ([Const.«Position», Const.«SocialRole»]),
ap (Const.«instance») ([Const.«occupiesPosition», Const.«TernaryPredicate»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?ORG» : Obj) => mkForall (fun («?POSITION» : Obj) => mkImp (ap (Const.«occupiesPosition») ([«?AGENT», «?POSITION», «?ORG»])) (ap (Const.«attribute») ([«?AGENT», «?POSITION»]))))),
mkForall (fun («?ORG» : Obj) => mkForall (fun («?PERSON» : Obj) => mkImp (ap (Const.«employs») ([«?ORG», «?PERSON»])) (mkExists (fun («?POSITION» : Obj) => ap (Const.«occupiesPosition») ([«?PERSON», «?POSITION», «?ORG»]))))),
mkForall (fun («?ORGANIZATION» : Obj) => mkForall (fun («?PERSON» : Obj) => mkForall (fun («?POSITION» : Obj) => mkImp (ap (Const.«occupiesPosition») ([«?PERSON», «?POSITION», «?ORGANIZATION»])) (ap (Const.«member») ([«?PERSON», «?ORGANIZATION»]))))),
ap (Const.«subclass») ([Const.«NormativeAttribute», Const.«RelationalAttribute»]),
ap (Const.«instance») ([Const.«modalAttribute», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«modalAttribute», Const.«AsymmetricRelation»]),
ap (Const.«instance») ([Const.«modalAttribute», Const.«IrreflexiveRelation»]),
ap (Const.«instance») ([Const.«modalAttribute», Const.«PartialValuedRelation»]),
ap (Const.«subrelation») ([Const.«modalAttribute», Const.«property»]),
mkForall (fun («?FORMULA1» : Obj) => mkForall (fun («?FORMULA2» : Obj) => mkForall (fun («?PROP» : Obj) => mkImp (mkAnd [ap (Const.«modalAttribute») ([«?FORMULA1», «?PROP»]), ap (Const.«entails») ([«?FORMULA1», «?FORMULA2»])]) (ap (Const.«modalAttribute») ([«?FORMULA2», «?PROP»]))))),
mkForall (fun («?FORMULA» : Obj) => mkImp (ap (Const.«modalAttribute») ([«?FORMULA», Const.«Permission»])) (ap (Const.«modalAttribute») ([«?FORMULA», Const.«Possibility»]))),
ap (Const.«subclass») ([Const.«SubjectiveAssessmentAttribute», Const.«NormativeAttribute»]),
ap (Const.«disjoint») ([Const.«SubjectiveAssessmentAttribute», Const.«ObjectiveNorm»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?JUDGE» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?JUDGE», Const.«Judging»]), ap (Const.«agent») ([«?JUDGE», «?AGENT»]), ap (Const.«patient») ([«?JUDGE», «?OBJ»])]) (mkExists (fun («?ATR» : Obj) => mkAnd [ap (Const.«instance») ([«?ATR», Const.«SubjectiveAssessmentAttribute»]), ap (Const.«holdsDuring») ([ap (Const.«ImmediateFutureFn») ([«?JUDGE»]), ap (Const.«believes») ([«?AGENT», ap (Const.«property») ([«?OBJ», «?ATR»])])])]))))),
ap (Const.«subclass») ([Const.«SubjectiveStrongPositiveAttribute», Const.«SubjectiveAssessmentAttribute»]),
ap (Const.«subclass») ([Const.«SubjectiveWeakPositiveAttribute», Const.«SubjectiveAssessmentAttribute»]),
ap (Const.«subclass») ([Const.«SubjectiveStrongNegativeAttribute», Const.«SubjectiveAssessmentAttribute»]),
ap (Const.«subclass») ([Const.«SubjectiveWeakNegativeAttribute», Const.«SubjectiveAssessmentAttribute»]),
ap (Const.«subclass») ([Const.«ObjectiveNorm», Const.«NormativeAttribute»]),
ap (Const.«subclass») ([Const.«ContestAttribute», Const.«ObjectiveNorm»]),
mkForall (fun («?ATTR» : Obj) => mkForall (fun («?THING» : Obj) => mkImp (mkAnd [ap (Const.«property») ([«?THING», «?ATTR»]), ap (Const.«instance») ([«?ATTR», Const.«ContestAttribute»])]) (mkExists (fun («?CONTEST» : Obj) => mkAnd [ap (Const.«instance») ([«?CONTEST», Const.«Contest»]), mkOr [ap (Const.«agent») ([«?CONTEST», «?THING»]), ap (Const.«patient») ([«?CONTEST», «?THING»]), ap (Const.«subProcess») ([«?THING», «?CONTEST»])]])))),
ap (Const.«subclass») ([Const.«AlethicAttribute», Const.«ObjectiveNorm»]),
ap (Const.«instance») ([Const.«Possibility», Const.«AlethicAttribute»]),
ap (Const.«instance») ([Const.«Necessity», Const.«AlethicAttribute»]),
mkForall (fun («?FORMULA» : Obj) => mkIff (ap (Const.«modalAttribute») ([«?FORMULA», Const.«Necessity»])) (mkNot (ap (Const.«modalAttribute») ([mkNot («?FORMULA»), Const.«Possibility»])))),
mkForall (fun («?FORMULA» : Obj) => mkImp (ap (Const.«modalAttribute») ([«?FORMULA», Const.«Necessity»])) (ap (Const.«modalAttribute») ([«?FORMULA», Const.«Possibility»]))),
ap (Const.«instance») ([Const.«holdsRight», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«holdsRight», Const.«AsymmetricRelation»]),
ap (Const.«instance») ([Const.«confersRight», Const.«TernaryPredicate»]),
mkForall (fun («?AGENT1» : Obj) => mkForall (fun («?AGENT2» : Obj) => mkForall (fun («?FORMULA» : Obj) => mkImp (ap (Const.«confersRight») ([«?FORMULA», «?AGENT1», «?AGENT2»])) (ap (Const.«holdsRight») ([«?FORMULA», «?AGENT2»]))))),
ap (Const.«instance») ([Const.«holdsObligation», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«holdsObligation», Const.«AsymmetricRelation»]),
ap (Const.«relatedInternalConcept») ([Const.«holdsObligation», Const.«holdsRight»]),
ap (Const.«instance») ([Const.«confersObligation», Const.«TernaryPredicate»]),
ap (Const.«relatedInternalConcept») ([Const.«confersObligation», Const.«confersRight»]),
mkForall (fun («?AGENT1» : Obj) => mkForall (fun («?AGENT2» : Obj) => mkForall (fun («?FORMULA» : Obj) => mkImp (ap (Const.«confersObligation») ([«?FORMULA», «?AGENT1», «?AGENT2»])) (ap (Const.«holdsObligation») ([«?FORMULA», «?AGENT2»]))))),
ap (Const.«subclass») ([Const.«DeonticAttribute», Const.«ObjectiveNorm»]),
ap (Const.«instance») ([Const.«Permission», Const.«DeonticAttribute»]),
ap (Const.«instance») ([Const.«Obligation», Const.«DeonticAttribute»]),
mkForall (fun («?FORMULA» : Obj) => mkIff (ap (Const.«modalAttribute») ([«?FORMULA», Const.«Obligation»])) (mkNot (ap (Const.«modalAttribute») ([mkNot («?FORMULA»), Const.«Permission»])))),
mkForall (fun («?FORMULA» : Obj) => mkImp (ap (Const.«modalAttribute») ([«?FORMULA», Const.«Obligation»])) (ap (Const.«modalAttribute») ([«?FORMULA», Const.«Permission»]))),
ap (Const.«subAttribute») ([Const.«Law», Const.«Obligation»]),
ap (Const.«instance») ([Const.«Law», Const.«DeonticAttribute»]),
ap (Const.«subAttribute») ([Const.«Promise», Const.«Obligation»]),
ap (Const.«instance») ([Const.«Prohibition», Const.«DeonticAttribute»]),
mkForall (fun («?FORMULA» : Obj) => mkIff (ap (Const.«modalAttribute») ([«?FORMULA», Const.«Prohibition»])) (mkNot (ap (Const.«modalAttribute») ([«?FORMULA», Const.«Permission»])))),
ap (Const.«subclass») ([Const.«ProbabilityAttribute», Const.«ObjectiveNorm»]),
ap (Const.«instance») ([Const.«Likely», Const.«ProbabilityAttribute»]),
ap (Const.«contraryAttribute») ([Const.«Likely», Const.«Unlikely»]),
mkForall (fun («?FORMULA» : Obj) => mkImp (ap (Const.«modalAttribute») ([«?FORMULA», Const.«Likely»])) (ap (Const.«greaterThan») ([ap (Const.«ProbabilityFn») ([ap (Const.«truth») ([«?FORMULA», Const.«True»])]), ap (Const.«ProbabilityFn») ([ap (Const.«truth») ([«?FORMULA», Const.«False»])])]))),
ap (Const.«instance») ([Const.«Unlikely», Const.«ProbabilityAttribute»]),
mkForall (fun («?FORMULA» : Obj) => mkImp (ap (Const.«modalAttribute») ([«?FORMULA», Const.«Unlikely»])) (ap (Const.«greaterThan») ([ap (Const.«ProbabilityFn») ([ap (Const.«truth») ([«?FORMULA», Const.«False»])]), ap (Const.«ProbabilityFn») ([ap (Const.«truth») ([«?FORMULA», Const.«True»])])]))),
ap (Const.«subclass») ([Const.«PhysicalState», Const.«InternalAttribute»]),
ap (Const.«contraryAttribute») ([Const.«Solid», Const.«Liquid», Const.«Gas», Const.«Plasma»]),
ap (Const.«exhaustiveAttribute») ([Const.«PhysicalState», Const.«Solid», Const.«Liquid», Const.«Gas», Const.«Plasma»]),
ap (Const.«instance») ([Const.«Solid», Const.«PhysicalState»]),
ap (Const.«instance») ([Const.«Liquid», Const.«PhysicalState»]),
ap (Const.«subAttribute») ([Const.«Liquid», Const.«Fluid»]),
mkForall (fun («?OBJ» : Obj) => mkImp (ap (Const.«instance») ([«?OBJ», Const.«Solution»])) (ap (Const.«attribute») ([«?OBJ», Const.«Liquid»]))),
ap (Const.«instance») ([Const.«Gas», Const.«PhysicalState»]),
ap (Const.«subAttribute») ([Const.«Gas», Const.«Fluid»]),
mkForall (fun («?OBJ» : Obj) => mkImp (ap (Const.«instance») ([«?OBJ», Const.«Substance»])) (mkExists (fun («?ATTR» : Obj) => mkAnd [ap (Const.«instance») ([«?ATTR», Const.«PhysicalState»]), ap (Const.«attribute») ([«?OBJ», «?ATTR»])]))),
mkForall (fun («?ATTR» : Obj) => mkForall (fun («?OBJ» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?ATTR», Const.«PhysicalState»]), ap (Const.«attribute») ([«?OBJ», «?ATTR»])]) (ap (Const.«instance») ([«?OBJ», Const.«Substance»])))),
ap (Const.«instance») ([Const.«Plasma», Const.«PhysicalState»]),
ap (Const.«subAttribute») ([Const.«Plasma», Const.«Fluid»]),
ap (Const.«instance») ([Const.«Fluid», Const.«InternalAttribute»]),
mkForall (fun («?X» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?X», Const.«Substance»]), mkOr [ap (Const.«attribute») ([«?X», Const.«Gas»]), ap (Const.«attribute») ([«?X», Const.«Liquid»]), ap (Const.«attribute») ([«?X», Const.«Plasma»])]]) (ap (Const.«attribute») ([«?X», Const.«Fluid»]))),
ap (Const.«subclass») ([Const.«PerceptualAttribute», Const.«RelationalAttribute»]),
mkForall (fun («?OBJ» : Obj) => mkForall (fun («?PERCEPTION» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?PERCEPTION», Const.«Perception»]), ap (Const.«patient») ([«?PERCEPTION», «?OBJ»])]) (mkExists (fun («?PROP» : Obj) => mkAnd [ap (Const.«instance») ([«?PROP», Const.«PerceptualAttribute»]), ap (Const.«attribute») ([«?OBJ», «?PROP»])])))),
ap (Const.«subclass») ([Const.«TasteAttribute», Const.«PerceptualAttribute»]),
mkForall (fun («?OBJ» : Obj) => mkImp (ap (Const.«instance») ([«?OBJ», ap (Const.«FoodForFn») ([Const.«Animal»])])) (mkExists (fun («?ATTR» : Obj) => mkAnd [ap (Const.«instance») ([«?ATTR», Const.«TasteAttribute»]), ap (Const.«attribute») ([«?OBJ», «?ATTR»])]))),
ap (Const.«subclass») ([Const.«OlfactoryAttribute», Const.«PerceptualAttribute»]),
ap (Const.«subclass») ([Const.«VisualAttribute», Const.«PerceptualAttribute»]),
ap (Const.«instance») ([Const.«Illuminated», Const.«VisualAttribute»]),
ap (Const.«instance») ([Const.«Unilluminated», Const.«VisualAttribute»]),
ap (Const.«contraryAttribute») ([Const.«Unilluminated», Const.«Illuminated»]),
ap (Const.«subclass») ([Const.«ColorAttribute», Const.«VisualAttribute»]),
ap (Const.«subclass») ([Const.«PrimaryColor», Const.«ColorAttribute»]),
ap (Const.«instance») ([Const.«Red», Const.«PrimaryColor»]),
ap (Const.«instance») ([Const.«Blue», Const.«PrimaryColor»]),
ap (Const.«instance») ([Const.«Yellow», Const.«PrimaryColor»]),
ap (Const.«instance») ([Const.«White», Const.«PrimaryColor»]),
ap (Const.«instance») ([Const.«Black», Const.«PrimaryColor»]),
ap (Const.«instance») ([Const.«Monochromatic», Const.«ColorAttribute»]),
mkForall (fun («?COLOR» : Obj) => mkForall (fun («?OBJ» : Obj) => mkForall (fun («?PART» : Obj) => mkImp (mkAnd [ap (Const.«attribute») ([«?OBJ», Const.«Monochromatic»]), ap (Const.«superficialPart») ([«?PART», «?OBJ»]), ap (Const.«attribute») ([«?PART», «?COLOR»]), ap (Const.«instance») ([«?COLOR», Const.«PrimaryColor»])]) (mkForall (fun («?ELEMENT» : Obj) => mkImp (ap (Const.«superficialPart») ([«?ELEMENT», «?OBJ»])) (ap (Const.«attribute») ([«?ELEMENT», «?COLOR»]))))))),
mkForall (fun («?OBJ» : Obj) => mkImp (ap (Const.«instance») ([«?OBJ», Const.«Object»])) (mkOr [ap (Const.«attribute») ([«?OBJ», Const.«Monochromatic»]), ap (Const.«attribute») ([«?OBJ», Const.«Polychromatic»])])),
ap (Const.«instance») ([Const.«Polychromatic», Const.«ColorAttribute»]),
ap (Const.«contraryAttribute») ([Const.«Polychromatic», Const.«Monochromatic»]),
mkForall (fun («?OBJ» : Obj) => mkImp (ap (Const.«attribute») ([«?OBJ», Const.«Polychromatic»])) (mkExists (fun («?PART1» : Obj) => mkExists (fun («?PART2» : Obj) => mkExists (fun («?COLOR1» : Obj) => mkExists (fun («?COLOR2» : Obj) => mkAnd [ap (Const.«superficialPart») ([«?PART1», «?OBJ»]), ap (Const.«superficialPart») ([«?PART2», «?OBJ»]), ap (Const.«attribute») ([«?PART1», «?COLOR1»]), ap (Const.«attribute») ([«?PART2», «?COLOR2»]), ap (Const.«instance») ([«?COLOR1», Const.«ColorAttribute»]), ap (Const.«instance») ([«?COLOR2», Const.«ColorAttribute»]), mkNot (ap (Const.«equal») ([«?COLOR1», «?COLOR2»]))])))))),
ap (Const.«subclass») ([Const.«StructureAttribute», Const.«InternalAttribute»]),
ap (Const.«subclass») ([Const.«ShapeAttribute», Const.«StructureAttribute»]),
mkForall (fun («?ATTRIBUTE» : Obj) => mkForall (fun («?OBJ» : Obj) => mkForall (fun («?SURFACE» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?ATTRIBUTE», Const.«ShapeAttribute»]), ap (Const.«attribute») ([«?OBJ», «?ATTRIBUTE»]), ap (Const.«surface») ([«?SURFACE», «?OBJ»])]) (ap (Const.«attribute») ([«?SURFACE», «?ATTRIBUTE»]))))),
ap (Const.«instance») ([Const.«Pliable», Const.«InternalAttribute»]),
mkForall (fun («?OBJ» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?OBJ», Const.«Object»]), ap (Const.«attribute») ([«?OBJ», Const.«Pliable»])]) (mkExists (fun («?CHANGE» : Obj) => mkAnd [ap (Const.«instance») ([«?CHANGE», Const.«ShapeChange»]), ap (Const.«patient») ([«?CHANGE», «?OBJ»])]))),
ap (Const.«instance») ([Const.«Rigid», Const.«InternalAttribute»]),
ap (Const.«contraryAttribute») ([Const.«Rigid», Const.«Pliable»]),
ap (Const.«subclass») ([Const.«TextureAttribute», Const.«PerceptualAttribute»]),
mkForall (fun («?ATTRIBUTE» : Obj) => mkForall (fun («?OBJ» : Obj) => mkForall (fun («?SURFACE» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?ATTRIBUTE», Const.«TextureAttribute»]), ap (Const.«attribute») ([«?OBJ», «?ATTRIBUTE»]), ap (Const.«surface») ([«?SURFACE», «?OBJ»])]) (ap (Const.«attribute») ([«?SURFACE», «?ATTRIBUTE»]))))),
ap (Const.«instance») ([Const.«Smooth», Const.«TextureAttribute»]),
ap (Const.«instance») ([Const.«Rough», Const.«TextureAttribute»]),
ap (Const.«contraryAttribute») ([Const.«Smooth», Const.«Rough»]),
ap (Const.«subclass») ([Const.«GeometricFigure», Const.«ShapeAttribute»]),
ap (Const.«partition») ([Const.«GeometricFigure», Const.«GeometricPoint», Const.«OneDimensionalFigure», Const.«TwoDimensionalFigure», Const.«ThreeDimensionalFigure»]),
ap (Const.«subclass») ([Const.«GeometricPoint», Const.«GeometricFigure»]),
ap (Const.«subclass») ([Const.«OneDimensionalFigure», Const.«GeometricFigure»]),
ap (Const.«subclass») ([Const.«TwoDimensionalFigure», Const.«GeometricFigure»]),
ap (Const.«partition») ([Const.«TwoDimensionalFigure», Const.«OpenTwoDimensionalFigure», Const.«ClosedTwoDimensionalFigure»]),
ap (Const.«subclass») ([Const.«OpenTwoDimensionalFigure», Const.«TwoDimensionalFigure»]),
ap (Const.«subclass») ([Const.«TwoDimensionalAngle», Const.«OpenTwoDimensionalFigure»]),
ap (Const.«subclass») ([Const.«ClosedTwoDimensionalFigure», Const.«TwoDimensionalFigure»]),
ap (Const.«subclass») ([Const.«ThreeDimensionalFigure», Const.«GeometricFigure»]),
ap (Const.«instance») ([Const.«geometricPart», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«geometricPart», Const.«PartialOrderingRelation»]),
ap (Const.«subrelation») ([Const.«pointOfFigure», Const.«geometricPart»]),
ap (Const.«instance») ([Const.«pointOfFigure», Const.«BinaryPredicate»]),
ap (Const.«subrelation») ([Const.«angleOfFigure», Const.«geometricPart»]),
ap (Const.«instance») ([Const.«angleOfFigure», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«pointOfIntersection», Const.«TernaryPredicate»]),
mkForall (fun («?FIGURE1» : Obj) => mkForall (fun («?FIGURE2» : Obj) => mkForall (fun («?POINT» : Obj) => mkImp (ap (Const.«pointOfIntersection») ([«?FIGURE1», «?FIGURE2», «?POINT»])) (mkAnd [ap (Const.«pointOfFigure») ([«?POINT», «?FIGURE1»]), ap (Const.«pointOfFigure») ([«?POINT», «?FIGURE2»])])))),
ap (Const.«instance») ([Const.«parallel», Const.«BinaryPredicate»]),
mkForall (fun («?LINE1» : Obj) => mkForall (fun («?LINE2» : Obj) => mkImp (ap (Const.«parallel») ([«?LINE1», «?LINE2»])) (mkNot (mkExists (fun («?POINT» : Obj) => ap (Const.«pointOfIntersection») ([«?LINE1», «?LINE2», «?POINT»])))))),
ap (Const.«instance») ([Const.«angularMeasure», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«angularMeasure», Const.«TotalValuedRelation»]),
ap (Const.«instance») ([Const.«relativeAngle», Const.«TernaryPredicate»]),
ap (Const.«instance») ([Const.«relativeAngle», Const.«TotalValuedRelation»]),
mkForall (fun («?L1» : Obj) => mkForall (fun («?L2» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?L1», Const.«Object»]), ap (Const.«attribute») ([«?L1», Const.«LongAndThin»]), ap (Const.«instance») ([«?L2», Const.«Object»]), ap (Const.«attribute») ([«?L2», Const.«LongAndThin»]), ap (Const.«connected») ([«?L1», «?L2»]), mkNot (ap (Const.«equal») ([«?L1», «?L2»]))]) (mkExists (fun («?M» : Obj) => ap (Const.«relativeAngle») ([«?L1», «?L2», «?M»]))))),
mkForall (fun («?L1» : Obj) => mkForall (fun («?L2» : Obj) => mkForall (fun («?M» : Obj) => mkImp (ap (Const.«relativeAngle») ([«?L1», «?L2», «?M»])) (mkAnd [ap (Const.«instance») ([«?L1», Const.«Object»]), ap (Const.«attribute») ([«?L1», Const.«LongAndThin»]), ap (Const.«instance») ([«?L2», Const.«Object»]), ap (Const.«attribute») ([«?L2», Const.«LongAndThin»]), ap (Const.«connected») ([«?L1», «?L2»]), mkNot (ap (Const.«equal») ([«?L1», «?L2»]))])))),
mkForall (fun («?E1» : Obj) => mkForall (fun («?E2» : Obj) => mkForall (fun («?E3» : Obj) => mkForall (fun («?E4» : Obj) => mkForall (fun («?N» : Obj) => mkForall (fun («?N1» : Obj) => mkForall (fun («?N2» : Obj) => mkForall (fun («?N3» : Obj) => mkForall (fun («?O1» : Obj) => mkForall (fun («?O2» : Obj) => mkForall (fun («?U» : Obj) => mkImp (mkAnd [ap (Const.«relativeAngle») ([«?O1», «?O2», «?N»]), ap (Const.«physicalEnd») ([«?E1», «?O1»]), ap (Const.«physicalEnd») ([«?E2», «?O1»]), mkNot (ap (Const.«equal») ([«?E1», «?E2»])), ap (Const.«length») ([«?O1», ap (Const.«MeasureFn») ([«?N1», «?U»])]), ap (Const.«length») ([«?O2», ap (Const.«MeasureFn») ([«?N2», «?U»])]), ap (Const.«distance») ([«?E1», «?E3», ap (Const.«MeasureFn») ([«?N3», «?U»])]), ap (Const.«physicalEnd») ([«?E3», «?O2»]), ap (Const.«physicalEnd») ([«?E4», «?O2»]), mkNot (ap (Const.«equal») ([«?E3», «?E4»])), mkNot (ap (Const.«meetsSpatially») ([«?E1», «?E3»]))]) (ap (Const.«equal») ([«?N», ap (Const.«ArcCosineFn») ([ap (Const.«DivisionFn») ([ap (Const.«SubtractionFn») ([ap (Const.«SubtractionFn») ([ap (Const.«MultiplicationFn») ([«?N3», «?N3»]), ap (Const.«MultiplicationFn») ([«?N1», «?N1»])]), ap (Const.«MultiplicationFn») ([«?N2», «?N2»])]), ap (Const.«MultiplicationFn») ([numLit "2.0", ap (Const.«MultiplicationFn») ([«?N1», «?N2»])])])])]))))))))))))),
ap (Const.«instance») ([Const.«physicalEnd», Const.«BinaryPredicate»]),
ap (Const.«subrelation») ([Const.«physicalEnd», Const.«properPart»]),
ap (Const.«subrelation») ([Const.«physicalEnd», Const.«part»]),
mkForall (fun («?O» : Obj) => mkForall (fun («?P1» : Obj) => mkImp (ap (Const.«physicalEnd») ([«?P1», «?O»])) (ap (Const.«attribute») ([«?O», Const.«LongAndThin»])))),
mkForall (fun («?D» : Obj) => mkForall (fun («?O» : Obj) => mkForall (fun («?P1» : Obj) => mkForall (fun («?P2» : Obj) => mkForall (fun («?U» : Obj) => mkImp (mkAnd [ap (Const.«physicalEnd») ([«?P1», «?O»]), ap (Const.«physicalEnd») ([«?P2», «?O»]), mkNot (ap (Const.«equal») ([«?P1», «?P2»])), ap (Const.«distance») ([«?P1», «?P2», ap (Const.«MeasureFn») ([«?D», «?U»])])]) (mkNot (mkExists (fun («?OP1» : Obj) => mkExists (fun («?OP2» : Obj) => mkExists (fun («?N2» : Obj) => mkAnd [ap (Const.«physicalEnd») ([«?OP1», «?O»]), ap (Const.«physicalEnd») ([«?OP2», «?O»]), mkNot (ap (Const.«equal») ([«?OP1», «?OP2»])), ap (Const.«distance») ([«?OP1», «?OP2», ap (Const.«MeasureFn») ([«?N2», «?U»])]), ap (Const.«greaterThan») ([«?N2», «?D»])])))))))))),
ap (Const.«instance») ([Const.«lineMeasure», Const.«BinaryPredicate»]),
ap (Const.«instance») ([Const.«lineMeasure», Const.«TotalValuedRelation»]),
ap (Const.«instance») ([Const.«geometricDistance», Const.«TernaryPredicate»]),
ap (Const.«instance») ([Const.«geometricDistance», Const.«SingleValuedRelation»]),
ap (Const.«instance») ([Const.«geometricDistance», Const.«TotalValuedRelation»]),
mkForall (fun («?LENGTH» : Obj) => mkForall (fun («?POINT1» : Obj) => mkForall (fun («?POINT2» : Obj) => mkImp (ap (Const.«geometricDistance») ([«?POINT1», «?POINT2», «?LENGTH»])) (ap (Const.«geometricDistance») ([«?POINT2», «?POINT1», «?LENGTH»]))))),
ap (Const.«subclass») ([Const.«SaturationAttribute», Const.«InternalAttribute»]),
ap (Const.«instance») ([Const.«Dry», Const.«SaturationAttribute»]),
ap (Const.«contraryAttribute») ([Const.«Dry», Const.«Damp»]),
mkForall (fun («?OBJ» : Obj) => mkImp (ap (Const.«attribute») ([«?OBJ», Const.«Dry»])) (mkNot (mkExists (fun («?SUBOBJ» : Obj) => mkAnd [ap (Const.«part») ([«?SUBOBJ», «?OBJ»]), ap (Const.«attribute») ([«?SUBOBJ», Const.«Liquid»])])))),
ap (Const.«instance») ([Const.«Damp», Const.«SaturationAttribute»]),
ap (Const.«instance») ([Const.«Wet», Const.«SaturationAttribute»]),
ap (Const.«subAttribute») ([Const.«Wet», Const.«Damp»]),
mkForall (fun («?OBJ» : Obj) => mkImp (ap (Const.«attribute») ([«?OBJ», Const.«Wet»])) (mkForall (fun («?PART» : Obj) => mkImp (ap (Const.«part») ([«?PART», «?OBJ»])) (mkExists (fun («?SUBPART» : Obj) => mkAnd [ap (Const.«part») ([«?SUBPART», «?PART»]), ap (Const.«attribute») ([«?SUBPART», Const.«Liquid»])]))))),
ap (Const.«subclass») ([Const.«BiologicalAttribute», Const.«InternalAttribute»]),
mkForall (fun («?ATT» : Obj) => mkForall (fun («?ORG» : Obj) => mkImp (mkAnd [ap (Const.«attribute») ([«?ORG», «?ATT»]), ap (Const.«instance») ([«?ATT», Const.«BiologicalAttribute»])]) (ap (Const.«instance») ([«?ORG», Const.«OrganicObject»])))),
ap (Const.«subclass») ([Const.«BodyPosition», Const.«BiologicalAttribute»]),
mkForall (fun («?ANIMAL» : Obj) => mkImp (ap (Const.«instance») ([«?ANIMAL», Const.«Animal»])) (mkOr [mkExists (fun («?MOTION» : Obj) => mkAnd [ap (Const.«instance») ([«?MOTION», Const.«BodyMotion»]), ap (Const.«agent») ([«?MOTION», «?ANIMAL»])]), mkExists (fun («?ATTR» : Obj) => mkAnd [ap (Const.«instance») ([«?ATTR», Const.«BodyPosition»]), ap (Const.«attribute») ([«?ANIMAL», «?ATTR»])])])),
ap (Const.«instance») ([Const.«Standing», Const.«BodyPosition»]),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?AMBULATE» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?AMBULATE», Const.«Ambulating»]), ap (Const.«agent») ([«?AMBULATE», «?AGENT»])]) (ap (Const.«attribute») ([«?AGENT», Const.«Standing»])))),
ap (Const.«instance») ([Const.«Sitting», Const.«BodyPosition»]),
ap (Const.«instance») ([Const.«Prostrate», Const.«BodyPosition»]),
ap (Const.«subclass») ([Const.«AnimacyAttribute», Const.«BiologicalAttribute»]),
ap (Const.«exhaustiveAttribute») ([Const.«AnimacyAttribute», Const.«Living», Const.«Dead»]),
ap (Const.«instance») ([Const.«Living», Const.«AnimacyAttribute»]),
mkForall (fun («?ORGANISM» : Obj) => mkForall (fun («?PROCESS» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?ORGANISM», Const.«Organism»]), ap (Const.«agent») ([«?PROCESS», «?ORGANISM»])]) (ap (Const.«holdsDuring») ([ap (Const.«WhenFn») ([«?PROCESS»]), ap (Const.«attribute») ([«?ORGANISM», Const.«Living»])])))),
ap (Const.«instance») ([Const.«Dead», Const.«AnimacyAttribute»]),
ap (Const.«subAttribute») ([Const.«Dead», Const.«Unconscious»]),
ap (Const.«contraryAttribute») ([Const.«Dead», Const.«Living»]),
mkForall (fun («?ORG» : Obj) => mkImp (ap (Const.«instance») ([«?ORG», Const.«Organism»])) (mkExists (fun («?ATTR» : Obj) => mkAnd [ap (Const.«instance») ([«?ATTR», Const.«AnimacyAttribute»]), ap (Const.«attribute») ([«?ORG», «?ATTR»])]))),
ap (Const.«subclass») ([Const.«SexAttribute», Const.«BiologicalAttribute»]),
ap (Const.«exhaustiveAttribute») ([Const.«SexAttribute», Const.«Female», Const.«Male», Const.«NonBinaryGender»]),
ap (Const.«instance») ([Const.«NonBinaryGender», Const.«SexAttribute»]),
ap (Const.«instance») ([Const.«Female», Const.«SexAttribute»]),
mkForall (fun («?BODY» : Obj) => mkForall (fun («?ORG» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?BODY», Const.«ReproductiveBody»]), ap (Const.«part») ([«?BODY», «?ORG»]), ap (Const.«instance») ([«?ORG», Const.«Organism»])]) (ap (Const.«attribute») ([«?ORG», Const.«Female»])))),
ap (Const.«instance») ([Const.«Male», Const.«SexAttribute»]),
ap (Const.«contraryAttribute») ([Const.«Male», Const.«Female»]),
mkForall (fun («?ANIMAL» : Obj) => mkImp (ap (Const.«instance») ([«?ANIMAL», Const.«Animal»])) (mkExists (fun («?ATTR» : Obj) => mkAnd [ap (Const.«instance») ([«?ATTR», Const.«SexAttribute»]), ap (Const.«attribute») ([«?ANIMAL», «?ATTR»])]))),
ap (Const.«subclass») ([Const.«DevelopmentalAttribute», Const.«BiologicalAttribute»]),
ap (Const.«exhaustiveAttribute») ([Const.«DevelopmentalAttribute», Const.«FullyFormed», Const.«NonFullyFormed»]),
ap (Const.«instance») ([Const.«FullyFormed», Const.«DevelopmentalAttribute»]),
mkForall (fun («?OBJ» : Obj) => mkImp (ap (Const.«attribute») ([«?OBJ», Const.«FullyFormed»])) (mkExists (fun («?GROWTH» : Obj) => mkAnd [ap (Const.«instance») ([«?GROWTH», Const.«Growth»]), ap (Const.«experiencer») ([«?GROWTH», «?OBJ»]), ap (Const.«holdsDuring») ([ap (Const.«BeginFn») ([ap (Const.«WhenFn») ([«?OBJ»])]), ap (Const.«attribute») ([«?OBJ», Const.«NonFullyFormed»])])]))),
ap (Const.«instance») ([Const.«NonFullyFormed», Const.«DevelopmentalAttribute»]),
ap (Const.«contraryAttribute») ([Const.«NonFullyFormed», Const.«FullyFormed»]),
ap (Const.«successorAttribute») ([Const.«NonFullyFormed», Const.«FullyFormed»]),
mkForall (fun («?ORG» : Obj) => mkImp (ap (Const.«instance») ([«?ORG», Const.«Organism»])) (mkExists (fun («?ATTR» : Obj) => mkAnd [ap (Const.«instance») ([«?ATTR», Const.«DevelopmentalAttribute»]), ap (Const.«attribute») ([«?ORG», «?ATTR»])]))),
ap (Const.«subAttribute») ([Const.«Larval», Const.«NonFullyFormed»]),
mkForall (fun («?BIRTH» : Obj) => mkForall (fun («?BW» : Obj) => mkForall (fun («?ORG» : Obj) => mkForall (fun («?TIME» : Obj) => mkImp (mkAnd [ap (Const.«holdsDuring») ([«?TIME», ap (Const.«attribute») ([«?ORG», Const.«Larval»])]), ap (Const.«instance») ([«?BIRTH», Const.«Birth»]), ap (Const.«equal») ([«?BW», ap (Const.«WhenFn») ([«?BIRTH»])]), ap (Const.«experiencer») ([«?BIRTH», «?ORG»])]) (ap (Const.«meetsTemporally») ([«?BW», «?TIME»])))))),
ap (Const.«subAttribute») ([Const.«Embryonic», Const.«NonFullyFormed»]),
ap (Const.«contraryAttribute») ([Const.«Embryonic», Const.«Larval»]),
mkForall (fun («?ORG» : Obj) => mkImp (ap (Const.«attribute») ([«?ORG», Const.«Embryonic»])) (mkExists (fun («?BODY» : Obj) => mkAnd [ap (Const.«instance») ([«?BODY», Const.«ReproductiveBody»]), ap (Const.«located») ([«?ORG», «?BODY»])]))),
mkForall (fun («?BIRTH» : Obj) => mkForall (fun («?BW» : Obj) => mkForall (fun («?ORG» : Obj) => mkForall (fun («?TIME» : Obj) => mkImp (mkAnd [ap (Const.«holdsDuring») ([«?TIME», ap (Const.«attribute») ([«?ORG», Const.«Embryonic»])]), ap (Const.«instance») ([«?BIRTH», Const.«Birth»]), ap (Const.«equal») ([«?BW», ap (Const.«WhenFn») ([«?BIRTH»])]), ap (Const.«experiencer») ([«?BIRTH», «?ORG»])]) (mkNot (ap (Const.«overlapsTemporally») ([«?TIME», «?BW»]))))))),
ap (Const.«subclass») ([Const.«DiseaseOrSyndrome», Const.«BiologicalAttribute»]),
ap (Const.«instance») ([Const.«ImpairedBodyPartFn», Const.«UnaryFunction»]),
mkForall (fun («?F» : Obj) => mkForall (fun («?H» : Obj) => mkForall (fun («?P» : Obj) => mkForall (fun («?PI» : Obj) => mkForall (fun («?T» : Obj) => mkImp (mkAnd [ap (Const.«holdsDuring») ([«?T», ap (Const.«attribute») ([«?H», ap (Const.«ImpairedBodyPartFn») ([«?P»])])]), ap (Const.«instance») ([«?PI», «?P»]), ap (Const.«part») ([«?PI», «?H»]), ap (Const.«hasPurpose») ([«?PI», «?F»])]) (ap (Const.«modalAttribute») ([mkNot («?F»), Const.«Likely»]))))))),
ap (Const.«instance») ([Const.«DeadOrMissingBodyPartFn», Const.«UnaryFunction»]),
ap (Const.«relatedInternalConcept») ([Const.«DeadOrMissingBodyPartFn», Const.«DeadFn»]),
mkForall (fun («?F» : Obj) => mkForall (fun («?H» : Obj) => mkForall (fun («?P» : Obj) => mkForall (fun («?PI» : Obj) => mkForall (fun («?T» : Obj) => mkImp (mkAnd [ap (Const.«holdsDuring») ([«?T», ap (Const.«attribute») ([«?H», ap (Const.«DeadOrMissingBodyPartFn») ([«?P»])])]), ap (Const.«instance») ([«?PI», «?P»]), ap (Const.«part») ([«?PI», «?H»]), ap (Const.«hasPurpose») ([«?PI», «?F»])]) (mkNot («?F»))))))),
ap (Const.«subclass») ([Const.«PsychologicalAttribute», Const.«BiologicalAttribute»]),
ap (Const.«partition») ([Const.«PsychologicalAttribute», Const.«StateOfMind», Const.«TraitAttribute»]),
mkForall (fun («?ATTR» : Obj) => mkForall (fun («?ORGANISM» : Obj) => mkForall (fun («?TIME» : Obj) => mkImp (ap (Const.«instance») ([«?ATTR», Const.«PsychologicalAttribute»])) (mkImp (mkAnd [ap (Const.«holdsDuring») ([«?TIME», ap (Const.«attribute») ([«?ORGANISM», «?ATTR»])]), ap (Const.«instance») ([«?ORGANISM», Const.«Organism»])]) (ap (Const.«holdsDuring») ([«?TIME», ap (Const.«attribute») ([«?ORGANISM», Const.«Living»])])))))),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?ATTR» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?ATTR», Const.«PsychologicalAttribute»]), ap (Const.«attribute») ([«?AGENT», «?ATTR»])]) (ap (Const.«instance») ([«?AGENT», Const.«SentientAgent»])))),
ap (Const.«subclass») ([Const.«StateOfMind», Const.«PsychologicalAttribute»]),
ap (Const.«subclass») ([Const.«EmotionalState», Const.«StateOfMind»]),
mkForall (fun («?A» : Obj) => mkImp (ap (Const.«instance») ([«?A», Const.«CognitiveAgent»])) (mkExists (fun («?E» : Obj) => mkAnd [ap (Const.«instance») ([«?E», Const.«EmotionalState»]), ap (Const.«attribute») ([«?A», «?E»])]))),
ap (Const.«subclass») ([Const.«ConsciousnessAttribute», Const.«StateOfMind»]),
mkForall (fun («?AGENT» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?AGENT», Const.«SentientAgent»]), ap (Const.«attribute») ([«?AGENT», Const.«Living»])]) (mkExists (fun («?ATTR» : Obj) => mkAnd [ap (Const.«instance») ([«?ATTR», Const.«ConsciousnessAttribute»]), ap (Const.«attribute») ([«?AGENT», «?ATTR»])]))),
mkForall (fun («?AGENT» : Obj) => mkForall (fun («?ATTR» : Obj) => mkImp (mkAnd [ap (Const.«instance») ([«?ATTR», Const.«ConsciousnessAttribute»]), ap (Const.«attribute») ([«?AGENT», «?ATTR»])]) (mkAnd [ap (Const.«instance») ([«?AGENT», Const.«SentientAgent»]), ap (Const.«attribute») ([«?AGENT», Const.«Living»])]))),
ap (Const.«instance») ([Const.«Asleep», Const.«ConsciousnessAttribute»]),
ap (Const.«subclass») ([Const.«Sleeping», Const.«PsychologicalProcess»]),
mkForall (fun («?H» : Obj) => mkForall (fun («?T» : Obj) => mkImp (ap (Const.«holdsDuring») ([«?T», ap (Const.«attribute») ([«?H», Const.«Asleep»])])) (mkExists (fun («?S» : Obj) => mkAnd [ap (Const.«equal») ([«?T», ap (Const.«WhenFn») ([«?S»])]), ap (Const.«instance») ([«?S», Const.«Sleeping»]), ap (Const.«experiencer») ([«?S», «?H»])])))),
ap (Const.«instance») ([Const.«Unconscious», Const.«ConsciousnessAttribute»]),
ap (Const.«contraryAttribute») ([Const.«Unconscious», Const.«Awake»]),
ap (Const.«instance») ([Const.«Awake», Const.«ConsciousnessAttribute»]),
mkForall (fun («?AGENT» : Obj) => mkImp (mkOr [ap (Const.«attribute») ([«?AGENT», Const.«Asleep»]), ap (Const.«attribute») ([«?AGENT», Const.«Awake»])]) (ap (Const.«attribute») ([«?AGENT», Const.«Living»]))),
ap (Const.«subclass») ([Const.«TraitAttribute», Const.«PsychologicalAttribute»]),
ap (Const.«subclass») ([Const.«PsychologicalDysfunction», Const.«PsychologicalAttribute»]),
ap (Const.«subclass») ([Const.«PsychologicalDysfunction», Const.«DiseaseOrSyndrome»]),
ap (Const.«instance») ([Const.«comment», Const.«TernaryPredicate»]),
ap (Const.«instance») ([Const.«MakingFn», Const.«UnaryFunction»]),
mkForall (fun («?X» : Obj) => mkForall (fun («?Y» : Obj) => mkImp (ap (Const.«instance») ([«?X», ap (Const.«MakingFn») ([«?Y»])])) (mkExists (fun («?OBJECT» : Obj) => mkAnd [ap (Const.«instance») ([«?OBJECT», «?Y»]), ap (Const.«result») ([«?X», «?OBJECT»])])))),
ap (Const.«instance») ([Const.«minValue», Const.«TernaryPredicate»]),
ap (Const.«instance») ([Const.«maxValue», Const.«TernaryPredicate»]),
ap (Const.«instance») ([Const.«defaultMinValue», Const.«TernaryPredicate»]),
mkForallRow (fun («@ARGS» : List Obj) => mkForall (fun («?ARG» : Obj) => mkForall (fun («?N» : Obj) => mkForall (fun («?REL» : Obj) => mkForall (fun («?VAL» : Obj) => mkImp (mkAnd [ap (Const.«defaultMinValue») ([«?REL», «?ARG», «?N»]), ap («?REL») («@ARGS»), ap (Const.«equal») ([«?VAL», ap (Const.«ListOrderFn») ([ap (Const.«ListFn») («@ARGS»), «?ARG»])])]) (ap (Const.«modalAttribute») ([ap (Const.«greaterThan») ([«?VAL», «?N»]), Const.«Likely»]))))))),
ap (Const.«instance») ([Const.«defaultMaxValue», Const.«TernaryPredicate»]),
mkForallRow (fun («@ARGS» : List Obj) => mkForall (fun («?ARG» : Obj) => mkForall (fun («?N» : Obj) => mkForall (fun («?REL» : Obj) => mkForall (fun («?VAL» : Obj) => mkImp (mkAnd [ap (Const.«defaultMaxValue») ([«?REL», «?ARG», «?N»]), ap («?REL») («@ARGS»), ap (Const.«equal») ([«?VAL», ap (Const.«ListOrderFn») ([ap (Const.«ListFn») («@ARGS»), «?ARG»])])]) (ap (Const.«modalAttribute») ([ap (Const.«greaterThan») ([«?N», «?VAL»]), Const.«Likely»]))))))),
ap (Const.«instance») ([Const.«defaultValue», Const.«TernaryPredicate»]),
mkForallRow (fun («@ARGS» : List Obj) => mkForall (fun («?ARG» : Obj) => mkForall (fun («?N» : Obj) => mkForall (fun («?REL» : Obj) => mkForall (fun («?VAL» : Obj) => mkImp (mkAnd [ap (Const.«defaultValue») ([«?REL», «?ARG», «?N»]), ap («?REL») («@ARGS»), ap (Const.«equal») ([«?VAL», ap (Const.«ListOrderFn») ([ap (Const.«ListFn») («@ARGS»), «?ARG»])])]) (ap (Const.«modalAttribute») ([ap (Const.«equal») ([«?N», «?VAL»]), Const.«Likely»]))))))),
ap (Const.«subclass») ([Const.«ClosedWorldPredicate», Const.«Predicate»]),
ap (Const.«instance») ([Const.«subclass», Const.«ClosedWorldPredicate»]),
ap (Const.«instance») ([Const.«DeadFn», Const.«UnaryFunction»])
 ]

def axiomCount : Nat := axioms.length

end

end MergeTheory

end Sumo